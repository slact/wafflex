--[[autogenerated script, do not edit]] local require, module; local function main()   local Parser = require "parser"
  local Ruleset = require "ruleset"
  local Binding = require "binding"
  local inspect = require "inspect"
  
  --luacheck: globals redis cjson ARGV unpack
  local hmm = function(thing)
    local out = inspect(thing)
    for line in out:gmatch('[^\r\n]+') do
      redis.call("ECHO", line)
    end
  end
  
  Ruleset.RuleComponent.generate_refs = true
  
  local tunpack = table.unpack or unpack
  local function redis_hmset(key, tbl, ...)
    local flat = {}
    for _, k in ipairs{...} do
      if tbl[k] then
        table.insert(flat, k)
        table.insert(flat, tbl[k])
      end
    end
    if #flat > 0 then
      redis.call("HMSET", key, tunpack(flat))
    end
  end
  
  local function table_keys(tbl)
    local keys = {}
    for k, _ in pairs(tbl) do
      table.insert(keys, k)
    end
    return keys
  end
  
  --[[local function tcopy(tbl)
    local cpy = {}
    for k, v in pairs(tbl) do
      cpy[k]=v
    end
    return cpy
  end
  ]]
  local nextarg; do local n = 0; nextarg = function(how_many)
    local ret = {}; how_many = how_many or 1;
    for i=1,how_many do ret[i]=ARGV[n+i] or false end
    n = n + how_many
    return tunpack(ret)
  end; end
  
  local prefix, action, item, ruleset_name = nextarg(4)
  prefix = #prefix>0 and prefix .. ":" or ""
  
  local kbase, key, keyf;
  local function genkeys(new_ruleset_name)
    kbase = ("%sruleset:%s"):format(prefix, new_ruleset_name)
    key = {
      rulesets = prefix.."rulesets",
      ruleset =  kbase,
      ruleset_pubsub = kbase..":pubsub",
      phases =   kbase..":phases",
      lists =    kbase..":lists",
      rules =    kbase..":rules",
      limiters = kbase..":limiters",
    }
    keyf = {
      list =         key.ruleset..":list:%s",
      list_rules =   key.ruleset..":list:%s:rules",
      list_refs =    key.ruleset..":list:%s:refs",
      
      rule =         key.ruleset..":rule:%s",
      rule_refs =    key.ruleset..":rule:%s:refs",
      
      limiter =      key.ruleset..":limiter:%s",
      limiter_refs = key.ruleset..":limiter:%s:refs",
      limiter_pubsub=key.ruleset..":limiter:%s:pubsub",
      
      phase =        key.ruleset..":phase:%s",
      phase_lists =  key.ruleset..":phase:%s:lists"
    }
  end
  genkeys(ruleset_name)
  
  Ruleset.uniqueName = function(thing, thingtbl, ruleset)
    local name, thing_key, n, set_key
    if thing == "ruleset" then
      thing_key = prefix .. "rulesets:n"
      set_key = key.rulesets
    else
      thing_key = (prefix .. "ruleset:" .. ruleset.name)
      if     thing == "phase" then
        set_key = key.phases
      elseif thing == "list" then
        set_key = key.lists
      elseif thing == "rule" then
        set_key = key.rules
      elseif thing == "limiter" then
        set_key = key.limiters
      end
    end
    n = redis.call("HINCRBY", thing_key, thing .. ":n", 1)
    name = ("%s%i"):format(thing, n)
    
    if redis.call("SISMEMBER", set_key, name) == 1 then --already exists
      return Ruleset.uniqueName(thing, thingtbl, ruleset)
    elseif thingtbl and thingtbl[name] then -- also already exists
      return Ruleset.uniqueName(thing, thingtbl, ruleset)
    else
      if thing == "ruleset" then genkeys(name) end
      return name
    end
  end
  
  local limiter_created = {} --needed because limiters can reference other limiters
  Binding.set("limiter", {
    create = function(limiter)
      if limiter.external then return end
      if limiter_created[limiter.name] then return end
      local lkey = keyf.limiter:format(limiter.name)
      if redis.call("EXISTS", lkey) == 1 then error("limiter \"" .. limiter.name .. "\" already exists") end
      limiter.gen = 0
      redis_hmset(lkey, limiter, "name", "info", "gen", "interval", "limit", "sync-steps", "burst-expire")
      if limiter.burst then
        redis.call("HSET", lkey, "burst", limiter.burst.name)
      end
      redis.call("SADD", key.limiters, limiter.name)
      
      if limiter.burst then
        redis.call("ZINCRBY", keyf.limiter_refs:format(limiter.burst.name), 1, "limiter:"..limiter.name)
      end
      
      limiter_created[limiter.name]=true
    end,
    update = function(limiter, diff)
      local lkey = keyf.limiter:format(limiter.name)
      if redis.call("EXISTS", lkey) == 0 then error("limiter \"" .. limiter.name .. "\" does not exist") end
      
      assert(not diff.name, "don't know how to rename limiters yet")
      
      limiter.gen = tonumber(limiter.gen or 0) + 1
      diff.gen = true
      
      if diff.burst then
        redis.call("ZINCRBY", keyf.limiter_refs:format(diff.burst.old.name), -1, "limiter:"..limiter.name)
        redis.call("ZREMRANGEBYSCORE", keyf.limiter_refs:format(diff.burst.old.name), "-inf", 0)
        redis.call("ZINCRBY", keyf.limiter_refs:format(diff.burst.new.name), 1, "limiter:"..limiter.name)
      end
      
      redis_hmset(lkey, limiter, table_keys(diff))
    end,
    delete = function(limiter)
      local lkey = keyf.limiter:format(limiter.name)
      if redis.call("EXISTS", lkey) == 0 then error("limiter \"" .. limiter.name .. "\" does not exist") end
      if redis.call("ZCARD", keyf.limiter_refs:format(limiter.name)) > 0 then error("limiter \"" .. limiter.name .. "\" still in use") end
      
      if limiter.burst then
        redis.call("ZINCRBY", keyf.limiter_refs:format(limiter.burst.name), -1, "limiter:"..limiter.name)
        redis.call("ZREMRANGEBYSCORE", keyf.limiter_refs:format(limiter.burst.name), "-inf", 0)
      end
      redis.call("SREM", key.limiters, limiter.name)
      redis.call("DEL", lkey)
    end
  })
  
  Binding.set("list", {
    create = function(list)
      if list.external then return end
      local lkey = keyf.list:format(list.name)
      if redis.call("EXISTS", lkey) == 1 then error("list \"" .. list.name .. "\" already exists") end
      list.gen = 0
      redis_hmset(lkey, list, "name", "info", "gen")
      
      local list_rules_key = keyf.list_rules:format(list.name)
      local list_ref = "list:"..list.name
      for _, rule in ipairs(list.rules) do
        redis.call("RPUSH", list_rules_key, rule.name)
        redis.call("ZINCRBY", keyf.rule_refs:format(rule.name), 1, list_ref)
      end
      
      redis.call("SADD", key.lists, list.name)
    end,
    update = function(list, diff)
      local lkey = keyf.list:format(list.name)
      if redis.call("EXISTS", lkey) == 0 then error("list \"" .. list.name .. "\" does not exist") end
      list.gen = tonumber(list.gen or 0) + 1
      diff.gen = true
      
      assert(not diff.name, "don't know how to rename lists yet")
      
      if diff.rules then
        local list_rules_key = keyf.list_rules:format(list.name)
        local list_ref = "list:"..list.name
        redis.call("DEL", list_rules_key)
        for _, rule in ipairs(diff.rules.old) do
          local rule_refs_key = keyf.rule_refs:format(rule.name)
          redis.call("ZINCRBY", rule_refs_key, -1, list_ref)
          redis.call("ZREMRANGEBYSCORE", rule_refs_key, "-inf", 0)
        end
        
        for _, rule in ipairs(diff.rules.old) do
          redis.call("RPUSH", list_rules_key, rule.name)
          redis.call("SADD", keyf.rule_refs:format(rule.name), list_ref)
        end
        
        --redis.call("ZREMRANGEBYSCORE", list_refs_key, "-inf" 0)
        diff.rules = nil
      end
      
      redis_hmset(lkey, list, table_keys(diff))
    end,
    delete = function(list)
      local lkey = keyf.list:format(list.name)
      local list_refs_key = keyf.list_refs:format(list.name)
      if redis.call("EXISTS", lkey) == 0 then error("list \"" .. list.name .. "\" does not exist") end
      if redis.call("ZCARD", list_refs_key) ~= 0 then error("list \"" .. list.name .. "\" is still in use") end
      
      local list_rules_key = keyf.list_rules:format(list.name)
      local list_ref = "list:"..list.name
      
      for _, rule_name in ipairs(redis.call("LRANGE", list_rules_key, 0, -1)) do
        local rule_refs_key = keyf.rule_refs:format(rule_name)
        redis.call("ZINCRBY", rule_refs_key, -1, list_ref)
        redis.call("ZREMRANGEBYSCORE", rule_refs_key, "-inf", 0)
      end
      
      redis.call("SREM", key.lists, list.name)
      redis.call("DEL", lkey, list_rules_key, list_refs_key)
    end
  })
  
  Binding.set("phase", {
    create = function(phase)
      if phase.external then return end
      local pkey = keyf.phase:format(phase.name)
      if redis.call("EXISTS", pkey) == 1 then error("phase \"" .. phase.name .. "\" already exists") end
      phase.gen = 0
      redis_hmset(pkey, phase, "name", "info", "gen")
      
      local phase_lists_key = keyf.phase_lists:format(phase.name)
      local phase_ref = "phase:"..phase.name
      for _, list in ipairs(phase.lists) do
        redis.call("RPUSH", phase_lists_key, list.name)
        redis.call("ZINCRBY", keyf.list_refs:format(list.name), 1, phase_ref)
      end
      
      redis.call("SADD", key.phases, phase.name)
    end,
    update = function(phase, diff)
      phase.gen = tonumber(phase.gen or 0) + 1
      diff.gen = true
      assert(not diff.name, "don't know how to rename phases yet")
      
      local pkey = keyf.phase:format(phase.name)
      local phase_ref = "phase:"..phase.name
      
      if diff.lists then
        local phase_lists_key = keyf.phase_lists:format(phase.name)
        local list_refs_key
        for _, list_name in ipairs(redis.call("LRANGE", phase_lists_key, 0, -1)) do
          list_refs_key = keyf.list_refs:format(list_name)
          redis.call("ZINCRBY", list_refs_key, -1, phase_ref)
          redis.call("ZREMRANGEBYSCORE", list_refs_key, "-inf", 0)
        end
        redis.call("DEL", phase_lists_key)
        
        for _, list in ipairs(diff.lists.new) do
          list_refs_key = keyf.list_refs:format(list.name)
          redis.call("RPUSH", phase_lists_key, list.name)
          redis.call("ZINCRBY", list_refs_key, 1, phase_ref)
        end
        diff.lists = nil
      end
      
      redis_hmset(pkey, phase, table_keys(diff))
    end,
    delete = function(phase)
      local pkey = keyf.phase:format(phase.name)
      local phase_ref = "phase:"..phase.name
      
      local phase_lists_key = keyf.phase_lists:format(phase.name)
      local list_refs_keys
      for _, list_name in ipairs(redis.call("LRANGE", phase_lists_key, 0, -1)) do
        list_refs_keys = keyf.list_refs:format(list_name)
        redis.call("ZINCRBY", list_refs_keys, -1, phase_ref)
        redis.call("ZREMRANGEBYSCORE", list_refs_keys, "-inf", 0)
      end
      
      redis.call("SREM", key.phases, phase.name)
      redis.call("DEL", pkey, phase_lists_key)
    end
  })
  
  Binding.set("rule", {
    create = function(rule)
      local rkey = keyf.rule:format(rule.name)
      if redis.call("EXISTS", rkey) == 1 then error("rule \"" .. rule.name .. "\" already exists") end
      rule.gen = 0
      redis_hmset(rkey, rule, "name", "info", "gen", "key")
      redis.call("HSET", rkey, "if", rule["if"]:toJSON())
      if rule["then"] then
        redis.call("HSET", rkey, "then", rule["then"]:toJSON())
      end
      if rule["else"] then
        redis.call("HSET", rkey, "else", rule["else"]:toJSON())
      end
      if rule.refs then
        local rule_ref = "rule:"..rule.name
        for ref_type, ref in pairs(rule.refs) do
          local refkeyf = assert(keyf[ref_type .. "_refs"])
          for _, ref_name in ipairs(ref) do
            redis.call("ZINCRBY", refkeyf:format(ref_name), 1, rule_ref)
          end
        end
      end
      redis.call("SADD", key.rules, rule.name)
    end,
    update = function(rule, diff)
      local rkey = keyf.rule:format(rule.name)
      if redis.call("EXISTS", rkey) == 1 then error("rule \"" .. rule.name .. "\" does not exist") end
      assert(not diff.name, "don't know how to rename rules yet")
      rule.gen = tonumber(rule.gen or 0) + 1
      diff.gen = true
      
      local function update_refs(old, new)
        local ref_kind, ref_name, refkey
        local rule_ref = "rule:"..rule.name
        for _, ref in ipairs(old) do
          ref_kind, ref_name = ref:match("(.+):(.+)")
          refkey = assert(keyf[ref_kind .. "_refs"]):format(ref_name)
          redis.call("ZINCRBY", refkey, -1, rule_ref)
          redis.call("ZREMRANGEBYSCORE", refkey, "-inf", 0)
        end
        
        for _, ref in ipairs(new) do
          ref_kind, ref_name = ref:match("(.+):(.+)")
          refkey = assert(keyf[ref_kind .. "_refs"]):format(ref_name)
          redis.call("ZINCRBY", refkey, 1, rule_ref)
        end
      end
      
      if diff["if"] then
        update_refs(diff["if"].old, diff["if"].new)
        redis.call("HSET", rkey, "if", rule["if"]:toJSON())
        diff["if"]=nil
      end
      if diff["then"] then
        update_refs(diff["then"].old, diff["then"].new)
        redis.call("HSET", rkey, "then", rule["then"]:toJSON())
        diff["then"]=nil
      end
      if diff["else"] then
        update_refs(diff["else"].old, diff["else"].new)
        redis.call("HSET", rkey, "else", rule["else"]:toJSON())
        diff["else"]=nil
      end
      
      redis_hmset(rkey, rule, table_keys(diff))
    end,
    delete = function(rule)
      local rkey = keyf.rule:format(rule.name)
      if redis.call("EXISTS", rkey) == 1 then error("rule \"" .. rule.name .. "\" does not exist") end
      if redis.call("ZCARD", keyf.rule_refs:format(rule.name)) > 0 then error("rule \"" .. rule.name .. "\" still in use") end
      
      local rule_ref = "rule:"..rule.name
      for _, ref in ipairs(rule.refs or {}) do
        local ref_kind, ref_name = ref:match("(.+):(.+)")
        local refkey = assert(keyf[ref_kind .. "_refs"]):format(ref_name)
        redis.call("ZINCRBY", refkey, -1, rule_ref)
        redis.call("ZREMRANGEBYSCORE", refkey, "-inf", 0)
      end
      
      redis.call("SREM", key.rules, rule.name)
      redis.call("DEL", rkey)
    end
  })
  
  Binding.set("ruleset", {
    create = function(ruleset)
      if redis.call("SISMEMBER", key.rulesets, ruleset.name) == 1 then error(("ruleset \"%s\" already exists"):format(ruleset.name)) end
      
      ruleset.gen = 0
      redis_hmset(key.ruleset, ruleset, "name", "info", "gen")
      redis.call("SADD", key.rulesets, ruleset.name)
    end,
    update = function(ruleset, diff)
      if redis.call("SISMEMBER", key.rulesets, ruleset.name) == 0 then error(("ruleset \"%s\" does not exist"):format(ruleset.name)) end
      assert(not diff.name, "don't know how to rename rulesets yet")
      assert(not diff.lists, "don't know how to update ruleset lists inline")
      assert(not diff.limiters, "don't know how to update ruleset limiters inline")
      assert(not diff.rules, "don't know how to update ruleset rules inline")
      ruleset.gen = tonumber(ruleset.gen or 0) + 1
      diff.gen = true
      
      redis_hmset(key.ruleset, ruleset, table_keys(diff))
    end,
    delete = function(ruleset)
      if redis.call("SISMEMBER", key.rulesets, ruleset.name) == 0 then error(("ruleset \"%s\" does not exist"):format(ruleset.name)) end
      --TODO: is this ruleset in use?
      redis.call("SREM", key.rulesets, ruleset.name)
      assert(redis.call("SCARD", key.phases) == 0, "some phases still present in ruleset")
      assert(redis.call("SCARD", key.list) == 0, "some lists still present in ruleset")
      assert(redis.call("SCARD", key.rule) == 0, "some rules still present in ruleset")
      assert(redis.call("SCARD", key.limiter) == 0, "some limiters still present in ruleset")
      
      redis.call("DEL", key.ruleset)
      
    end
  })
  
  local actions
  actions = {
    ruleset = {
      create = function()
        if #ruleset_name > 0 and redis.call("EXISTS", key.ruleset) == 1 then
          return {0, ("ruleset \"%s\" already exists"):format(ruleset_name)}
        end
        
        local json_in = nextarg(1)
        
        local p = Parser.new()
        local parsed, err = p:parseJSON("ruleset", json_in, ruleset_name or "anonymous ruleset")
        if not parsed then
          return {0, err}
        end
        if #ruleset_name > 0 then
          parsed.name = ruleset_name
        end
        
        local rs = Ruleset.new(parsed)
        hmm(rs)
        
        return {1}
      end,
      update = function()
        if not ruleset_name or #ruleset_name == 0 then return {0, ("no ruleset name given")} end
        if redis.call("EXISTS", key.ruleset) == 0 then
          return {0, ("ruleset \"%s\" does not exist"):format(ruleset_name)}
        end
        
        local json_in = nextarg(1)
        
        local p = Parser.new({incomplete=true})
        local parsed, err = p:parseJSON("ruleset", json_in, ruleset_name)
        if not parsed then
          return {0, err}
        end
      end,
      delete = function()
        local name = nextarg(1)
        error("can'd do this yet" .. name, ruleset_name)
      end
    },
    list = {
      create = function()
        local json_in, list_name = nextarg(2)
        if not list_name then list_name = "" end
        
        if #list_name > 0 and redis.call("EXISTS", keyf.list:format(list_name)) == 1 then
          return {0, ("rule \"%s\" already exists"):format(list_name)}
        end
        
        local p = Parser.new()
        local parsed, err = p:parseJSON("list", json_in, list_name)
        if not parsed then
          return {0, err}
        end
        
        local list = Ruleset.newList(parsed)
        hmm(list)
        
        return {1}
      end,
      delete = function()
        
      end
    },
    rule = {
      create = function()
        local json_in, rule_name = nextarg(2)
        if not rule_name then rule_name = "" end
        
        if #rule_name > 0 and redis.call("EXISTS", keyf.rule:format(rule_name)) == 1 then
          return {0, ("rule \"%s\" already exists"):format(rule_name)}
        end
        
        local p = Parser.new()
        local parsed, err = p:parseJSON("rule", json_in, rule_name)
        if not parsed then
          return {0, err}
        end
        
        local rule = Ruleset.newRule(parsed)
        
        hmm(rule)
        return {1}
        
      end,
      delete = function()
      
      end
    },
    limiter = {
      create = function()
        local json_in, limiter_name = nextarg(2)
        if not limiter_name then limiter_name = "" end
        
        if #limiter_name > 0 and redis.call("EXISTS", keyf.rule:format(#limiter_name)) == 1 then
          return {0, ("rule \"%s\" already exists"):format(#limiter_name)}
        end
        
        local p = Parser.new()
        local parsed, err = p:parseJSON("rule", json_in, #limiter_name)
        if not parsed then
          return {0, err}
        end
        
        local rule = Ruleset.newRule(parsed)
        hmm(rule)
        return {1}
      end,
      delete = function()
        
      end
    }
  }
  
  if type(actions[item]) == "function" then
    actions[item](action)
  elseif actions[item][action] then
    return actions[item][action]()
  else
    error(("unknown action %s for item %s"):format(action, item))
  end

end
do
  local modules = {}
  module = function(name, fn) modules[name]=fn() end
  require = function(name) return modules[name] end
end
--luacheck: ignore

module("inspect", function()
local a={_VERSION='inspect.lua 3.1.0',_URL='http://github.com/kikito/inspect.lua',_DESCRIPTION='human-readable representations of tables',_LICENSE="MIT LICENSE; Copyright (c) 2013 Enrique Garc√≠a Cota"}local tostring=tostring;a.KEY=setmetatable({},{__tostring=function()return'inspect.KEY'end})a.METATABLE=setmetatable({},{__tostring=function()return'inspect.METATABLE'end})local function b(c)if c:match('"')and not c:match("'")then return"'"..c.."'"end;return'"'..c:gsub('"','\\"')..'"'end;local d={["\a"]="\\a",["\b"]="\\b",["\f"]="\\f",["\n"]="\\n",["\r"]="\\r",["\t"]="\\t",["\v"]="\\v"}local e={}for f=0,31 do local g=string.char(f)if not d[g]then d[g]="\\"..f;e[g]=string.format("\\%03d",f)end end;local function h(c)return c:gsub("\\","\\\\"):gsub("(%c)%f[0-9]",e):gsub("%c",d)end;local function i(c)return type(c)=='string'and c:match("^[_%a][_%a%d]*$")end;local function j(k,l)return type(k)=='number'and 1<=k and k<=l and math.floor(k)==k end;local m={['number']=1,['boolean']=2,['string']=3,['table']=4,['function']=5,['userdata']=6,['thread']=7}local function n(o,p)local q,r=type(o),type(p)if q==r and(q=='string'or q=='number')then return o<p end;local s,t=m[q],m[r]if s and t then return m[q]<m[r]elseif s then return true elseif t then return false end;return q<r end;local function u(v)local w=1;local x=rawget(v,w)while x~=nil do w=w+1;x=rawget(v,w)end;return w-1 end;local function y(v)local z={}local l=u(v)for k,A in pairs(v)do if not j(k,l)then table.insert(z,k)end end;table.sort(z,n)return z,l end;local function B(v,C)local D=type(C)=='table'and rawget(C,'__tostring')local c,E;if type(D)=='function'then E,c=pcall(D,v)c=E and c or'error: '..tostring(c)end;if type(c)=='string'and#c>0 then return c end end;local function F(v,G)G=G or{}if type(v)=='table'then if not G[v]then G[v]=1;for k,x in pairs(v)do F(k,G)F(x,G)end;F(getmetatable(v),G)else G[v]=G[v]+1 end end;return G end;local H=function(I)local J,w={},#I;for f=1,w do J[f]=I[f]end;return J,w end;local function K(L,...)local z={...}local M,w=H(L)for f=1,#z do M[w+f]=z[f]end;return M end;local function N(O,P,L,Q)if P==nil then return nil end;if Q[P]then return Q[P]end;local R=O(P,L)if type(R)=='table'then local S={}Q[P]=S;local T;for k,x in pairs(R)do T=N(O,k,K(L,k,a.KEY),Q)if T~=nil then S[T]=N(O,x,K(L,T),Q)end end;local C=N(O,getmetatable(R),K(L,a.METATABLE),Q)setmetatable(S,C)R=S end;return R end;local U={}local V={__index=U}function U:puts(...)local W={...}local X=self.buffer;local w=#X;for f=1,#W do w=w+1;X[w]=W[f]end end;function U:down(Y)self.level=self.level+1;Y()self.level=self.level-1 end;function U:tabify()self:puts(self.newline,string.rep(self.indent,self.level))end;function U:alreadyVisited(x)return self.ids[x]~=nil end;function U:getId(x)local Z=self.ids[x]if not Z then local _=type(x)Z=(self.maxIds[_]or 0)+1;self.maxIds[_]=Z;self.ids[x]=Z end;return tostring(Z)end;function U:putKey(k)if i(k)then return self:puts(k)end;self:puts("[")self:putValue(k)self:puts("]")end;function U:putTable(v)if v==a.KEY or v==a.METATABLE then self:puts(tostring(v))elseif self:alreadyVisited(v)then self:puts('<table ',self:getId(v),'>')elseif self.level>=self.depth then self:puts('{...}')else if self.tableAppearances[v]>1 then self:puts('<',self:getId(v),'>')end;local a0,l=y(v)local C=getmetatable(v)local a1=B(v,C)self:puts('{')self:down(function()if a1 then self:puts(' -- ',h(a1))if l>=1 then self:tabify()end end;local a2=0;for f=1,l do if a2>0 then self:puts(',')end;self:puts(' ')self:putValue(v[f])a2=a2+1 end;for A,k in ipairs(a0)do if a2>0 then self:puts(',')end;self:tabify()self:putKey(k)self:puts(' = ')self:putValue(v[k])a2=a2+1 end;if C then if a2>0 then self:puts(',')end;self:tabify()self:puts('<metatable> = ')self:putValue(C)end end)if#a0>0 or C then self:tabify()elseif l>0 then self:puts(' ')end;self:puts('}')end end;function U:putValue(x)local _=type(x)if _=='string'then self:puts(b(h(x)))elseif _=='number'or _=='boolean'or _=='nil'then self:puts(tostring(x))elseif _=='table'then self:putTable(x)else self:puts('<',_,' ',self:getId(x),'>')end end;function a.inspect(a3,a4)a4=a4 or{}local a5=a4.depth or math.huge;local a6=a4.newline or'\n'local a7=a4.indent or'  'local O=a4.process;if O then a3=N(O,a3,{},{})end;local a8=setmetatable({depth=a5,level=0,buffer={},ids={},maxIds={},newline=a6,indent=a7,tableAppearances=F(a3)},V)a8:putValue(a3)return table.concat(a8.buffer)end;setmetatable(a,{__call=function(A,...)return a.inspect(...)end})return a

end)

module("dkjson", function()
local a=false;local b=false;local c='json'local pairs,type,tostring,tonumber,getmetatable,setmetatable,rawset=pairs,type,tostring,tonumber,getmetatable,setmetatable,rawset;local error,require,pcall,select=error,require,pcall,select;local d,e=math.floor,math.huge;local f,g,h,i,j,k,l,m=string.rep,string.gsub,string.sub,string.byte,string.char,string.find,string.len,string.format;local n=string.match;local o=table.concat;local p={version="dkjson 2.5"}if b then _G[c]=p end;local q=nil;pcall(function()local r=require"debug".getmetatable;if r then getmetatable=r end end)p.null=setmetatable({},{__tojson=function()return"null"end})local function s(t)local u,v,w=0,0,0;for x,y in pairs(t)do if x=='n'and type(y)=='number'then w=y;if y>u then u=y end else if type(x)~='number'or x<1 or d(x)~=x then return false end;if x>u then u=x end;v=v+1 end end;if u>10 and u>w and u>v*2 then return false end;return true,u end;local z={["\""]="\\\"",["\\"]="\\\\",["\b"]="\\b",["\f"]="\\f",["\n"]="\\n",["\r"]="\\r",["\t"]="\\t"}local function A(B)local C=z[B]if C then return C end;local D,E,F,G=i(B,1,4)D,E,F,G=D or 0,E or 0,F or 0,G or 0;if D<=0x7f then C=D elseif 0xc0<=D and D<=0xdf and E>=0x80 then C=(D-0xc0)*0x40+E-0x80 elseif 0xe0<=D and D<=0xef and E>=0x80 and F>=0x80 then C=((D-0xe0)*0x40+E-0x80)*0x40+F-0x80 elseif 0xf0<=D and D<=0xf7 and E>=0x80 and F>=0x80 and G>=0x80 then C=(((D-0xf0)*0x40+E-0x80)*0x40+F-0x80)*0x40+G-0x80 else return""end;if C<=0xffff then return m("\\u%.4x",C)elseif C<=0x10ffff then C=C-0x10000;local H,I=0xD800+d(C/0x400),0xDC00+C%0x400;return m("\\u%.4x\\u%.4x",H,I)else return""end end;local function J(K,L,M)if k(K,L)then return g(K,L,M)else return K end end;local function N(C)C=J(C,"[%z\1-\31\"\\\127]",A)if k(C,"[\194\216\220\225\226\239]")then C=J(C,"\194[\128-\159\173]",A)C=J(C,"\216[\128-\132]",A)C=J(C,"\220\143",A)C=J(C,"\225\158[\180\181]",A)C=J(C,"\226\128[\140-\143\168-\175]",A)C=J(C,"\226\129[\160-\175]",A)C=J(C,"\239\187\191",A)C=J(C,"\239\191[\176-\191]",A)end;return"\""..C.."\""end;p.quotestring=N;local function O(K,P,v)local Q,R=k(K,P,1,true)if Q then return h(K,1,Q-1)..v..h(K,R+1,-1)else return K end end;local S,T;local function U()S=n(tostring(0.5),"([^05+])")T="[^0-9%-%+eE"..g(S,"[%^%$%(%)%%%.%[%]%*%+%-%?]","%%%0").."]+"end;U()local function V(W)return O(J(tostring(W),T,""),S,".")end;local function X(K)local W=tonumber(O(K,".",S))if not W then U()W=tonumber(O(K,".",S))end;return W end;local function Y(Z,_,a0)_[a0+1]="\n"_[a0+2]=f("  ",Z)a0=a0+2;return a0 end;function p.addnewline(a1)if a1.indent then a1.bufferlen=Y(a1.level or 0,a1.buffer,a1.bufferlen or#a1.buffer)end end;local a2;local function a3(a4,C,a5,a6,Z,_,a0,a7,a8,a1)local a9=type(a4)if a9~='string'and a9~='number'then return nil,"type '"..a9 .."' is not supported as a key by JSON."end;if a5 then a0=a0+1;_[a0]=","end;if a6 then a0=Y(Z,_,a0)end;_[a0+1]=N(a4)_[a0+2]=":"return a2(C,a6,Z,_,a0+2,a7,a8,a1)end;local function aa(ab,_,a1)local a0=a1.bufferlen;if type(ab)=='string'then a0=a0+1;_[a0]=ab end;return a0 end;local function ac(ad,C,a1,_,a0,ae)ae=ae or ad;local af=a1.exception;if not af then return nil,ae else a1.bufferlen=a0;local ag,ah=af(ad,C,a1,ae)if not ag then return nil,ah or ae end;return aa(ag,_,a1)end end;function p.encodeexception(ad,C,a1,ae)return N("<"..ae..">")end;a2=function(C,a6,Z,_,a0,a7,a8,a1)local ai=type(C)local aj=getmetatable(C)aj=type(aj)=='table'and aj;local ak=aj and aj.__jsonval;if ak then if type(ak)=="function"then C=ak(C)else C=ak end;ai=type(C)end;local al=aj and aj.__tojson;if al then if a7[C]then return ac('reference cycle',C,a1,_,a0)end;a7[C]=true;a1.bufferlen=a0;local ag,ah=al(C,a1)if not ag then return ac('custom encoder failed',C,a1,_,a0,ah)end;a7[C]=nil;a0=aa(ag,_,a1)elseif C==nil then a0=a0+1;_[a0]="null"elseif ai=='number'then local am;if C~=C or C>=e or-C>=e then am="null"else am=V(C)end;a0=a0+1;_[a0]=am elseif ai=='boolean'then a0=a0+1;_[a0]=C and"true"or"false"elseif ai=='string'then a0=a0+1;_[a0]=N(C)elseif ai=='table'then if a7[C]then return ac('reference cycle',C,a1,_,a0)end;a7[C]=true;Z=Z+1;local an,v=s(C)if v==0 and aj and aj.__jsontype=='object'then an=false end;local ah;if an then a0=a0+1;_[a0]="["for Q=1,v do a0,ah=a2(C[Q],a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;if Q<v then a0=a0+1;_[a0]=","end end;a0=a0+1;_[a0]="]"else local a5=false;a0=a0+1;_[a0]="{"local ao=aj and aj.__jsonorder or a8;if ao then if type(ao)=="function"then ao=ao(C)end;local ap={}v=#ao;for Q=1,v do local x=ao[Q]local y=C[x]if y then ap[x]=true;a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)a5=true end end;for x,y in pairs(C)do if not ap[x]then a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;a5=true end end else for x,y in pairs(C)do a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;a5=true end end;if a6 then a0=Y(Z-1,_,a0)end;a0=a0+1;_[a0]="}"end;a7[C]=nil else return ac('unsupported type',C,a1,_,a0,"type '"..ai.."' is not supported by JSON.")end;return a0 end;function p.encode(C,a1)a1=a1 or{}local aq=a1.buffer;local _=aq or{}a1.buffer=_;U()local ag,ah=a2(C,a1.indent,a1.level or 0,_,a1.bufferlen or 0,a1.tables or{},a1.keyorder,a1)if not ag then error(ah,2)elseif aq==_ then a1.bufferlen=ag;return true else a1.bufferlen=nil;a1.buffer=nil;return o(_)end end;local function ar(K,as)local at,au,av=1,1,0;while true do au=k(K,"\n",au,true)if au and au<as then at=at+1;av=au;au=au+1 else break end end;return"line "..at..", column "..as-av end;local function aw(K,ax,as)return nil,l(K)+1,"unterminated "..ax.." at "..ar(K,as)end;local function ay(K,au)while true do au=k(K,"%S",au)if not au then return nil end;local az=h(K,au,au+1)if az=="\239\187"and h(K,au+2,au+2)=="\191"then au=au+3 elseif az=="//"then au=k(K,"[\n\r]",au+2)if not au then return nil end elseif az=="/*"then au=k(K,"*/",au+2)if not au then return nil end;au=au+2 else return au end end end;local aA={["\""]="\"",["\\"]="\\",["/"]="/",["b"]="\b",["f"]="\f",["n"]="\n",["r"]="\r",["t"]="\t"}local function aB(C)if C<0 then return nil elseif C<=0x007f then return j(C)elseif C<=0x07ff then return j(0xc0+d(C/0x40),0x80+d(C)%0x40)elseif C<=0xffff then return j(0xe0+d(C/0x1000),0x80+d(C/0x40)%0x40,0x80+d(C)%0x40)elseif C<=0x10ffff then return j(0xf0+d(C/0x40000),0x80+d(C/0x1000)%0x40,0x80+d(C/0x40)%0x40,0x80+d(C)%0x40)else return nil end end;local function aC(K,au)local aD=au+1;local _,v={},0;while true do local aE=k(K,"[\"\\]",aD)if not aE then return aw(K,"string",au)end;if aE>aD then v=v+1;_[v]=h(K,aD,aE-1)end;if h(K,aE,aE)=="\""then aD=aE+1;break else local aF=h(K,aE+1,aE+1)local C;if aF=="u"then C=tonumber(h(K,aE+2,aE+5),16)if C then local aG;if 0xD800<=C and C<=0xDBff then if h(K,aE+6,aE+7)=="\\u"then aG=tonumber(h(K,aE+8,aE+11),16)if aG and 0xDC00<=aG and aG<=0xDFFF then C=(C-0xD800)*0x400+aG-0xDC00+0x10000 else aG=nil end end end;C=C and aB(C)if C then if aG then aD=aE+12 else aD=aE+6 end end end end;if not C then C=aA[aF]or aF;aD=aE+2 end;v=v+1;_[v]=C end end;if v==1 then return _[1],aD elseif v>1 then return o(_),aD else return"",aD end end;local aH;local function aI(t,aJ,K,au)if type(aJ)=="function"then aJ=aJ(K,au)if type(aJ)~="table"then return t end end;return setmetatable(t,aJ)end;local function aK(ax,aL,K,aM,aN,aO,aP)local aQ=l(K)local t,v={},0;local au=aM+1;if ax=='object'then aI(t,aO,K,aM)else aI(t,aP,K,aM)end;while true do au=ay(K,au)if not au then return aw(K,ax,aM)end;local aR=h(K,au,au)if aR==aL then return t,au+1 end;local aS,aT;aS,au,aT=aH(K,au,aN,aO,aP)if aT then return nil,au,aT end;au=ay(K,au)if not au then return aw(K,ax,aM)end;aR=h(K,au,au)if aR==":"then if aS==nil then return nil,au,"cannot use nil as table index (at "..ar(K,au)..")"end;au=ay(K,au+1)if not au then return aw(K,ax,aM)end;local aU;aU,au,aT=aH(K,au,aN,aO,aP)if aT then return nil,au,aT end;t[aS]=aU;au=ay(K,au)if not au then return aw(K,ax,aM)end;aR=h(K,au,au)else v=v+1;t[v]=aS end;if aR==","then au=au+1 end end end;aH=function(K,au,aN,aO,aP)au=au or 1;au=ay(K,au)if not au then return nil,l(K)+1,"no valid JSON value (reached the end)"end;local aR=h(K,au,au)if aR=="{"then return aK('object',"}",K,au,aN,aO,aP)elseif aR=="["then return aK('array',"]",K,au,aN,aO,aP)elseif aR=="\""then return aC(K,au)else local aV,aW=k(K,"^%-?[%d%.]+[eE]?[%+%-]?%d*",au)if aV then local aX=X(h(K,aV,aW))if aX then return aX,aW+1 end end;aV,aW=k(K,"^%a%w*",au)if aV then local aY=h(K,aV,aW)if aY=="true"then return true,aW+1 elseif aY=="false"then return false,aW+1 elseif aY=="null"then return aN,aW+1 end end;return nil,au,"no valid JSON value at "..ar(K,au)end end;local function aZ(...)if select("#",...)>0 then return...else return{__jsontype='object'},{__jsontype='array'}end end;function p.decode(K,au,aN,...)local aO,aP=aZ(...)return aH(K,au,aN,aO,aP)end;function p.use_lpeg()local a_=require("lpeg")if a_.version()=="0.11"then error"due to a bug in LPeg 0.11, it cannot be used for JSON matching"end;local b0=a_.match;local b1,b2,b3=a_.P,a_.S,a_.R;local function b4(K,au,ah,a1)if not a1.msg then a1.msg=ah.." at "..ar(K,au)a1.pos=au end;return false end;local function b5(ah)return a_.Cmt(a_.Cc(ah)*a_.Carg(2),b4)end;local b6=b1"//"*(1-b2"\n\r")^0;local b7=b1"/*"*(1-b1"*/")^0*b1"*/"local b8=(b2" \n\r\t"+b1"\239\187\191"+b6+b7)^0;local b9=1-b2"\"\\\n\r"local ba=b1"\\"*a_.C(b2"\"\\/bfnrt"+b5"unsupported escape sequence")/aA;local bb=b3("09","af","AF")local function bc(bd,au,be,bf)be,bf=tonumber(be,16),tonumber(bf,16)if 0xD800<=be and be<=0xDBff and 0xDC00<=bf and bf<=0xDFFF then return true,aB((be-0xD800)*0x400+bf-0xDC00+0x10000)else return false end end;local function bg(bh)return aB(tonumber(bh,16))end;local bi=b1"\\u"*a_.C(bb*bb*bb*bb)local bj=a_.Cmt(bi*bi,bc)+bi/bg;local bk=bj+ba+b9;local bl=b1"\""*a_.Cs(bk^0)*(b1"\""+b5"unterminated string")local bm=b1"-"^-1*(b1"0"+b3"19"*b3"09"^0)local bn=b1"."*b3"09"^0;local bo=b2"eE"*b2"+-"^-1*b3"09"^1;local bp=bm*bn^-1*bo^-1/X;local bq=b1"true"*a_.Cc(true)+b1"false"*a_.Cc(false)+b1"null"*a_.Carg(1)local br=bp+bl+bq;local bs,bt;local function bu(K,au,aN,a1)local bv,bw;local bx;local by,bz={},0;repeat bv,bw,bx=b0(bs,K,au,aN,a1)if not bx then break end;au=bx;bz=bz+1;by[bz]=bv until bw=='last'return au,setmetatable(by,a1.arraymeta)end;local function bA(K,au,aN,a1)local bv,a4,bw;local bx;local by={}repeat a4,bv,bw,bx=b0(bt,K,au,aN,a1)if not bx then break end;au=bx;by[a4]=bv until bw=='last'return au,setmetatable(by,a1.objectmeta)end;local bB=b1"["*a_.Cmt(a_.Carg(1)*a_.Carg(2),bu)*b8*(b1"]"+b5"']' expected")local bC=b1"{"*a_.Cmt(a_.Carg(1)*a_.Carg(2),bA)*b8*(b1"}"+b5"'}' expected")local bD=b8*(bB+bC+br)local bE=bD+b8*b5"value expected"bs=bD*b8*(b1","*a_.Cc'cont'+a_.Cc'last')*a_.Cp()local bF=a_.Cg(b8*bl*b8*(b1":"+b5"colon expected")*bE)bt=bF*b8*(b1","*a_.Cc'cont'+a_.Cc'last')*a_.Cp()local bG=bE*a_.Cp()function p.decode(K,au,aN,...)local a1={}a1.objectmeta,a1.arraymeta=aZ(...)local bv,bH=b0(bG,K,au,aN,a1)if a1.msg then return nil,a1.pos,a1.msg else return bv,bH end end;p.use_lpeg=function()return p end;p.using_lpeg=true;return p end;if a then pcall(p.use_lpeg)end;return p

end)

module("binding", function()
local a={}local b={bindings=a,require_create_userdata=false,require_binding=false}setmetatable(a,{__index=function(c,d)if b.require_binding then error("missing binding for "..tostring(d))end end})local e={create=function(f,self,...)if type(self)~="table"then return nil,("expected 'self' to be table, got %s)"):format(type(self))end;local g=f(self,...)if(b.require_create_userdata or g)and type(g)~="userdata"then return nil,("expected userdata, got %s"):format(type(g))elseif type(g)=="userdata"then self.__binding=g end;return true end,update=function(h,self,i,j,...)if type(self)~="table"then return nil,("expected 'self' to be table, got %s)"):format(type(self))end;if type(i)~="string"then return nil,("expected 'update_name' to be string, got %s)"):format(type(self))end;local g=h(self,i,j,...)if type(g)=="userdata"then self.__binding=g end;return true end,delete=function(k,self,...)if type(self)~="table"then return nil,("expected 'self' to be table, got %s)"):format(type(self))end;assert(type(self.__binding)=="userdata",("expected seld.__binding userdata, got %s"):format(type(self.__binding)))k(self.__binding,self,...)return true end}function b.set(l,m,n,o)assert(not rawget(a,l),("binding %s already set"):format(l))assert(type(l)=="string","binding name must be a string, got "..type(l))if type(m)=="table"and n==nil and o==nil then local p=m;m=p.create;n=p.update;o=p.delete end;local q={create=m,update=n,delete=o}for r,s in pairs(q)do assert(type(s)=="function"or type(s)==nil,("\"%s\" binding \"%s\" callback must be function or nil, was %s"):format(l,r,type(s)))end;a[l]=q end;function b.call(t,u,...)local q=a[t]if not q then return end;local v=e[u]if not v then error(("unknown binding call \"%s\" for \"%s\""):format(u,t))end;if not q[u]then error(("no callback for binding call \"%s\" for \"%s\""):format(u,t))end;local w,x=v(q[u],...)if not w then error(("Binding \"%s\" call \"%s\" error: %s"):format(t,u,x))end;return w end;return b

end)

module("rulecomponent", function()
local a=require"binding"local b=require"dkjson"local c;local function d(e)return e:sub(1,1)=="#"and e:sub(2)or e end;local f={__index=function(self,g)local h=d(g)if h~=g then return self[d(g)]end end}local function i(j)local self={table=setmetatable({},f)}local function k(l,m)local n,o=next(l)if type(n)=="number"then m:error("invalid data value, expected {\"key\":value}, got {\"key\"}")elseif type(n)~="string"then m:error("unexpected data type %s",type(n))end;local p=self.table[n]if m then m:assert(p,("Unknown %s \"%s\""):format(j,n))else assert(p,("Unknown %s \"%s\""):format(j,n))end;return n,o end;function self.add(n,q)if type(n)=="table"then for r,s in pairs(n)do self.add(s,q)end;return true end;assert(q.parse,("%s missing parse callback"):format(j))assert(self.table[n]==nil,("%s %s already exists"):format(j,n))local t={parse=q.parse,init=q.init,delete=q.delete,meta={__jsonval=q.jsonval,__jsonorder=q.jsonorder or{"action","condition"},__index={toJSON=function(u)return b.encode(u,{indent=true})end}}}self.table[n]=t;return true end;function self.parse(l,m)local n,o=k(l,m)o=self.table[n].parse(o,m)or o;return{[n]=o}end;function self.new(l,v)local n,o=k(l)n=d(n)local w=self.table[n]local p=setmetatable({[j]=n,data=o},w.meta)if w.init then local x=w.init(o,p,v)if x then p.data=x end end;a.call(("%s:%s"):format(j,n),"create",p)return p end;function self.delete(p,v)local n=p[j]or p.name;local w=self.table[n]print(j.." DELETE THING "..n.." "..tostring(w.delete))if w.delete then w.delete(p.data,v)end;a.call(("%s:%s"):format(j,n),"delete",p)end;return self end;c={condition=i("condition"),action=i("action")}c.condition.add("any",{parse=function(l,m)m:assert_jsontype(l,"array","\"any\" condition value must be an array of conditions")for y,s in ipairs(l)do local z=m:parseCondition(s)l[y]=z end end,init=function(l,p,v)for y,s in ipairs(l)do l[y]=c.condition.new(s,v)end end,delete=function(l,v)for r,A in ipairs(l)do c.condition.delete(A,v)end end,jsonval=function(self)return{any=self.data}end})c.condition.add("all",{parse=function(l,m)m:assert_jsontype(l,"array","\"all\" condition value must be an array of conditions")for y,s in ipairs(l)do local z=m:parseCondition(s)l[y]=z end end,init=function(l,v)for y,s in ipairs(l)do l[y]=c.condition.new(s,v)end end,delete=function(l,v)for r,A in ipairs(l)do c.condition.delete(A,v)end end,jsonval=function(self)return{all=self.data}end})c.condition.add({"true","false"},{parse=function(l,m)end,jsonval=function(self)return self.condition end})c.condition.add("tag-check",{parse=function(l,m)m:assert_type(l,"string","\"tag-check\" value must be a string")return m:parseInterpolatedString(l)end,init=function(l)a.call("string","create",l)end,delete=function(l)a.call("string","delete",l)end,jsonval=function(self)return{["tag-check"]=self.data.string}end})c.condition.add("match",{parse=function(l,m)m:assert_jsontype(l,"array","\"match\" value must be an array of strings")for y,s in ipairs(l)do m:assert_jsontype(s,"string","\"match\" value must be an array of strings")l[y]=m:parseInterpolatedString(s)end end,init=function(l)local B=function(e)local C=0;for r in e.string:gmatch("%$")do C=C+1 end;return C end;local D=function(E,F)return B(E)<B(F)end;table.sort(l,D)for r,e in ipairs(l)do a.call("string","create",e)end end,delete=function(l)for r,e in ipairs(l)do a.call("string","delete",e)end end,jsonval=function(self)local G={}for r,e in ipairs(self.data)do table.insert(G,e.string)end;return{match=G}end})local H={__jsonorder={"name","key","increment"}}c.condition.add({"limit-break","limit-check"},{parse=function(l,m)if type(l)=="string"then l={name=l}elseif type(l)~="table"then m:error("invalid value type %s",type(l))end;local I=next(m:getContext())local J=m:getContext("rule")local K=m:getContext("if")if not l.key then l.key=J.key end;m:assert(l.key,"limiter \"key\" missing, and no default \"key\" in rule")m:assert_type(l.key,"string","invalid limiter \"key\" type")l.key=m:parseInterpolatedString(l.key)if not l.increment then if I=="limit-break"then l.increment=1 elseif I=="limit-check"then l.increment=0 end end;l.increment=m:assert(tonumber(l.increment),"invalid or empty \"increment\" value")m:assert(l.increment>=0,"\"increment\" must be >= 0")m:assert(l.name,"name missing")m:assert_type(l.name,"string","invalid \"name\" type")if c.generate_refs then if not J.refs then J.refs={}end;if not K.refs then K.refs={}end;table.insert(J.refs.limiter,"limiter:"..l.name)table.insert(K.refs.limiter,"limiter:"..l.name)end;return l end,init=function(l,p,v)local L=v:findLimiter(l.name)if not L then error("unknown limiter "..l.name)end;l.name=nil;l.limiter=L;if l.key then a.call("string","create",l.key)end end,delete=function(l)if l.key then a.call("string","delete",l.key)end end,jsonval=function(self)local M={}for N,s in pairs(self.data)do M[N]=s end;if M.derived_key then M.derived_key=nil;M.key=nil elseif M.key then M.key=M.key.string end;M.name=M.limiter.name;M.limiter=nil;setmetatable(M,H)local O={[self.condition]=M}return O end})c.condition.add(".delay",{parse=function(l,m)m:assert_jsontype(l,"number","delay by <number> please")end})c.action.add("tag",{parse=function(l,m)m:assert_jsontype(l,"string","\"tag\" value must be a string")return m:parseInterpolatedString(l)end,init=function(l)a.call("string","create",l)end,delete=function(l)a.call("string","delete",l)end,jsonval=function(self)return{tag=self.data.string}end})c.action.add("accept",{parse=function(l,m)m:assert_type(l,"table","\"accept\" value must be an object")m:assert_table_size(l,0,"\"accept\" value must be empty")end})c.action.add("reject",{parse=function(l,m)m:assert_type(l,"table","\"reject\" value must be an object")end})c.action.add("wait",{parse=function(l,m)m:assert_jsontype(l,"number","\"wait\" value must be a number")end})return c

end)

module("parser", function()
local a=require"rulecomponent"local b=require"dkjson"local function c(d,e,f)local g=e[f.key]d:pushContext(g,f.key)local h=d.ruleset;if g then d:assert_type(g,f.type,"wrong type for ruleset %s, expected %s, got %s",f.key,f.type,d:jsontype(g))local i,j;for k,l in pairs(g)do d:assert_type(k,"string","wrong key type for %s, expected string, got %s %s",f.thing,d:jsontype(k),tostring(k))i,j=f.parser_method(d,l,k)d:assert(i,j)d:assert(h[f.key][i.name]==nil,"%s %s already exists",f.thing,i.name)h[f.key][i.name]=i end end;d:popContext()return true end;local function m(n,o)if type(n)==type(o)then setmetatable(n,getmetatable(o))end end;local p;do local q=setmetatable({},{__mode="k"})p=function(r,s)local t,u,v=1,1,0;local w=q[r]if w and w.pos<s then t=w.line;u=w.pos end;while true do u=r:find("\n",u,true)if u and u<s then t=t+1;v=u;u=u+1 else break end end;return t,s-v end end;local function x(y)return function(r,s)local t,z=p(r,s)return{__pos=s,__line=t,__column=z,__jsontype=y,__jsonmeta=true}end end;local A={}function A:jsontype(B)if type(B)=="table"then local C=getmetatable(B)return C and C.__jsontype or nil else return type(B)end end;function A:assert(D,j,...)if not D then self:error(j,...)end;return D end;function A:assert_type(B,E,j,...)if j then return self:assert(type(B)==E,j,...)else return self:assert(type(B)==E,"expected type '%s', got '%s'",E,type(B))end end;function A:assert_jsontype(B,E,j,...)if j then return self:assert(self:jsontype(B)==E,j,...)else return self:assert(self:jsontype(B)==E,"expected JSON type '%s', got '%s'",E,self:jsontype(B))end end;function A:assert_table_size(B,F,j,...)self:assert_type(B,"table")local G=0;for H,H in pairs(B)do G=G+1 end;if G~=F then if j then self:error(j,...)else self:error("wrong table size, expected %i, got %i",F,G)end end;return B end;local function I(J)local K=getmetatable(J)if K.__line and K.__column then return K.__line,K.__column end end;local function L(J)local t,M=I(J)if t and M then return("line %s column %i"):format(t,M)else return nil end end;function A:error(j,...)if not j then j="unknown error"end;if select("#",...)>0 then j=j:format(...)end;local N={}for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]if P.name then table.insert(N,P.name)end;local Q=L(P.ctx)if Q then if self.name then table.insert(N,self.name)end;error(("%s at %s: %s"):format(table.concat(N," in "),Q,j))end end;if self.name then table.insert(N,self.name)end;if#N>0 then error(("%s: %s"):format(table.concat(N," in "),j))else error(j)end end;function A:setInterpolationChecker(R)self.interpolation_checker=R end;function A:checkInterpolatedString(r)if self.interpolation_checker then self.interpolation_checker(r,self)end;return true end;function A:pushContext(S,T)table.insert(self.ctx_stack,{ctx=S,name=T})self.context=self.ctx_stack[#self.ctx_stack]return self end;function A:popContext()table.remove(self.ctx_stack,#self.ctx_stack)self.context=self.ctx_stack[#self.ctx_stack]end;function A:getContext(T)if not T then return self.context and self.context.ctx end;for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]if P.name==T then return P.ctx end end;return nil end;function A:printContext()for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]print(P.name or"<?>",self:jsontype(P.ctx)or"<?>",L(P.ctx)or"")end end;function A:parseFile(U,V)local W,j=io.open(U,"rb")if not W then return nil,j end;local X=W:read("*a")W:close()self.name=U;return self:parseJSON("ruleset",X,"file "..U,V)end;function A:parseJSON(Y,Z,_,V)self:assert_type(Z,"string","expected a JSON string")local g,H,j=b.decode(Z,1,b.null,x("object"),x("array"))self.name=_;local function a0()if not g then self:error("Error parsing JSON: "..j)end;if Y=="ruleset"then return self:parseRuleSet(g)elseif Y=="phase"then return self:parsePhase(g)elseif Y=="limiter"then return self:parseLimiter(g)elseif Y=="list"then return self:parseList(g)elseif Y=="rule"then return self:parseRule(g)end end;if V then return a0()else local a1,a2=pcall(a0)if not a1 then return nil,a2:match("[^:]*:%d+: (.*)")or a2 else return a2 end end end;function A:parseInterpolatedString(r)for a3 in r:gmatch("%$%b{}")do if not a3:match("^%${[%w_]+}")then self:error("invalid variable \"%s\" in interpolated string",a3)end end;for a3 in r:gmatch("%${?[%w_]*}?")do if a3:sub(2,2)=="{"then if a3:sub(-1)~="}"then self:error("missing '}' in interpolated string")end;a3=a3:sub(3,-2)if a3==""then self:error("invalid variable ${} in interpolated string")elseif a3:match("^%d%d+")then self:error("invalid regex capture \"%s\" in interpolated string. 1-9 only (nginx quirk)",a3)elseif a3:match("^%d.+")then self:error("invalid variable \"%s\" in interpolated string. can't sart with a number (nginx quirk)",a3)end else a3=a3:sub(2,-1)end;if a3==""then self:error("invalid empty variable in interpolated string")end end;return{string=r}end;local function a4(d,g,a5,j)local a6=a5 and g[a5]or g;if not a6 then if d.allow_incomplete then g.incomplete=true;d.incomplete=true else d:error(j or"missing required attribute \"%s\"",a5)end;return false else return true end end;function A:parseRuleSet(g,T)self:pushContext(g,"ruleset")self:assert_type(g,"table","wrong type for ruleset")self.ruleset.name=T or g.name;if a4(self,g,"limiters")then c(self,g,{thing="limiter",key="limiters",type="table",parser_method=self.parseLimiter})self:checkLimiters(g.limiters)end;if a4(self,g,"rules")then c(self,g,{thing="rule",key="rules",type="table",parser_method=function(self,g,T)self:pushContext(g,"rule")self:assert(type(g)~="string",("named rule \"%s\" cannot be a string referring to another named rule \"%s\""):format(T,tostring(g)))self:popContext()return self:parseRule(g,T)end})end;if a4(self,g,"lists")then c(self,g,{thing="list",key="lists",type="table",parser_method=self.parseList})end;if a4(self,g,"phases")then self.ruleset.phases=self:parsePhaseTable(g.phases)end;local function a7(J)local a8=getmetatable(J)if a8 and a8.__jsonmeta then setmetatable(J,{line=a8.__line,col=a8.__column})end;for H,l in pairs(J)do if type(l)=="table"then a7(l)end end end;a7(self.ruleset)return self.ruleset end;function A:parsePhaseTable(g)self:assert(g~=nil,"missing phase table (\"phases\" attribute)")self:assert_jsontype(g,"object","phase table must be an object")self:pushContext(g,"phase table")for a9,aa in pairs(g)do self:assert_type(a9,"string","phase table entries must be strings")if self:jsontype(aa)=="array"then for O,ab in ipairs(aa)do if type(ab)=="string"or self:jsontype(ab)=="array"or self:jsontype(ab)=="object"then aa[O]=self:parseList(ab)else self:error("invalid rule list type: %s",self:jsontype(ab))end end elseif type(aa)=="string"then g[a9]={self:parseList(aa)}elseif self:jsontype(aa)=="object"then g[a9]=self:parseList(aa)end end;self:popContext()return g end;function A:getList(T)local ab=self.ruleset.lists[T]if not ab and self.external then ab=self.external.lists[T]end;return ab end;function A:parseList(g,T)if type(g)=="string"then return self:assert(self:getList(g),([[named list "%s" not found]]):format(g))end;self:pushContext(g,"list")local ab={}if self:jsontype(g)=="object"then if T then self:assert(T==g.name,"rule list 'name' attribute must match outside list name")else T=tostring(g.name)end;g=g.rules end;local ac;if a4(self,g,nil,"missing rule list")then self:assert_jsontype(g,"array","rule list must be an array")ac={}for H,l in ipairs(g)do table.insert(ac,self:parseRule(l))end end;self:popContext()ab.name=T;ab.rules=ac;m(ab,g)return ab end;function A:getRule(T)local ad=self.ruleset.rules[T]if not ad and self.external then ad=self.external.rules[T]end;return ad end;function A:parseRule(g,T)self:pushContext(g,"rule")local ae;if type(g)=="string"then ae=self:getRule(g)self:assert(ae,([[named rule "%s" not found]]):format(g))self:popContext()return ae end;self:assert_type(g,"table","invalid rule data type: "..type(g))self:assert_jsontype(g,"object",("invalid rule data type: %s"):format(self:jsontype(g)))if g["if"]or g["if-any"]or g["if-all"]or g["then"]then self:assert(not g["always"],[["always" clause can't be present in if/then rule]])self:assert(not g["switch"],[["switch" clause can't be present in if/then rule]])end;if g["then"]then if g["if"]and(g["if-any"]or g["if-all"])or g["if-any"]and g["if-all"]then self:error("only one of \"if\", \"if-any\" or \"if-all\" allowed in if/then rule")end;local af;if g["if"]then self:pushContext(g,"if")af=self:parseCondition(g["if"])self:popContext()elseif g["if-any"]or g["if-all"]then local ag={}self:pushContext(g,"if")for H,l in ipairs(g["if-any"]or g["if-all"])do af=self:assert(self:parseCondition(l))table.insert(ag,af)end;self:popContext()af={[g["if-any"]and"any"or"all"]=ag}m(af,g["if"]or g["if-any"]or g["if-all"])g["if-any"]=nil;g["if-all"]=nil end;g["if"]=af elseif g["always"]then g["if"]={["true"]={}}g["then"]=g["always"]g["always"]=nil elseif next(g)==nil then self:error("empty rule not allowed")elseif self.allow_incomplete then g.incomplete=true;self.incomplete=true else self:error("rule must have at least an \"if\", \"then\", or \"always\" attribute")end;if not g.name then g.name=T end;if g["if"]then if a4(self,g,"then")then g["then"]=self:parseActions(g["then"],"then")end;if g["else"]or not self.allow_incomplete then g["else"]=self:parseActions(g["else"],"else")end end;if g.key then g.key=self:parseInterpolatedString(g.key)end;self:popContext()return g end;function A:parseCondition(g)self:pushContext(g,"condition")local af;if type(g)=="string"then af={[g]={}}elseif type(g)=="table"then self:assert_jsontype(g,"object","condition cannot be an array, must be an object")self:assert_table_size(g,1,"condition object must have exactly one attribute (the condition name)")af=g else self:error("wrong type (%s) for condition",type(g))end;self:popContext()self:pushContext(g,"condition "..next(af))af=a.condition.parse(af,self)self:popContext()m(af,g)return af end;function A:parseAction(g)self:pushContext(g,"action")local ah;if type(g)=="string"then ah={[g]={}}elseif self:jsontype(g)=="object"then self:assert(next(g,next(g))==nil,"action object must have only 1 attribute -- the action name")ah=g else self:error("action must be string on 1-attribute object, but instead was a %s",self:jsontype(g))end;self:popContext()self:pushContext(g,("\"%s\" action"):format(next(ah)))m(ah,g)ah=a.action.parse(ah,self)self:popContext()return ah end;function A:parseActions(g,T)if g==nil then return{}end;self:pushContext(g,T and("\"%s\" actions"):format(T)or nil)local ai={}m(ai,g)if self:jsontype(g)=="object"or type(g)=="string"or#g==0 and next(g)~=nil then table.insert(ai,self:parseAction(g))elseif type(g)=="table"then for H,l in ipairs(g)do table.insert(ai,self:parseAction(l))end end;self:popContext()return ai end;function A:parseTimeInterval(g,j)if j then j=" for "..j end;local aj=self:jsontype(g)if aj=="number"then return g elseif aj=="string"then local ak,al=g:match("^([%d.]+)([%w_]*)")local am;ak=tonumber(ak)self:assert(ak and al,("invalid time string \"%s\"%s"):format(g,j))if al=="ms"or al:match("^millisec(ond(s?))?")then am=.01 elseif al==""or al=="s"or al:match("^sec(ond(s?))?")then am=1 elseif al=="m"or al:match("^min(ute(s)?)?")then am=60 elseif al=="h"or al:match("^hour(s?)")then am=3600 elseif al=="d"or al:match("^day(s)?")then am=86400 elseif al=="w"or al=="wk"or al:match("^week(s)?")then am=604800 elseif al=="M"or al:match("^month(s)?")then am=2628001 else self:error("unknown time unit \"%s\"%s",al,j)end;return ak*am else self:error("invalid time inteval type \"%s\"%s",self:jsontype(g),j)end end;function A:getLimiter(T)local an=self.ruleset.limiters[T]if not an and self.external then an=self.external.limiters[T]end;return an end;function A:parseLimiter(g,T)self:pushContext(g,"limiter")if not g.name then g.name=T end;if a4(self,g,"interval")then g.interval=self:parseTimeInterval(g.interval,"interval value")self:assert(g.interval>=60,"\"interval\" value must be >= 60 seconds")end;if a4(self,g,"limit")then g.limit=self:assert(tonumber(g.limit),"invalid \"limit\" value, must be a number")self:assert(g.limit>=0,"\"limit\" value must be >= 0")end;if g.sync_steps then g.sync_steps=self:assert(tonumber(g.sync_steps),"invalid \"sync-steps\" value")end;if g.burst then self:assert_type(g.burst,"string","invalid \"burst\" value type")end;if g["burst-expire"]then g.burst_expire=self:parseTimeInterval(g["burst-expire"],"burst_expire value")g["burst-expire"]=nil end;self:assert_type(g.name,"string","invalid limiter name")self:popContext()return g end;function A:checkLimiters(g)if not g then return true end;self:pushContext(g,"limiters")for H,l in pairs(g)do self:pushContext(l,("limiter \"%s\""):format(l.name))if l.burst then self:assert(g[l.burst],("limiter references unknown burst limiter \"%s\""):format(l.burst))end;self:popContext()end;self:popContext()end;local ao={__index=A}local function ap(f)local d={name="<?>",ctx_stack={},ruleset={limiters={},rules={},lists={},phases={}}}f=f or{}if f.external then d.external={}for k,G in pairs{lists="list",rules="rule",limiters="limiter"}do local aq=f.external[G]d.external[k]=setmetatable({},{__index=function(J,ar)local i=aq(ar)if i then if type(i)~="table"then i={name=ar,external=true}else error("how do?...")end end;J[ar]=i;return i end})end end;if f.allow_incomplete then d.allow_incomplete=true end;setmetatable(d,ao)return d end;return{new=ap,RuleComponent=a}

end)

module("ruleset", function()
local a=require"rulecomponent"local b=require"binding"local c=require"dkjson"local d;local e=function(f,g)local h={}for i,j in pairs(f)do h[i]=j end;if g then return h else return setmetatable(h,getmetatable(f))end end;local function k(l,f,m)assert(m.name,("a %s must have a name"):format(l))assert(not f[m.name],("%s \"%s\" already exists"):format(l,m.name))end;local function n(o)if type(o)=="string"then return o elseif type(o)=="table"then return o.name else return o end end;local function p(f,q)local h={}setmetatable(h,getmetatable(f))for i,j in pairs(f)do if not q[i]then h[i]=j end end;return h end;local function r(f)local s={}for i in pairs(f)do table.insert(s,i)end;table.sort(s)return s end;local t={}local u={}u.ruleset={__index=t,__jsonorder={"name","info","phases","limiters","lists","rules"}}u.phase={new=function(v,m)return setmetatable({name=v,lists=m},u.phase)end,__index={toJSON=function(self)return c.encode(self,{indent=true})end},__jsonval=function(self)local w={}for x,y in pairs(self.lists)do table.insert(w,y.name)end;return w end}u.rules={__jsonorder=r}u.lists={__jsonorder=r}u.limiters={__jsonorder=r}u.list={new=function(m)return setmetatable(m,u.list)end,__index={toJSON=function(self)return c.encode(self,{indent=true})end},__jsonorder={"name","info","rules"},__jsonval=function(self)local z={}for x,A in pairs(self.rules)do table.insert(z,A.name)end;if self.info then return setmetatable({info=self.info,rules=z},getmetatable(self))else return setmetatable(z,getmetatable(self))end end}local B={__index={toJSON=function(self)return c.encode(self,{indent=true})end}}u.rule={new=function(m,C)local A=setmetatable(m,u.rule)if m["if"]then m["if"]=a.condition.new(A["if"],C)end;for x,D in pairs{"then","else"}do if m[D]then local E=setmetatable({},B)for x,j in pairs(m[D])do table.insert(E,a.action.new(j,C))end;m[D]=E end end;return m end,__index={toJSON=function(self)return c.encode(self,{indent=true})end},__jsonorder={"name","info","key","if","if-any","if-all","then","else"},__jsonval=function(self)if#self["else"]<=1 or#self["then"]<=1 or self.key or self["if"].condition=="any"or self["if"].condition=="all"or self["refs"]then local F=e(self)if self["if"].condition=="any"then F["if-any"]=F["if"].data;F["if"]=nil end;if self["if"].condition=="all"then F["if-all"]=F["if"].data;F["if"]=nil end;if#self["then"]==0 then F["then"]=nil end;if#self["then"]==1 then F["then"]=self["then"][1]end;if#self["else"]==0 then F["else"]=nil end;if#self["else"]==1 then F["else"]=self["else"][1]end;if self.key then self.key=self.key.string end;if F.refs then F.refs=nil end;return F end;return self end}u.limiter={new=function(m)return setmetatable(m,u.limiter)end,__index={toJSON=function(self)return c.encode(self,{indent=true})end},__jsonorder={"name","info","limit","interval","burst","burst-expire"},__jsonval=function(self)if self.burst then local h=e(self)h.burst=h.burst["name"]return h end;return self end}local function G(self,H,I,v,m)local o=I(self,v)if not o then return nil,("%s \"%s\" not found."):format(H,v)end;local J={}for i,j in pairs(m)do J[i]={old=o[i],new=j}o[i]=j end;b.call(H,"update",o,J)return o end;function t:findLimiter(v)return self.limiters[n(v)]end;function t:addLimiter(m,K)if m.__already_loaded_as_burst_limiter then m.__already_loaded_as_burst_limiter=nil;return nil end;k("limiter",self.limiters,m)local L=u.limiter.new(m)self.limiters[m.name]=L;if L.burst then local M=self:findLimiter(L.burst)if not M then M=self:addLimiter(K[L.burst],K)K[L.burst].__already_loaded_as_burst_limiter=true;L.burst=M end end;b.call("limiter","create",L)return L end;function t:updateLimiter(v,m)if m.burst then local N=self:findLimiter(m.burst)assert(N,("unknown burst limiter \"%s\""):format(n(m.burst)))m.burst=N end;return G(self,"limiter",self.findLimiter,v,m)end;function t:deleteLimiter(L)assert(self.limiters[L.name]==L,"tried deleting unexpected limiter of the same name")self.limiters[L.name]=nil;b.call("limiter","delete",L)end;function t:findRule(v)return self.rules[n(v)]end;function t:addRule(m)if not m.name then m.name=self:uniqueName("rule")else k("rule",self.rules,m)end;local A=u.rule.new(m,self)self.rules[m.name]=A;b.call("rule","create",A)return A end;function t:updateRule(v,m)return G(self,"rule",self.findRule,v,m)end;function t:deleteRule(A)assert(self.rules[A.name]==A,"tried deleting unexpected rule of the same name")for O,y in pairs(self.lists)do for x,P in ipairs(y)do assert(P~=A,("can't delete rule \"%s\", it's used in list \"%s\""):format(A.name,O))end end;self.rules[A.name]=nil;if A["if"]then a.condition.delete(A["if"],self)end;for x,D in pairs{"then","else"}do if A[D]then local E=A[D]for x,Q in pairs(E)do a.action.delete(Q,self)end;A[D]={}end end;b.call("rule","delete",A)end;function t:findList(v)return self.lists[n(v)]end;function t:addList(m)assert(m.rules)if not m.name then m.name=self:uniqueName("list")else k("list",self.lists,m)end;for R,S in ipairs(m.rules)do m.rules[R]=self:findRule(S.name)or self:addRule(S)end;local y=u.list.new(m)self.lists[m.name]=y;b.call("list","create",y)return y end;function t:updateList(v,m)if m.rules then m=m.rules;if m.name then assert(v==m.name)end end;for R,S in ipairs(m.rules)do m.rules[R]=self:findRule(S.name)or self:addRule(S)end;return G(self,"list",self.findList,v,m)end;function t:deleteList(y)assert(self.lists[y.name]==y,"tried deleting unexpected list of the same name")for T,U in pairs(self.phases)do for x,V in ipairs(U)do assert(V~=y,("can't delete list \"%s\", it's used in phase \"%s\""):format(y.name,T))end end;self.lists[y.name]=nil;b.call("list","delete",y)end;local W={request=true}function t:addPhase(m,v)local w;if m.name then if v then assert(v==m.name)end;w=m.lists else assert(v)w=m end;assert(W[v],("unknown phase \"%s\""):format(v))assert(not self.phases[v],("phase \"%s\" already exists"):format(v))local X;for R,y in ipairs(w)do if type(y)=="string"then y,X=self:findList(y)else y,X=self:findList(y)if not y then y,X=self:addList(y)end end;if not y then return nil,X or("can't find list \"%s\" for phase \"%s\""):format(y,v)end;w[R]=y end;local U=u.phase.new(v,w)b.call("phase","create",U)return U end;function t:deletePhase(v)local U=assert(self.phases[v],("phase \"%s\" does not exist"):format(v))b.call("phase","delete",U)self.phases[v]=nil end;function t:uniqueName(o)local Y={ruleset={},rule=self.rules,list=self.lists,limiter=self.limiters}local Z=Y[o]if Z==nil then error("don't knoq how to generate unique name for "..tostring(o))end;return assert(d.uniqueName(o,Z,self),"unique name can't be nil")end;function t:toJSON()local _={name=self.name,info=self.info,rules=e(self.rules),lists=e(self.lists),limiters=e(self.limiters),phases=self.phases}setmetatable(_,u.ruleset)local a0={name=true}for x,a1 in ipairs({"rules","lists","limiters","phases"})do local a2=_[a1]or{}for i,o in pairs(a2)do a2[i]=p(o,a0)end end;return c.encode(_,{indent=true})end;function t:destroy()for v,x in pairs(self.phases)do self:deletePhase(v)end;for x,y in pairs(self.lists)do self:deleteList(y)end;for x,A in pairs(self.rules)do self:deleteRule(A)end;for x,L in pairs(self.limiters)do self:deleteLimiter(L)end;b.call("ruleset","delete",self)end;d={new=function(m)local C=setmetatable({rules=setmetatable({},u.rules),lists=setmetatable({},u.lists),limiters=setmetatable({},u.limiters),phases=setmetatable({},u.phases),name=m and m.name or nil},u.ruleset)if not C.name then C.name=C:uniqueName("ruleset")end;if m then for x,j in pairs(m.limiters)do C:addLimiter(j,m.limiters)end;for x,j in pairs(m.rules)do C:addRule(j)end;for x,j in pairs(m.lists)do C:addList(j)end;for a3,j in pairs(m.phases)do C:addPhase(j,a3)end end;b.call("ruleset","create",C)return C end,newLimiter=u.limiter.new,newPhase=u.phase.new,newList=u.list.new,newRule=u.rule.new,uniqueName=function(a4,Z,C)error("uniqueName must be configured outside the Ruleset module")end,RuleComponent=a}return d

end)


return main()
