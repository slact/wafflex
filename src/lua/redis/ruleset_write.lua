--autogenerated script, do not edit
local require, module; do
  local modules = {}
  module = function(name, fn) modules[name]=fn() end
  require = function(name) return modules[name] end
end
--luacheck: ignore
local function main()
  local Parser = require "parser"
  local inspect = require "inspect"
  --luacheck: globals redis cjson ARGV
  local hmm = function(thing)
    local out = inspect(thing)
    for line in out:gmatch('[^\r\n]+') do
      redis.call("ECHO", line)
    end
  end
  
  local data = [[
  {
    "name":"banana"
    "phases": {}
  }
  ]]
  
  
  
  local p = Parser:new()
  
  local res, err = p:parseJSON(data, "testinput")
  if not res then error(err) end
  hmm(res)
  return 27

end

module("inspect", function()
local a={_VERSION='inspect.lua 3.1.0',_URL='http://github.com/kikito/inspect.lua',_DESCRIPTION='human-readable representations of tables',_LICENSE=[[
    MIT LICENSE

    Copyright (c) 2013 Enrique Garc√≠a Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]}local tostring=tostring;a.KEY=setmetatable({},{__tostring=function()return'inspect.KEY'end})a.METATABLE=setmetatable({},{__tostring=function()return'inspect.METATABLE'end})local function b(c)if c:match('"')and not c:match("'")then return"'"..c.."'"end;return'"'..c:gsub('"','\\"')..'"'end;local d={["\a"]="\\a",["\b"]="\\b",["\f"]="\\f",["\n"]="\\n",["\r"]="\\r",["\t"]="\\t",["\v"]="\\v"}local e={}for f=0,31 do local g=string.char(f)if not d[g]then d[g]="\\"..f;e[g]=string.format("\\%03d",f)end end;local function h(c)return c:gsub("\\","\\\\"):gsub("(%c)%f[0-9]",e):gsub("%c",d)end;local function i(c)return type(c)=='string'and c:match("^[_%a][_%a%d]*$")end;local function j(k,l)return type(k)=='number'and 1<=k and k<=l and math.floor(k)==k end;local m={['number']=1,['boolean']=2,['string']=3,['table']=4,['function']=5,['userdata']=6,['thread']=7}local function n(o,p)local q,r=type(o),type(p)if q==r and(q=='string'or q=='number')then return o<p end;local s,t=m[q],m[r]if s and t then return m[q]<m[r]elseif s then return true elseif t then return false end;return q<r end;local function u(v)local w=1;local x=rawget(v,w)while x~=nil do w=w+1;x=rawget(v,w)end;return w-1 end;local function y(v)local z={}local l=u(v)for k,A in pairs(v)do if not j(k,l)then table.insert(z,k)end end;table.sort(z,n)return z,l end;local function B(v,C)local D=type(C)=='table'and rawget(C,'__tostring')local c,E;if type(D)=='function'then E,c=pcall(D,v)c=E and c or'error: '..tostring(c)end;if type(c)=='string'and#c>0 then return c end end;local function F(v,G)G=G or{}if type(v)=='table'then if not G[v]then G[v]=1;for k,x in pairs(v)do F(k,G)F(x,G)end;F(getmetatable(v),G)else G[v]=G[v]+1 end end;return G end;local H=function(I)local J,w={},#I;for f=1,w do J[f]=I[f]end;return J,w end;local function K(L,...)local z={...}local M,w=H(L)for f=1,#z do M[w+f]=z[f]end;return M end;local function N(O,P,L,Q)if P==nil then return nil end;if Q[P]then return Q[P]end;local R=O(P,L)if type(R)=='table'then local S={}Q[P]=S;local T;for k,x in pairs(R)do T=N(O,k,K(L,k,a.KEY),Q)if T~=nil then S[T]=N(O,x,K(L,T),Q)end end;local C=N(O,getmetatable(R),K(L,a.METATABLE),Q)setmetatable(S,C)R=S end;return R end;local U={}local V={__index=U}function U:puts(...)local W={...}local X=self.buffer;local w=#X;for f=1,#W do w=w+1;X[w]=W[f]end end;function U:down(Y)self.level=self.level+1;Y()self.level=self.level-1 end;function U:tabify()self:puts(self.newline,string.rep(self.indent,self.level))end;function U:alreadyVisited(x)return self.ids[x]~=nil end;function U:getId(x)local Z=self.ids[x]if not Z then local _=type(x)Z=(self.maxIds[_]or 0)+1;self.maxIds[_]=Z;self.ids[x]=Z end;return tostring(Z)end;function U:putKey(k)if i(k)then return self:puts(k)end;self:puts("[")self:putValue(k)self:puts("]")end;function U:putTable(v)if v==a.KEY or v==a.METATABLE then self:puts(tostring(v))elseif self:alreadyVisited(v)then self:puts('<table ',self:getId(v),'>')elseif self.level>=self.depth then self:puts('{...}')else if self.tableAppearances[v]>1 then self:puts('<',self:getId(v),'>')end;local a0,l=y(v)local C=getmetatable(v)local a1=B(v,C)self:puts('{')self:down(function()if a1 then self:puts(' -- ',h(a1))if l>=1 then self:tabify()end end;local a2=0;for f=1,l do if a2>0 then self:puts(',')end;self:puts(' ')self:putValue(v[f])a2=a2+1 end;for A,k in ipairs(a0)do if a2>0 then self:puts(',')end;self:tabify()self:putKey(k)self:puts(' = ')self:putValue(v[k])a2=a2+1 end;if C then if a2>0 then self:puts(',')end;self:tabify()self:puts('<metatable> = ')self:putValue(C)end end)if#a0>0 or C then self:tabify()elseif l>0 then self:puts(' ')end;self:puts('}')end end;function U:putValue(x)local _=type(x)if _=='string'then self:puts(b(h(x)))elseif _=='number'or _=='boolean'or _=='nil'then self:puts(tostring(x))elseif _=='table'then self:putTable(x)else self:puts('<',_,' ',self:getId(x),'>')end end;function a.inspect(a3,a4)a4=a4 or{}local a5=a4.depth or math.huge;local a6=a4.newline or'\n'local a7=a4.indent or'  'local O=a4.process;if O then a3=N(O,a3,{},{})end;local a8=setmetatable({depth=a5,level=0,buffer={},ids={},maxIds={},newline=a6,indent=a7,tableAppearances=F(a3)},V)a8:putValue(a3)return table.concat(a8.buffer)end;setmetatable(a,{__call=function(A,...)return a.inspect(...)end})return a

end)

module("dkjson", function()
local a=false;local b=false;local c='json'local pairs,type,tostring,tonumber,getmetatable,setmetatable,rawset=pairs,type,tostring,tonumber,getmetatable,setmetatable,rawset;local error,require,pcall,select=error,require,pcall,select;local d,e=math.floor,math.huge;local f,g,h,i,j,k,l,m=string.rep,string.gsub,string.sub,string.byte,string.char,string.find,string.len,string.format;local n=string.match;local o=table.concat;local p={version="dkjson 2.5"}if b then _G[c]=p end;local q=nil;pcall(function()local r=require"debug".getmetatable;if r then getmetatable=r end end)p.null=setmetatable({},{__tojson=function()return"null"end})local function s(t)local u,v,w=0,0,0;for x,y in pairs(t)do if x=='n'and type(y)=='number'then w=y;if y>u then u=y end else if type(x)~='number'or x<1 or d(x)~=x then return false end;if x>u then u=x end;v=v+1 end end;if u>10 and u>w and u>v*2 then return false end;return true,u end;local z={["\""]="\\\"",["\\"]="\\\\",["\b"]="\\b",["\f"]="\\f",["\n"]="\\n",["\r"]="\\r",["\t"]="\\t"}local function A(B)local C=z[B]if C then return C end;local D,E,F,G=i(B,1,4)D,E,F,G=D or 0,E or 0,F or 0,G or 0;if D<=0x7f then C=D elseif 0xc0<=D and D<=0xdf and E>=0x80 then C=(D-0xc0)*0x40+E-0x80 elseif 0xe0<=D and D<=0xef and E>=0x80 and F>=0x80 then C=((D-0xe0)*0x40+E-0x80)*0x40+F-0x80 elseif 0xf0<=D and D<=0xf7 and E>=0x80 and F>=0x80 and G>=0x80 then C=(((D-0xf0)*0x40+E-0x80)*0x40+F-0x80)*0x40+G-0x80 else return""end;if C<=0xffff then return m("\\u%.4x",C)elseif C<=0x10ffff then C=C-0x10000;local H,I=0xD800+d(C/0x400),0xDC00+C%0x400;return m("\\u%.4x\\u%.4x",H,I)else return""end end;local function J(K,L,M)if k(K,L)then return g(K,L,M)else return K end end;local function N(C)C=J(C,"[%z\1-\31\"\\\127]",A)if k(C,"[\194\216\220\225\226\239]")then C=J(C,"\194[\128-\159\173]",A)C=J(C,"\216[\128-\132]",A)C=J(C,"\220\143",A)C=J(C,"\225\158[\180\181]",A)C=J(C,"\226\128[\140-\143\168-\175]",A)C=J(C,"\226\129[\160-\175]",A)C=J(C,"\239\187\191",A)C=J(C,"\239\191[\176-\191]",A)end;return"\""..C.."\""end;p.quotestring=N;local function O(K,P,v)local Q,R=k(K,P,1,true)if Q then return h(K,1,Q-1)..v..h(K,R+1,-1)else return K end end;local S,T;local function U()S=n(tostring(0.5),"([^05+])")T="[^0-9%-%+eE"..g(S,"[%^%$%(%)%%%.%[%]%*%+%-%?]","%%%0").."]+"end;U()local function V(W)return O(J(tostring(W),T,""),S,".")end;local function X(K)local W=tonumber(O(K,".",S))if not W then U()W=tonumber(O(K,".",S))end;return W end;local function Y(Z,_,a0)_[a0+1]="\n"_[a0+2]=f("  ",Z)a0=a0+2;return a0 end;function p.addnewline(a1)if a1.indent then a1.bufferlen=Y(a1.level or 0,a1.buffer,a1.bufferlen or#a1.buffer)end end;local a2;local function a3(a4,C,a5,a6,Z,_,a0,a7,a8,a1)local a9=type(a4)if a9~='string'and a9~='number'then return nil,"type '"..a9 .."' is not supported as a key by JSON."end;if a5 then a0=a0+1;_[a0]=","end;if a6 then a0=Y(Z,_,a0)end;_[a0+1]=N(a4)_[a0+2]=":"return a2(C,a6,Z,_,a0+2,a7,a8,a1)end;local function aa(ab,_,a1)local a0=a1.bufferlen;if type(ab)=='string'then a0=a0+1;_[a0]=ab end;return a0 end;local function ac(ad,C,a1,_,a0,ae)ae=ae or ad;local af=a1.exception;if not af then return nil,ae else a1.bufferlen=a0;local ag,ah=af(ad,C,a1,ae)if not ag then return nil,ah or ae end;return aa(ag,_,a1)end end;function p.encodeexception(ad,C,a1,ae)return N("<"..ae..">")end;a2=function(C,a6,Z,_,a0,a7,a8,a1)local ai=type(C)local aj=getmetatable(C)aj=type(aj)=='table'and aj;local ak=aj and aj.__jsonval;if ak then if type(ak)=="function"then C=ak(C)else C=ak end;ai=type(C)end;local al=aj and aj.__tojson;if al then if a7[C]then return ac('reference cycle',C,a1,_,a0)end;a7[C]=true;a1.bufferlen=a0;local ag,ah=al(C,a1)if not ag then return ac('custom encoder failed',C,a1,_,a0,ah)end;a7[C]=nil;a0=aa(ag,_,a1)elseif C==nil then a0=a0+1;_[a0]="null"elseif ai=='number'then local am;if C~=C or C>=e or-C>=e then am="null"else am=V(C)end;a0=a0+1;_[a0]=am elseif ai=='boolean'then a0=a0+1;_[a0]=C and"true"or"false"elseif ai=='string'then a0=a0+1;_[a0]=N(C)elseif ai=='table'then if a7[C]then return ac('reference cycle',C,a1,_,a0)end;a7[C]=true;Z=Z+1;local an,v=s(C)if v==0 and aj and aj.__jsontype=='object'then an=false end;local ah;if an then a0=a0+1;_[a0]="["for Q=1,v do a0,ah=a2(C[Q],a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;if Q<v then a0=a0+1;_[a0]=","end end;a0=a0+1;_[a0]="]"else local a5=false;a0=a0+1;_[a0]="{"local ao=aj and aj.__jsonorder or a8;if ao then if type(ao)=="function"then ao=ao(C)end;local ap={}v=#ao;for Q=1,v do local x=ao[Q]local y=C[x]if y then ap[x]=true;a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)a5=true end end;for x,y in pairs(C)do if not ap[x]then a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;a5=true end end else for x,y in pairs(C)do a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;a5=true end end;if a6 then a0=Y(Z-1,_,a0)end;a0=a0+1;_[a0]="}"end;a7[C]=nil else return ac('unsupported type',C,a1,_,a0,"type '"..ai.."' is not supported by JSON.")end;return a0 end;function p.encode(C,a1)a1=a1 or{}local aq=a1.buffer;local _=aq or{}a1.buffer=_;U()local ag,ah=a2(C,a1.indent,a1.level or 0,_,a1.bufferlen or 0,a1.tables or{},a1.keyorder,a1)if not ag then error(ah,2)elseif aq==_ then a1.bufferlen=ag;return true else a1.bufferlen=nil;a1.buffer=nil;return o(_)end end;local function ar(K,as)local at,au,av=1,1,0;while true do au=k(K,"\n",au,true)if au and au<as then at=at+1;av=au;au=au+1 else break end end;return"line "..at..", column "..as-av end;local function aw(K,ax,as)return nil,l(K)+1,"unterminated "..ax.." at "..ar(K,as)end;local function ay(K,au)while true do au=k(K,"%S",au)if not au then return nil end;local az=h(K,au,au+1)if az=="\239\187"and h(K,au+2,au+2)=="\191"then au=au+3 elseif az=="//"then au=k(K,"[\n\r]",au+2)if not au then return nil end elseif az=="/*"then au=k(K,"*/",au+2)if not au then return nil end;au=au+2 else return au end end end;local aA={["\""]="\"",["\\"]="\\",["/"]="/",["b"]="\b",["f"]="\f",["n"]="\n",["r"]="\r",["t"]="\t"}local function aB(C)if C<0 then return nil elseif C<=0x007f then return j(C)elseif C<=0x07ff then return j(0xc0+d(C/0x40),0x80+d(C)%0x40)elseif C<=0xffff then return j(0xe0+d(C/0x1000),0x80+d(C/0x40)%0x40,0x80+d(C)%0x40)elseif C<=0x10ffff then return j(0xf0+d(C/0x40000),0x80+d(C/0x1000)%0x40,0x80+d(C/0x40)%0x40,0x80+d(C)%0x40)else return nil end end;local function aC(K,au)local aD=au+1;local _,v={},0;while true do local aE=k(K,"[\"\\]",aD)if not aE then return aw(K,"string",au)end;if aE>aD then v=v+1;_[v]=h(K,aD,aE-1)end;if h(K,aE,aE)=="\""then aD=aE+1;break else local aF=h(K,aE+1,aE+1)local C;if aF=="u"then C=tonumber(h(K,aE+2,aE+5),16)if C then local aG;if 0xD800<=C and C<=0xDBff then if h(K,aE+6,aE+7)=="\\u"then aG=tonumber(h(K,aE+8,aE+11),16)if aG and 0xDC00<=aG and aG<=0xDFFF then C=(C-0xD800)*0x400+aG-0xDC00+0x10000 else aG=nil end end end;C=C and aB(C)if C then if aG then aD=aE+12 else aD=aE+6 end end end end;if not C then C=aA[aF]or aF;aD=aE+2 end;v=v+1;_[v]=C end end;if v==1 then return _[1],aD elseif v>1 then return o(_),aD else return"",aD end end;local aH;local function aI(t,aJ,K,au)if type(aJ)=="function"then aJ=aJ(K,au)if type(aJ)~="table"then return t end end;return setmetatable(t,aJ)end;local function aK(ax,aL,K,aM,aN,aO,aP)local aQ=l(K)local t,v={},0;local au=aM+1;if ax=='object'then aI(t,aO,K,aM)else aI(t,aP,K,aM)end;while true do au=ay(K,au)if not au then return aw(K,ax,aM)end;local aR=h(K,au,au)if aR==aL then return t,au+1 end;local aS,aT;aS,au,aT=aH(K,au,aN,aO,aP)if aT then return nil,au,aT end;au=ay(K,au)if not au then return aw(K,ax,aM)end;aR=h(K,au,au)if aR==":"then if aS==nil then return nil,au,"cannot use nil as table index (at "..ar(K,au)..")"end;au=ay(K,au+1)if not au then return aw(K,ax,aM)end;local aU;aU,au,aT=aH(K,au,aN,aO,aP)if aT then return nil,au,aT end;t[aS]=aU;au=ay(K,au)if not au then return aw(K,ax,aM)end;aR=h(K,au,au)else v=v+1;t[v]=aS end;if aR==","then au=au+1 end end end;aH=function(K,au,aN,aO,aP)au=au or 1;au=ay(K,au)if not au then return nil,l(K)+1,"no valid JSON value (reached the end)"end;local aR=h(K,au,au)if aR=="{"then return aK('object',"}",K,au,aN,aO,aP)elseif aR=="["then return aK('array',"]",K,au,aN,aO,aP)elseif aR=="\""then return aC(K,au)else local aV,aW=k(K,"^%-?[%d%.]+[eE]?[%+%-]?%d*",au)if aV then local aX=X(h(K,aV,aW))if aX then return aX,aW+1 end end;aV,aW=k(K,"^%a%w*",au)if aV then local aY=h(K,aV,aW)if aY=="true"then return true,aW+1 elseif aY=="false"then return false,aW+1 elseif aY=="null"then return aN,aW+1 end end;return nil,au,"no valid JSON value at "..ar(K,au)end end;local function aZ(...)if select("#",...)>0 then return...else return{__jsontype='object'},{__jsontype='array'}end end;function p.decode(K,au,aN,...)local aO,aP=aZ(...)return aH(K,au,aN,aO,aP)end;function p.use_lpeg()local a_=require("lpeg")if a_.version()=="0.11"then error"due to a bug in LPeg 0.11, it cannot be used for JSON matching"end;local b0=a_.match;local b1,b2,b3=a_.P,a_.S,a_.R;local function b4(K,au,ah,a1)if not a1.msg then a1.msg=ah.." at "..ar(K,au)a1.pos=au end;return false end;local function b5(ah)return a_.Cmt(a_.Cc(ah)*a_.Carg(2),b4)end;local b6=b1"//"*(1-b2"\n\r")^0;local b7=b1"/*"*(1-b1"*/")^0*b1"*/"local b8=(b2" \n\r\t"+b1"\239\187\191"+b6+b7)^0;local b9=1-b2"\"\\\n\r"local ba=b1"\\"*a_.C(b2"\"\\/bfnrt"+b5"unsupported escape sequence")/aA;local bb=b3("09","af","AF")local function bc(bd,au,be,bf)be,bf=tonumber(be,16),tonumber(bf,16)if 0xD800<=be and be<=0xDBff and 0xDC00<=bf and bf<=0xDFFF then return true,aB((be-0xD800)*0x400+bf-0xDC00+0x10000)else return false end end;local function bg(bh)return aB(tonumber(bh,16))end;local bi=b1"\\u"*a_.C(bb*bb*bb*bb)local bj=a_.Cmt(bi*bi,bc)+bi/bg;local bk=bj+ba+b9;local bl=b1"\""*a_.Cs(bk^0)*(b1"\""+b5"unterminated string")local bm=b1"-"^-1*(b1"0"+b3"19"*b3"09"^0)local bn=b1"."*b3"09"^0;local bo=b2"eE"*b2"+-"^-1*b3"09"^1;local bp=bm*bn^-1*bo^-1/X;local bq=b1"true"*a_.Cc(true)+b1"false"*a_.Cc(false)+b1"null"*a_.Carg(1)local br=bp+bl+bq;local bs,bt;local function bu(K,au,aN,a1)local bv,bw;local bx;local by,bz={},0;repeat bv,bw,bx=b0(bs,K,au,aN,a1)if not bx then break end;au=bx;bz=bz+1;by[bz]=bv until bw=='last'return au,setmetatable(by,a1.arraymeta)end;local function bA(K,au,aN,a1)local bv,a4,bw;local bx;local by={}repeat a4,bv,bw,bx=b0(bt,K,au,aN,a1)if not bx then break end;au=bx;by[a4]=bv until bw=='last'return au,setmetatable(by,a1.objectmeta)end;local bB=b1"["*a_.Cmt(a_.Carg(1)*a_.Carg(2),bu)*b8*(b1"]"+b5"']' expected")local bC=b1"{"*a_.Cmt(a_.Carg(1)*a_.Carg(2),bA)*b8*(b1"}"+b5"'}' expected")local bD=b8*(bB+bC+br)local bE=bD+b8*b5"value expected"bs=bD*b8*(b1","*a_.Cc'cont'+a_.Cc'last')*a_.Cp()local bF=a_.Cg(b8*bl*b8*(b1":"+b5"colon expected")*bE)bt=bF*b8*(b1","*a_.Cc'cont'+a_.Cc'last')*a_.Cp()local bG=bE*a_.Cp()function p.decode(K,au,aN,...)local a1={}a1.objectmeta,a1.arraymeta=aZ(...)local bv,bH=b0(bG,K,au,aN,a1)if a1.msg then return nil,a1.pos,a1.msg else return bv,bH end end;p.use_lpeg=function()return p end;p.using_lpeg=true;return p end;if a then pcall(p.use_lpeg)end;return p

end)

module("parser", function()
local a=require"rulecomponent"local b=require"dkjson"local function c(d,e,f)local g=e[f.key]d:pushContext(g,f.key)local h=d.ruleset;if g then d:assert_type(g,f.type,"wrong type for ruleset %s, expected %s, got %s",f.key,f.type,d:jsontype(g))local i,j;for k,l in pairs(g)do d:assert_type(k,"string","wrong key type for %s, expected string, got %s %s",f.thing,d:jsontype(k),tostring(k))i,j=f.parser_method(d,l,k)d:assert(i,j)d:assert(h[f.key][i.name]==nil,"%s %s already exists",f.thing,i.name)h[f.key][i.name]=i end end;d:popContext()return true end;local function m(n,o)if type(n)==type(o)then setmetatable(n,getmetatable(o))end end;local p;do local q=setmetatable({},{__mode="k"})p=function(r,s)local t,u,v=1,1,0;local w=q[r]if w and w.pos<s then t=w.line;u=w.pos end;while true do u=r:find("\n",u,true)if u and u<s then t=t+1;v=u;u=u+1 else break end end;return t,s-v end end;local function x(y)return function(r,s)local t,z=p(r,s)return{__pos=s,__line=t,__column=z,__jsontype=y,__jsonmeta=true}end end;local A={}function A:jsontype(B)if type(B)=="table"then local C=getmetatable(B)return C and C.__jsontype or nil else return type(B)end end;function A:assert(D,j,...)if not D then self:error(j,...)end;return D end;function A:assert_type(B,E,j,...)if j then return self:assert(type(B)==E,j,...)else return self:assert(type(B)==E,"expected type '%s', got '%s'",E,type(B))end end;function A:assert_jsontype(B,E,j,...)if j then return self:assert(self:jsontype(B)==E,j,...)else return self:assert(self:jsontype(B)==E,"expected JSON type '%s', got '%s'",E,self:jsontype(B))end end;function A:assert_table_size(B,F,j,...)self:assert_type(B,"table")local G=0;for H,H in pairs(B)do G=G+1 end;if G~=F then if j then self:error(j,...)else self:error("wrong table size, expected %i, got %i",F,G)end end;return B end;local function I(J)local K=getmetatable(J)if K.__line and K.__column then return K.__line,K.__column end end;local function L(J)local t,M=I(J)if t and M then return("line %s column %i"):format(t,M)else return nil end end;function A:error(j,...)if not j then j="unknown error"end;if select("#",...)>0 then j=j:format(...)end;local N={}for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]if P.name then table.insert(N,P.name)end;local Q=L(P.ctx)if Q then if self.name then table.insert(N,self.name)end;error(("%s at %s: %s"):format(table.concat(N," in "),Q,j))end end;if self.name then table.insert(N,self.name)end;if#N>0 then error(("%s: %s"):format(table.concat(N," in "),j))else error(j)end end;function A:setInterpolationChecker(R)self.interpolation_checker=R end;function A:checkInterpolatedString(r)if self.interpolation_checker then self.interpolation_checker(r,self)end;return true end;function A:pushContext(S,T)table.insert(self.ctx_stack,{ctx=S,name=T})self.context=self.ctx_stack[#self.ctx_stack]return self end;function A:popContext()table.remove(self.ctx_stack,#self.ctx_stack)self.context=self.ctx_stack[#self.ctx_stack]end;function A:getContext(T)if not T then return self.context and self.context.ctx end;for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]if P.name==T then return P.ctx end end;return nil end;function A:printContext()for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]print(P.name or"<?>",self:jsontype(P.ctx)or"<?>",L(P.ctx)or"")end end;function A:parseFile(U,V)local W,j=io.open(U,"rb")if not W then return nil,j end;local X=W:read("*a")W:close()self.name=U;return self:parseJSON("ruleset",X,"file "..U,V)end;function A:parseJSON(Y,Z,_,V)self:assert_type(Z,"string","expected a JSON string")local g,H,j=b.decode(Z,1,b.null,x("object"),x("array"))self.name=_;local function a0()if not g then self:error(j)end;if Y=="ruleset"then return self:parseRuleSet(g)elseif Y=="phase"then return self:parsePhase(g)elseif Y=="limiter"then return self:parseLimiter(g)elseif Y=="list"then return self:parseList(g)elseif Y=="rule"then return self:parseRule(g)end end;if V then return a0()else local a1,a2=pcall(a0)if not a1 then return nil,a2:match("[^:]*:%d+: (.*)")or a2 else return a2 end end end;function A:parseInterpolatedString(r)for a3 in r:gmatch("%$%b{}")do if not a3:match("^%${[%w_]+}")then self:error("invalid variable \"%s\" in interpolated string",a3)end end;for a3 in r:gmatch("%${?[%w_]*}?")do if a3:sub(2,2)=="{"then if a3:sub(-1)~="}"then self:error("missing '}' in interpolated string")end;a3=a3:sub(3,-2)if a3==""then self:error("invalid variable ${} in interpolated string")elseif a3:match("^%d%d+")then self:error("invalid regex capture \"%s\" in interpolated string. 1-9 only (nginx quirk)",a3)elseif a3:match("^%d.+")then self:error("invalid variable \"%s\" in interpolated string. can't sart with a number (nginx quirk)",a3)end else a3=a3:sub(2,-1)end;if a3==""then self:error("invalid empty variable in interpolated string")end end;return{string=r}end;function A:parseRuleSet(g,T)self:pushContext(g,"ruleset")self:assert_type(g,"table","wrong type for ruleset")c(self,g,{thing="limiter",key="limiters",type="table",parser_method=self.parseLimiter})self:checkLimiters(g.limiters)self.ruleset.name=T or g.name;c(self,g,{thing="rule",key="rules",type="table",parser_method=function(self,g,T)self:pushContext(g,"rule")self:assert(type(g)~="string",("named rule \"%s\" cannot be a string referring to another named rule \"%s\""):format(T,tostring(g)))self:popContext()return self:parseRule(g,T)end})c(self,g,{thing="list",key="lists",type="table",parser_method=self.parseList})self.ruleset.phases=self:parsePhaseTable(g.phases)local function a4(J)local a5=getmetatable(J)if a5 and a5.__jsonmeta then setmetatable(J,{line=a5.__line,col=a5.__column})end;for H,l in pairs(J)do if type(l)=="table"then a4(l)end end end;a4(self.ruleset)return self.ruleset end;function A:parsePhaseTable(g)self:assert(g~=nil,"missing phase table (\"phases\" attribute)")self:assert_jsontype(g,"object","phase table must be an object")self:pushContext(g,"phase table")for a6,a7 in pairs(g)do self:assert_type(a6,"string","phase table entries must be strings")if self:jsontype(a7)=="array"then for O,a8 in ipairs(a7)do if type(a8)=="string"or self:jsontype(a8)=="array"or self:jsontype(a8)=="object"then a7[O]=self:parseList(a8)else self:error("invalid rule list type: %s",self:jsontype(a8))end end elseif type(a7)=="string"then g[a6]={self:parseList(a7)}elseif self:jsontype(a7)=="object"then g[a6]=self:parseList(a7)end end;self:popContext()return g end;function A:getList(T)local a8=self.ruleset.lists[T]if not a8 and self.external then a8=self.external.lists[T]end;return a8 end;function A:parseList(g,T)if type(g)=="string"then return self:assert(self:getList(g),([[named list "%s" not found]]):format(g))end;self:pushContext(g,"list")local a8;if self:jsontype(g)=="object"then if T then self:assert(T==g.name,"rule list 'name' attribute must match outside list name")else T=tostring(g.name)end;g=g.rules end;self:assert_jsontype(g,"array","rule list must be an array")local a9={}for H,l in ipairs(g)do table.insert(a9,self:parseRule(l))end;self:popContext()a8={name=T,rules=a9}m(a8,g)return a8 end;function A:getRule(T)local aa=self.ruleset.rules[T]if not aa and self.external then aa=self.external.rules[T]end;return aa end;function A:parseRule(g,T)self:pushContext(g,"rule")local ab;if type(g)=="string"then ab=self:getRule(g)self:assert(ab,([[named rule "%s" not found]]):format(g))self:popContext()return ab end;self:assert_type(g,"table","invalid rule data type: "..type(g))self:assert_jsontype(g,"object",("invalid rule data type: %s"):format(self:jsontype(g)))if g["if"]or g["if-any"]or g["if-all"]or g["then"]then self:assert(not g["always"],[["always" clause can't be present in if/then rule]])self:assert(not g["switch"],[["switch" clause can't be present in if/then rule]])end;if g["then"]then if g["if"]and(g["if-any"]or g["if-all"])or g["if-any"]and g["if-all"]then self:error("only one of \"if\", \"if-any\" or \"if-all\" allowed in if/then rule")end;local ac;if g["if"]then ac=self:parseCondition(g["if"])elseif g["if-any"]or g["if-all"]then local ad={}for H,l in ipairs(g["if-any"]or g["if-all"])do ac=self:assert(self:parseCondition(l))table.insert(ad,ac)end;ac={[g["if-any"]and"any"or"all"]=ad}m(ac,g["if"]or g["if-any"]or g["if-all"])end;ab={["if"]=ac,["then"]=g["then"],["else"]=g["else"],name=g["name"]or T,info=g["info"],key=g["key"]}elseif g["always"]then ab={["if"]={["true"]={}},["then"]=g["always"],name=g["name"]or T,info=g["info"],key=g["key"]}elseif next(g)==nil then self:error("empty rule not allowed")else self:error("rule must have at least an \"if\", \"then\", or \"always\" attribute")end;if ab["if"]then ab["then"]=self:parseActions(ab["then"],"then")ab["else"]=self:parseActions(ab["else"],"else")end;if ab.key then ab.key=self:parseInterpolatedString(ab.key)end;self:popContext()m(ab,g)return ab end;function A:parseCondition(g)self:pushContext(g,"condition")local ac;if type(g)=="string"then ac={[g]={}}elseif type(g)=="table"then self:assert_jsontype(g,"object","condition cannot be an array, must be an object")self:assert_table_size(g,1,"condition object must have exactly one attribute (the condition name)")ac=g else self:error("wrong type (%s) for condition",type(g))end;self:popContext()self:pushContext(g,"condition "..next(ac))ac=a.condition.parse(ac,self)self:popContext()m(ac,g)return ac end;function A:parseAction(g)self:pushContext(g,"action")local ae;if type(g)=="string"then ae={[g]={}}elseif self:jsontype(g)=="object"then self:assert(next(g,next(g))==nil,"action object must have only 1 attribute -- the action name")ae=g else self:error("action must be string on 1-attribute object, but instead was a %s",self:jsontype(g))end;self:popContext()self:pushContext(g,("\"%s\" action"):format(next(ae)))m(ae,g)ae=a.action.parse(ae,self)self:popContext()return ae end;function A:parseActions(g,T)if g==nil then return{}end;self:pushContext(g,T and("\"%s\" actions"):format(T)or nil)local af={}m(af,g)if self:jsontype(g)=="object"or type(g)=="string"or#g==0 and next(g)~=nil then table.insert(af,self:parseAction(g))elseif type(g)=="table"then for H,l in ipairs(g)do table.insert(af,self:parseAction(l))end end;self:popContext()return af end;function A:parseTimeInterval(g,j)if j then j=" for "..j end;local ag=self:jsontype(g)if ag=="number"then return g elseif ag=="string"then local ah,ai=g:match("^([%d.]+)([%w_]*)")local aj;ah=tonumber(ah)self:assert(ah and ai,("invalid time string \"%s\"%s"):format(g,j))if ai=="ms"or ai:match("^millisec(ond(s?))?")then aj=.01 elseif ai==""or ai=="s"or ai:match("^sec(ond(s?))?")then aj=1 elseif ai=="m"or ai:match("^min(ute(s)?)?")then aj=60 elseif ai=="h"or ai:match("^hour(s?)")then aj=3600 elseif ai=="d"or ai:match("^day(s)?")then aj=86400 elseif ai=="w"or ai=="wk"or ai:match("^week(s)?")then aj=604800 elseif ai=="M"or ai:match("^month(s)?")then aj=2628001 else self:error("unknown time unit \"%s\"%s",ai,j)end;return ah*aj else self:error("invalid time inteval type \"%s\"%s",self:jsontype(g),j)end end;function A:getLimiter(T)local ak=self.ruleset.limiters[T]if not ak and self.external then ak=self.external.limiters[T]end;return ak end;function A:parseLimiter(g,T)self:pushContext(g,"limiter")if not g.name then g.name=T end;g.interval=self:parseTimeInterval(g.interval,"interval value")self:assert(g.interval>=60,"\"interval\" value must be >= 60 seconds")self:assert(g.limit,"missing \"limit\" value")g.limit=self:assert(tonumber(g.limit),"invalid \"limit\" value, must be a number")self:assert(g.limit>=0,"\"limit\" value must be >= 0")if g.sync_steps then g.sync_steps=self:assert(tonumber(g.sync_steps),"invalid \"sync-steps\" value")end;if g.burst then self:assert_type(g.burst,"string","invalid \"burst\" value type")end;if g["burst-expire"]then g.burst_expire=self:parseTimeInterval(g["burst-expire"],"burst_expire value")g["burst-expire"]=nil end;self:assert_type(g.name,"string","invalid limiter name")self:popContext()return g end;function A:checkLimiters(g)if not g then return true end;self:pushContext(g,"limiters")for H,l in pairs(g)do self:pushContext(l,("limiter \"%s\""):format(l.name))if l.burst then self:assert(g[l.burst],("limiter references unknown burst limiter \"%s\""):format(l.burst))end;self:popContext()end;self:popContext()end;local al={__index=A}local function am(f)local d={name="<?>",ctx_stack={},ruleset={limiters={},rules={},lists={},phases={}}}f=f or{}if f.external then d.external={}for k,G in pairs{lists="list",rules="rule",limiters="limiter"}do local an=f.external[G]d.external[k]=setmetatable({},{__index=function(J,ao)local i=an(ao)if i then if type(i)~="table"then i={name=ao,external=true}else error("how do?...")end end;J[ao]=i;return i end})end end;setmetatable(d,al)return d end;return{new=am}

end)

module("rulecomponent", function()
local a=require"binding"or{call=function()end}local b=require"mm"local function c(d)return d:sub(1,1)=="#"and d:sub(2)or d end;local e={__index=function(self,f)local g=c(f)if g~=f then return self[c(f)]end end}local function h(i)local self={table=setmetatable({},e)}local function j(k,l)local m,n=next(k)if type(m)=="number"then l:error("invalid data value, expected {\"key\":value}, got {\"key\"}")elseif type(m)~="string"then l:error("unexpected data type %s",type(m))end;local o=self.table[m]if l then l:assert(o,("Unknown %s \"%s\""):format(i,m))else assert(o,("Unknown %s \"%s\""):format(i,m))end;return m,n end;function self.add(m,p)if type(m)=="table"then for q,r in pairs(m)do self.add(r,p)end;return true end;assert(p.parse,("%s missing parse callback"):format(i))assert(self.table[m]==nil,("%s %s already exists"):format(i,m))local s={parse=p.parse,init=p.init,delete=p.delete,meta={__jsonval=p.jsonval,__jsonorder=p.jsonorder or{"action","condition"}}}self.table[m]=s;return true end;function self.parse(k,l)local m,n=j(k,l)n=self.table[m].parse(n,l)or n;return{[m]=n}end;function self.new(k,t)local m,n=j(k)m=c(m)local u=self.table[m]local o=setmetatable({[i]=m,data=n},u.meta)if u.init then local v=u.init(n,o,t)if v then o.data=v end end;a.call(("%s:%s"):format(i,m),"create",o)return o end;function self.delete(o,t)local m=o[i]or o.name;local u=self.table[m]print(i.." DELETE THING "..m.." "..tostring(u.delete))if u.delete then u.delete(o.data,t)end;a.call(("%s:%s"):format(i,m),"delete",o)end;return self end;local w={condition=h("condition"),action=h("action")}w.condition.add("any",{parse=function(k,l)l:assert_jsontype(k,"array","\"any\" condition value must be an array of conditions")for x,r in ipairs(k)do local y=l:parseCondition(r)k[x]=y end end,init=function(k,o,t)for x,r in ipairs(k)do k[x]=w.condition.new(r,t)end end,delete=function(k,t)for q,z in ipairs(k)do w.condition.delete(z,t)end end,jsonval=function(self)return{any=self.data}end})w.condition.add("all",{parse=function(k,l)l:assert_jsontype(k,"array","\"all\" condition value must be an array of conditions")for x,r in ipairs(k)do local y=l:parseCondition(r)k[x]=y end end,init=function(k,t)for x,r in ipairs(k)do k[x]=w.condition.new(r,t)end end,delete=function(k,t)for q,z in ipairs(k)do w.condition.delete(z,t)end end,jsonval=function(self)return{all=self.data}end})w.condition.add({"true","false"},{parse=function(k,l)end,jsonval=function(self)return self.condition end})w.condition.add("tag-check",{parse=function(k,l)l:assert_type(k,"string","\"tag-check\" value must be a string")return l:parseInterpolatedString(k)end,init=function(k)a.call("string","create",k)end,delete=function(k)a.call("string","delete",k)end,jsonval=function(self)return{["tag-check"]=self.data.string}end})w.condition.add("match",{parse=function(k,l)l:assert_jsontype(k,"array","\"match\" value must be an array of strings")for x,r in ipairs(k)do l:assert_jsontype(r,"string","\"match\" value must be an array of strings")k[x]=l:parseInterpolatedString(r)end end,init=function(k)local A=function(d)local B=0;for q in d.string:gmatch("%$")do B=B+1 end;return B end;local C=function(D,E)return A(D)<A(E)end;table.sort(k,C)for q,d in ipairs(k)do a.call("string","create",d)end end,delete=function(k)for q,d in ipairs(k)do a.call("string","delete",d)end end,jsonval=function(self)local F={}for q,d in ipairs(self.data)do table.insert(F,d.string)end;return{match=F}end})local G={__jsonorder={"name","key","increment"}}w.condition.add({"limit-break","limit-check"},{parse=function(k,l)if type(k)=="string"then k={name=k}elseif type(k)~="table"then l:error("invalid value type %s",type(k))end;local H=next(l:getContext())local I=l:getContext("rule")if not k.key then k.key=I.key end;l:assert(k.key,"limiter \"key\" missing, and no default \"key\" in rule")l:assert_type(k.key,"string","invalid limiter \"key\" type")k.key=l:parseInterpolatedString(k.key)if not k.increment then if H=="limit-break"then k.increment=1 elseif H=="limit-check"then k.increment=0 end end;k.increment=l:assert(tonumber(k.increment),"invalid or empty \"increment\" value")l:assert(k.increment>=0,"\"increment\" must be >= 0")l:assert(k.name,"name missing")l:assert_type(k.name,"string","invalid \"name\" type")b(k)return k end,init=function(k,o,t)local J=t:findLimiter(k.name)if not J then error("unknown limiter "..k.name)end;k.name=nil;k.limiter=J;if k.key then a.call("string","create",k.key)end end,delete=function(k)if k.key then a.call("string","delete",k.key)end end,jsonval=function(self)local K={}for L,r in pairs(self.data)do K[L]=r end;if K.derived_key then K.derived_key=nil;K.key=nil elseif K.key then K.key=K.key.string end;K.name=K.limiter.name;K.limiter=nil;setmetatable(K,G)local M={[self.condition]=K}return M end})w.condition.add(".delay",{parse=function(k,l)l:assert_jsontype(k,"number","delay by <number> please")end})w.action.add("tag",{parse=function(k,l)l:assert_jsontype(k,"string","\"tag\" value must be a string")return l:parseInterpolatedString(k)end,init=function(k)a.call("string","create",k)end,delete=function(k)a.call("string","delete",k)end,jsonval=function(self)return{tag=self.data.string}end})w.action.add("accept",{parse=function(k,l)l:assert_type(k,"table","\"accept\" value must be an object")l:assert_table_size(k,0,"\"accept\" value must be empty")end})w.action.add("reject",{parse=function(k,l)l:assert_type(k,"table","\"reject\" value must be an object")end})w.action.add("wait",{parse=function(k,l)l:assert_jsontype(k,"number","\"wait\" value must be a number")end})return w

end)

module("ruleset", function()
local a=require"rulecomponent"local b=require"binding"or{call=function()end}local c=require"dkjson"local d;local e=function(f,g)local h={}for i,j in pairs(f)do h[i]=j end;if g then return h else return setmetatable(h,getmetatable(f))end end;local function k(l,f,m)assert(m.name,("a %s must have a name"):format(l))assert(not f[m.name],("%s \"%s\" already exists"):format(l,m.name))end;local function n(o)if type(o)=="string"then return o elseif type(o)=="table"then return o.name else return o end end;local function p(f,q)local h={}setmetatable(h,getmetatable(f))for i,j in pairs(f)do if not q[i]then h[i]=j end end;return h end;local function r(f)local s={}for i in pairs(f)do table.insert(s,i)end;table.sort(s)return s end;local t,u,v,w,x={},{},{},{},{}local y={}y.ruleset={__index=t,__jsonorder={"name","info","phases","limiters","lists","rules"}}y.phase={new=function(m)end,__index=u,__jsonval=function(self)local z={}for A,B in pairs(self.lists)do table.insert(z,B.name)end;return z end}y.rules={__jsonorder=r}y.lists={__jsonorder=r}y.limiters={__jsonorder=r}y.list={new=function(m)return setmetatable(m,y.list)end,__index=v,__jsonorder={"name","info","rules"},__jsonval=function(self)local C={}for A,D in pairs(self.rules)do table.insert(C,D.name)end;if self.info then return setmetatable({info=self.info,rules=C},getmetatable(self))else return setmetatable(C,getmetatable(self))end end}y.rule={new=function(m,E)local D=setmetatable(m,y.rule)if m["if"]then m["if"]=a.condition.new(D["if"],E)end;for A,F in pairs{"then","else"}do if m[F]then local G={}for A,j in pairs(m[F])do table.insert(G,a.action.new(j,E))end;m[F]=G end end;return m end,__index=w,__jsonorder={"name","info","key","if","if-any","if-all","then","else"},__jsonval=function(self)if#self["else"]<=1 or#self["then"]<=1 or self.key or self["if"].condition=="any"or self["if"].condition=="all"then local H=e(self)if self["if"].condition=="any"then H["if-any"]=H["if"].data;H["if"]=nil end;if self["if"].condition=="all"then H["if-all"]=H["if"].data;H["if"]=nil end;if#self["then"]==0 then H["then"]=nil end;if#self["then"]==1 then H["then"]=self["then"][1]end;if#self["else"]==0 then H["else"]=nil end;if#self["else"]==1 then H["else"]=self["else"][1]end;if self.key then self.key=self.key.string end;return H end;return self end}y.limiter={new=function(m)return setmetatable(m,y.limiter)end,__index=x,__jsonorder={"name","info","limit","interval","burst","burst-expire"},__jsonval=function(self)if self.burst then local h=e(self)h.burst=h.burst["name"]return h end;return self end}function t:findLimiter(I)return self.limiters[n(I)]end;function t:addLimiter(m,J)if m.__already_loaded_as_burst_limiter then m.__already_loaded_as_burst_limiter=nil;return nil end;k("limiter",self.limiters,m)local K=y.limiter.new(m)self.limiters[m.name]=K;if K.burst then local L=self:findLimiter(K.burst)if not L then L=self:addLimiter(J[K.burst],J)J[K.burst].__already_loaded_as_burst_limiter=true;K.burst=L end end;b.call("limiter","create",K)return K end;function t:deleteLimiter(K)assert(self.limiters[K.name]==K,"tried deleting unexpected limiter of the same name")self.limiters[K.name]=nil;b.call("limiter","delete",K)end;function t:findRule(I)return self.rules[n(I)]end;function t:addRule(m)if not m.name then m.name=self:uniqueName("rule")else k("rule",self.rules,m)end;local D=y.rule.new(m,self)self.rules[m.name]=D;b.call("rule","create",D)return D end;function t:deleteRule(D)assert(self.rules[D.name]==D,"tried deleting unexpected list of the same name")for M,B in pairs(self.lists)do for A,N in ipairs(B)do assert(N~=D,("can't delete rule \"%s\", it's used in list \"%s\""):format(D.name,M))end end;self.rules[D.name]=nil;if D["if"]then a.condition.delete(D["if"],self)end;for A,F in pairs{"then","else"}do if D[F]then local G=D[F]for A,O in pairs(G)do a.action.delete(O,self)end;D[F]={}end end;b.call("rule","delete",D)end;function t:findList(I)return self.lists[n(I)]end;function t:addList(m)if not m.name then m.name=self:uniqueName("list")else k("list",self.lists,m)end;for P,Q in ipairs(m.rules)do m.rules[P]=self:findRule(Q.name)or self:addRule(Q)end;local B=y.list.new(m)self.lists[m.name]=B;b.call("list","create",B)return B end;function t:deleteList(B)assert(self.lists[B.name]==B,"tried deleting unexpected list of the same name")for R,S in pairs(self.phases)do for A,T in ipairs(S)do assert(T~=B,("can't delete list \"%s\", it's used in phase \"%s\""):format(B.name,R))end end;self.lists[B.name]=nil;b.call("list","delete",B)end;function t:setPhaseTable(m)if self.phases then for A,S in pairs(self.phases)do b.call("phase","delete",S)end end;self.phases={}for i,j in pairs(m)do local S=setmetatable({name=i,lists={}},y.phase)for P,B in pairs(j)do S.lists[P]=self:findList(B)or self:addList(B)end;self.phases[i]=S;b.call("phase","create",S)end;return self.phases end;function t:uniqueName(o)local U={ruleset={},rule=self.rules,list=self.lists,limiter=self.limiters}local V=U[o]if V==nil then error("don't knoq how to generate unique name for "..tostring(o))end;return assert(d.uniqueName(o,V,self),"unique name can't be nil")end;function t:toJSON()local W={name=self.name,info=self.info,rules=e(self.rules),lists=e(self.lists),limiters=e(self.limiters),phases=self.phases}setmetatable(W,y.ruleset)local X={name=true}for A,Y in ipairs({"rules","lists","limiters","phases"})do local Z=W[Y]or{}for i,o in pairs(Z)do Z[i]=p(o,X)end end;return c.encode(W,{indent=true})end;function t:destroy()self:setPhaseTable({})for A,B in pairs(self.lists)do self:deleteList(B)end;for A,D in pairs(self.rules)do self:deleteRule(D)end;for A,K in pairs(self.limiters)do self:deleteLimiter(K)end;b.call("ruleset","delete",self)end;d={new=function(m)local E=setmetatable({rules=setmetatable({},y.rules),lists=setmetatable({},y.lists),limiters=setmetatable({},y.limiters),phases={},name=m and m.name or nil},y.ruleset)if not E.name then E.name=E:uniqueName("ruleset")end;if m then for A,j in pairs(m.limiters)do E:addLimiter(j,m.limiters)end;for A,j in pairs(m.rules)do E:addRule(j)end;for A,j in pairs(m.lists)do E:addList(j)end;E:setPhaseTable(m.phases)end;b.call("ruleset","create",E)return E end,newLimiter=y.limiter.new,newPhase=y.phase.new,newList=y.list.new,newRule=y.rule.new,uniqueName=function(_,V,E)error("uniqueName must be configured outside the Ruleset module")end}return d

end)


return main()
