// don't edit this please, it was auto-generated by hsss
// https://github.com/slact/hsss

typedef struct {
  char *name;
  char *script;
} wfx_lua_script_t;

typedef struct {
  //lua environs initializer
  wfx_lua_script_t init;

} wfx_lua_scripts_t;

wfx_lua_scripts_t wfx_lua_scripts = {
  {"init", 
   "--lua environs initializer\n"
   "return function(package_loader, initializers)\n"
   "  package.path = \"\"\n"
   "  package.cpath= \"\"\n"
   "  setmetatable(package.preload, {__index = function(self, name)\n"
   "    local pkg = package_loader(name)\n"
   "    local loader\n"
   "    if pkg then\n"
   "      loader = function()\n"
   "        return pkg\n"
   "      end\n"
   "      self[name]=loader\n"
   "    end\n"
   "    return loader\n"
   "  end})\n"
   "  \n"
   "  local mm = require \"mm\"\n"
   "  local Parser = require \"parser\"\n"
   "  local Ruleset = require \"ruleset\"\n"
   "  local Binding = require \"binding\"\n"
   "\n"
   "  --import c bindings\n"
   "  if initializers then\n"
   "    for k,v in pairs(initializers) do\n"
   "      assert(type(v) == \"table\")\n"
   "      mm(v)\n"
   "      Binding.set(k, v)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local p = Parser.new()\n"
   "  \n"
   "  local parsed = p:parseFile(\"/home/leop/sandbox/wafflex/src/lua/nginx/ruleset1.json\")\n"
   "\n"
   "  mm(parsed)\n"
   "\n"
   "  local rs = Ruleset.new(parsed)\n"
   "\n"
   "  mm(rs)\n"
   "end\n"}
};

// don't edit this please, it was auto-generated by hsss
// https://github.com/slact/hsss

typedef struct {
  char *name;
  char *script;
} wfx_module_lua_script_t;

typedef struct {
  wfx_module_lua_script_t binding;

  //David Kolf's JSON module for Lua 5.1/5.2
  //small hack to generate object and array metatables by slact
  wfx_module_lua_script_t dkjson;

  //mm, a pretty printer
  wfx_module_lua_script_t mm;

  wfx_module_lua_script_t parser;

  wfx_module_lua_script_t rule;

  wfx_module_lua_script_t ruleset;

} wfx_module_lua_scripts_t;

wfx_module_lua_scripts_t wfx_module_lua_scripts = {
  {"binding", 
   "local mm = require \"mm\"\n"
   "local binds = {}\n"
   "\n"
   "local calls = {\n"
   "  create = function(callback, self, ...)\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'self' to be table, got %s)\"):format(type(self))\n"
   "    end\n"
   "    local ref = callback(self, ...)\n"
   "    --[[\n"
   "    if type(ref) ~= \"userdata\" then\n"
   "      return nil, (\"expected userdata, got %s\"):format(type(ref))\n"
   "    end\n"
   "    self.__binding = ref\n"
   "    ]]\n"
   "    return true\n"
   "  end,\n"
   "  update = function(callback, self, update_name, update_data)\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'self' to be table, got %s)\"):format(type(self))\n"
   "    end\n"
   "    if type(update_name) ~= \"string\" then\n"
   "      return nil, (\"expected 'update_name' to be string, got %s)\"):format(type(self))\n"
   "    end\n"
   "    local ref = callback(self, update_name, update_data, self.ruleset)\n"
   "    if type(ref) == \"userdata\" then\n"
   "      self.__binding = ref\n"
   "    end\n"
   "    return true\n"
   "  end,\n"
   "  replace = function(callback, self, replacee)\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'self'(replacement) to be table, got %s)\"):format(type(self))\n"
   "    end\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'replacee' to be table, got %s)\"):format(type(replacee))\n"
   "    end\n"
   "    if self.ruleset ~= replacee.ruleset then\n"
   "      return nil, \"replacement ruleset differs from replacee ruleset\"\n"
   "    end\n"
   "    local ref = callback(self, replacee, self.ruleset)\n"
   "    if type(ref) == \"userdata\" then\n"
   "      self.__binding = ref\n"
   "    end\n"
   "    return true\n"
   "  end,\n"
   "  delete = function(callback, self)\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'self' to be table, got %s)\"):format(type(self))\n"
   "    end\n"
   "    callback(self, replacee, self.ruleset)\n"
   "    return true\n"
   "  end\n"
   "}\n"
   "\n"
   "return {\n"
   "  bindings = binds,\n"
   "  set = function(name, create, replace, update, delete)\n"
   "    if type(create) == \"table\" and replace == nil and update == nil and delete == nil then\n"
   "      local tbl = create\n"
   "      create = tbl.create\n"
   "      replace = tbl.replace\n"
   "      update = tbl.update\n"
   "      delete = tbl.delete\n"
   "    end\n"
   "    \n"
   "    local callbacks = {\n"
   "      create = create,\n"
   "      replace = replace,\n"
   "      update = update,\n"
   "      delete = delete\n"
   "    }\n"
   "    \n"
   "    for n,f in pairs(callbacks) do\n"
   "      assert(type(f) == \"function\" or type(f) == nil, (\"\\\"%s\\\" binding \\\"%s\\\" callback must be function or nil, was %s\"):format(name, n, type(f)))\n"
   "    end\n"
   "    \n"
   "    binds[name]=callbacks\n"
   "  end,\n"
   "  call = function(binding_name, call_name, ...)\n"
   "    local callbacks = binds[binding_name]\n"
   "    if not callbacks then return end\n"
   "    local thiscall = calls[call_name]\n"
   "    if not thiscall then\n"
   "      error((\"unknown binding call \\\"%s\\\"\"):format(call_name))\n"
   "    end\n"
   "    local ok, err = thiscall(callbacks[call_name], ...)\n"
   "    if not ok then\n"
   "      error((\"Binding \\\"%s\\\" call \\\"%s\\\" error: %s\"):format(binding_name, call_name, err))\n"
   "    end\n"
   "    return ok\n"
   "  end\n"
   "}\n"},

  {"dkjson", 
   "--David Kolf's JSON module for Lua 5.1/5.2\n"
   "--small hack to generate object and array metatables by slact\n"
   "\n"
   "local always_try_using_lpeg = false\n"
   "local register_global_module_table = false\n"
   "local global_module_name = 'json'\n"
   "\n"
   "--[==[\n"
   "\n"
   "David Kolf's JSON module for Lua 5.1/5.2\n"
   "\n"
   "Version 2.5\n"
   "\n"
   "\n"
   "For the documentation see the corresponding readme.txt or visit\n"
   "<http://dkolf.de/src/dkjson-lua.fsl/>.\n"
   "\n"
   "You can contact the author by sending an e-mail to 'david' at the\n"
   "domain 'dkolf.de'.\n"
   "\n"
   "\n"
   "Copyright (C) 2010-2013 David Heiko Kolf\n"
   "\n"
   "Permission is hereby granted, free of charge, to any person obtaining\n"
   "a copy of this software and associated documentation files (the\n"
   "\"Software\"), to deal in the Software without restriction, including\n"
   "without limitation the rights to use, copy, modify, merge, publish,\n"
   "distribute, sublicense, and/or sell copies of the Software, and to\n"
   "permit persons to whom the Software is furnished to do so, subject to\n"
   "the following conditions:\n"
   "\n"
   "The above copyright notice and this permission notice shall be\n"
   "included in all copies or substantial portions of the Software.\n"
   "\n"
   "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n"
   "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
   "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
   "NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n"
   "BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n"
   "ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n"
   "CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
   "SOFTWARE.\n"
   "\n"
   "--]==]\n"
   "\n"
   "-- global dependencies:\n"
   "local pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset =\n"
   "      pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset\n"
   "local error, require, pcall, select = error, require, pcall, select\n"
   "local floor, huge = math.floor, math.huge\n"
   "local strrep, gsub, strsub, strbyte, strchar, strfind, strlen, strformat =\n"
   "      string.rep, string.gsub, string.sub, string.byte, string.char,\n"
   "      string.find, string.len, string.format\n"
   "local strmatch = string.match\n"
   "local concat = table.concat\n"
   "\n"
   "local json = { version = \"dkjson 2.5\" }\n"
   "\n"
   "if register_global_module_table then\n"
   "  _G[global_module_name] = json\n"
   "end\n"
   "\n"
   "local _ENV = nil -- blocking globals in Lua 5.2\n"
   "\n"
   "pcall (function()\n"
   "  -- Enable access to blocked metatables.\n"
   "  -- Don't worry, this module doesn't change anything in them.\n"
   "  local debmeta = require \"debug\".getmetatable\n"
   "  if debmeta then getmetatable = debmeta end\n"
   "end)\n"
   "\n"
   "json.null = setmetatable ({}, {\n"
   "  __tojson = function () return \"null\" end\n"
   "})\n"
   "\n"
   "local function isarray (tbl)\n"
   "  local max, n, arraylen = 0, 0, 0\n"
   "  for k,v in pairs (tbl) do\n"
   "    if k == 'n' and type(v) == 'number' then\n"
   "      arraylen = v\n"
   "      if v > max then\n"
   "        max = v\n"
   "      end\n"
   "    else\n"
   "      if type(k) ~= 'number' or k < 1 or floor(k) ~= k then\n"
   "        return false\n"
   "      end\n"
   "      if k > max then\n"
   "        max = k\n"
   "      end\n"
   "      n = n + 1\n"
   "    end\n"
   "  end\n"
   "  if max > 10 and max > arraylen and max > n * 2 then\n"
   "    return false -- don't create an array with too many holes\n"
   "  end\n"
   "  return true, max\n"
   "end\n"
   "\n"
   "local escapecodes = {\n"
   "  [\"\\\"\"] = \"\\\\\\\"\", [\"\\\\\"] = \"\\\\\\\\\", [\"\\b\"] = \"\\\\b\", [\"\\f\"] = \"\\\\f\",\n"
   "  [\"\\n\"] = \"\\\\n\",  [\"\\r\"] = \"\\\\r\",  [\"\\t\"] = \"\\\\t\"\n"
   "}\n"
   "\n"
   "local function escapeutf8 (uchar)\n"
   "  local value = escapecodes[uchar]\n"
   "  if value then\n"
   "    return value\n"
   "  end\n"
   "  local a, b, c, d = strbyte (uchar, 1, 4)\n"
   "  a, b, c, d = a or 0, b or 0, c or 0, d or 0\n"
   "  if a <= 0x7f then\n"
   "    value = a\n"
   "  elseif 0xc0 <= a and a <= 0xdf and b >= 0x80 then\n"
   "    value = (a - 0xc0) * 0x40 + b - 0x80\n"
   "  elseif 0xe0 <= a and a <= 0xef and b >= 0x80 and c >= 0x80 then\n"
   "    value = ((a - 0xe0) * 0x40 + b - 0x80) * 0x40 + c - 0x80\n"
   "  elseif 0xf0 <= a and a <= 0xf7 and b >= 0x80 and c >= 0x80 and d >= 0x80 then\n"
   "    value = (((a - 0xf0) * 0x40 + b - 0x80) * 0x40 + c - 0x80) * 0x40 + d - 0x80\n"
   "  else\n"
   "    return \"\"\n"
   "  end\n"
   "  if value <= 0xffff then\n"
   "    return strformat (\"\\\\u%.4x\", value)\n"
   "  elseif value <= 0x10ffff then\n"
   "    -- encode as UTF-16 surrogate pair\n"
   "    value = value - 0x10000\n"
   "    local highsur, lowsur = 0xD800 + floor (value/0x400), 0xDC00 + (value % 0x400)\n"
   "    return strformat (\"\\\\u%.4x\\\\u%.4x\", highsur, lowsur)\n"
   "  else\n"
   "    return \"\"\n"
   "  end\n"
   "end\n"
   "\n"
   "local function fsub (str, pattern, repl)\n"
   "  -- gsub always builds a new string in a buffer, even when no match\n"
   "  -- exists. First using find should be more efficient when most strings\n"
   "  -- don't contain the pattern.\n"
   "  if strfind (str, pattern) then\n"
   "    return gsub (str, pattern, repl)\n"
   "  else\n"
   "    return str\n"
   "  end\n"
   "end\n"
   "\n"
   "local function quotestring (value)\n"
   "  -- based on the regexp \"escapable\" in https://github.com/douglascrockford/JSON-js\n"
   "  value = fsub (value, \"[%z\\1-\\31\\\"\\\\\\127]\", escapeutf8)\n"
   "  if strfind (value, \"[\\194\\216\\220\\225\\226\\239]\") then\n"
   "    value = fsub (value, \"\\194[\\128-\\159\\173]\", escapeutf8)\n"
   "    value = fsub (value, \"\\216[\\128-\\132]\", escapeutf8)\n"
   "    value = fsub (value, \"\\220\\143\", escapeutf8)\n"
   "    value = fsub (value, \"\\225\\158[\\180\\181]\", escapeutf8)\n"
   "    value = fsub (value, \"\\226\\128[\\140-\\143\\168-\\175]\", escapeutf8)\n"
   "    value = fsub (value, \"\\226\\129[\\160-\\175]\", escapeutf8)\n"
   "    value = fsub (value, \"\\239\\187\\191\", escapeutf8)\n"
   "    value = fsub (value, \"\\239\\191[\\176-\\191]\", escapeutf8)\n"
   "  end\n"
   "  return \"\\\"\" .. value .. \"\\\"\"\n"
   "end\n"
   "json.quotestring = quotestring\n"
   "\n"
   "local function replace(str, o, n)\n"
   "  local i, j = strfind (str, o, 1, true)\n"
   "  if i then\n"
   "    return strsub(str, 1, i-1) .. n .. strsub(str, j+1, -1)\n"
   "  else\n"
   "    return str\n"
   "  end\n"
   "end\n"
   "\n"
   "-- locale independent num2str and str2num functions\n"
   "local decpoint, numfilter\n"
   "\n"
   "local function updatedecpoint ()\n"
   "  decpoint = strmatch(tostring(0.5), \"([^05+])\")\n"
   "  -- build a filter that can be used to remove group separators\n"
   "  numfilter = \"[^0-9%-%+eE\" .. gsub(decpoint, \"[%^%$%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\") .. \"]+\"\n"
   "end\n"
   "\n"
   "updatedecpoint()\n"
   "\n"
   "local function num2str (num)\n"
   "  return replace(fsub(tostring(num), numfilter, \"\"), decpoint, \".\")\n"
   "end\n"
   "\n"
   "local function str2num (str)\n"
   "  local num = tonumber(replace(str, \".\", decpoint))\n"
   "  if not num then\n"
   "    updatedecpoint()\n"
   "    num = tonumber(replace(str, \".\", decpoint))\n"
   "  end\n"
   "  return num\n"
   "end\n"
   "\n"
   "local function addnewline2 (level, buffer, buflen)\n"
   "  buffer[buflen+1] = \"\\n\"\n"
   "  buffer[buflen+2] = strrep (\"  \", level)\n"
   "  buflen = buflen + 2\n"
   "  return buflen\n"
   "end\n"
   "\n"
   "function json.addnewline (state)\n"
   "  if state.indent then\n"
   "    state.bufferlen = addnewline2 (state.level or 0,\n"
   "                           state.buffer, state.bufferlen or #(state.buffer))\n"
   "  end\n"
   "end\n"
   "\n"
   "local encode2 -- forward declaration\n"
   "\n"
   "local function addpair (key, value, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "  local kt = type (key)\n"
   "  if kt ~= 'string' and kt ~= 'number' then\n"
   "    return nil, \"type '\" .. kt .. \"' is not supported as a key by JSON.\"\n"
   "  end\n"
   "  if prev then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = \",\"\n"
   "  end\n"
   "  if indent then\n"
   "    buflen = addnewline2 (level, buffer, buflen)\n"
   "  end\n"
   "  buffer[buflen+1] = quotestring (key)\n"
   "  buffer[buflen+2] = \":\"\n"
   "  return encode2 (value, indent, level, buffer, buflen + 2, tables, globalorder, state)\n"
   "end\n"
   "\n"
   "local function appendcustom(res, buffer, state)\n"
   "  local buflen = state.bufferlen\n"
   "  if type (res) == 'string' then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = res\n"
   "  end\n"
   "  return buflen\n"
   "end\n"
   "\n"
   "local function exception(reason, value, state, buffer, buflen, defaultmessage)\n"
   "  defaultmessage = defaultmessage or reason\n"
   "  local handler = state.exception\n"
   "  if not handler then\n"
   "    return nil, defaultmessage\n"
   "  else\n"
   "    state.bufferlen = buflen\n"
   "    local ret, msg = handler (reason, value, state, defaultmessage)\n"
   "    if not ret then return nil, msg or defaultmessage end\n"
   "    return appendcustom(ret, buffer, state)\n"
   "  end\n"
   "end\n"
   "\n"
   "function json.encodeexception(reason, value, state, defaultmessage)\n"
   "  return quotestring(\"<\" .. defaultmessage .. \">\")\n"
   "end\n"
   "\n"
   "encode2 = function (value, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "  local valtype = type (value)\n"
   "  local valmeta = getmetatable (value)\n"
   "  valmeta = type (valmeta) == 'table' and valmeta -- only tables\n"
   "  local valtojson = valmeta and valmeta.__tojson\n"
   "  if valtojson then\n"
   "    if tables[value] then\n"
   "      return exception('reference cycle', value, state, buffer, buflen)\n"
   "    end\n"
   "    tables[value] = true\n"
   "    state.bufferlen = buflen\n"
   "    local ret, msg = valtojson (value, state)\n"
   "    if not ret then return exception('custom encoder failed', value, state, buffer, buflen, msg) end\n"
   "    tables[value] = nil\n"
   "    buflen = appendcustom(ret, buffer, state)\n"
   "  elseif value == nil then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = \"null\"\n"
   "  elseif valtype == 'number' then\n"
   "    local s\n"
   "    if value ~= value or value >= huge or -value >= huge then\n"
   "      -- This is the behaviour of the original JSON implementation.\n"
   "      s = \"null\"\n"
   "    else\n"
   "      s = num2str (value)\n"
   "    end\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = s\n"
   "  elseif valtype == 'boolean' then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = value and \"true\" or \"false\"\n"
   "  elseif valtype == 'string' then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = quotestring (value)\n"
   "  elseif valtype == 'table' then\n"
   "    if tables[value] then\n"
   "      return exception('reference cycle', value, state, buffer, buflen)\n"
   "    end\n"
   "    tables[value] = true\n"
   "    level = level + 1\n"
   "    local isa, n = isarray (value)\n"
   "    if n == 0 and valmeta and valmeta.__jsontype == 'object' then\n"
   "      isa = false\n"
   "    end\n"
   "    local msg\n"
   "    if isa then -- JSON array\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"[\"\n"
   "      for i = 1, n do\n"
   "        buflen, msg = encode2 (value[i], indent, level, buffer, buflen, tables, globalorder, state)\n"
   "        if not buflen then return nil, msg end\n"
   "        if i < n then\n"
   "          buflen = buflen + 1\n"
   "          buffer[buflen] = \",\"\n"
   "        end\n"
   "      end\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"]\"\n"
   "    else -- JSON object\n"
   "      local prev = false\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"{\"\n"
   "      local order = valmeta and valmeta.__jsonorder or globalorder\n"
   "      if order then\n"
   "        local used = {}\n"
   "        n = #order\n"
   "        for i = 1, n do\n"
   "          local k = order[i]\n"
   "          local v = value[k]\n"
   "          if v then\n"
   "            used[k] = true\n"
   "            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "            prev = true -- add a seperator before the next element\n"
   "          end\n"
   "        end\n"
   "        for k,v in pairs (value) do\n"
   "          if not used[k] then\n"
   "            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "            if not buflen then return nil, msg end\n"
   "            prev = true -- add a seperator before the next element\n"
   "          end\n"
   "        end\n"
   "      else -- unordered\n"
   "        for k,v in pairs (value) do\n"
   "          buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "          if not buflen then return nil, msg end\n"
   "          prev = true -- add a seperator before the next element\n"
   "        end\n"
   "      end\n"
   "      if indent then\n"
   "        buflen = addnewline2 (level - 1, buffer, buflen)\n"
   "      end\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"}\"\n"
   "    end\n"
   "    tables[value] = nil\n"
   "  else\n"
   "    return exception ('unsupported type', value, state, buffer, buflen,\n"
   "      \"type '\" .. valtype .. \"' is not supported by JSON.\")\n"
   "  end\n"
   "  return buflen\n"
   "end\n"
   "\n"
   "function json.encode (value, state)\n"
   "  state = state or {}\n"
   "  local oldbuffer = state.buffer\n"
   "  local buffer = oldbuffer or {}\n"
   "  state.buffer = buffer\n"
   "  updatedecpoint()\n"
   "  local ret, msg = encode2 (value, state.indent, state.level or 0,\n"
   "                   buffer, state.bufferlen or 0, state.tables or {}, state.keyorder, state)\n"
   "  if not ret then\n"
   "    error (msg, 2)\n"
   "  elseif oldbuffer == buffer then\n"
   "    state.bufferlen = ret\n"
   "    return true\n"
   "  else\n"
   "    state.bufferlen = nil\n"
   "    state.buffer = nil\n"
   "    return concat (buffer)\n"
   "  end\n"
   "end\n"
   "\n"
   "local function loc(str, where)\n"
   "  local line, pos, linepos = 1, 1, 0\n"
   "  while true do\n"
   "    pos = strfind (str, \"\\n\", pos, true)\n"
   "    if pos and pos < where then\n"
   "      line = line + 1\n"
   "      linepos = pos\n"
   "      pos = pos + 1\n"
   "    else\n"
   "      break\n"
   "    end\n"
   "  end\n"
   "  return \"line \" .. line .. \", column \" .. (where - linepos)\n"
   "end\n"
   "\n"
   "local function unterminated (str, what, where)\n"
   "  return nil, strlen (str) + 1, \"unterminated \" .. what .. \" at \" .. loc (str, where)\n"
   "end\n"
   "\n"
   "local function scanwhite (str, pos)\n"
   "  while true do\n"
   "    pos = strfind (str, \"%S\", pos)\n"
   "    if not pos then return nil end\n"
   "    local sub2 = strsub (str, pos, pos + 1)\n"
   "    if sub2 == \"\\239\\187\" and strsub (str, pos + 2, pos + 2) == \"\\191\" then\n"
   "      -- UTF-8 Byte Order Mark\n"
   "      pos = pos + 3\n"
   "    elseif sub2 == \"//\" then\n"
   "      pos = strfind (str, \"[\\n\\r]\", pos + 2)\n"
   "      if not pos then return nil end\n"
   "    elseif sub2 == \"/*\" then\n"
   "      pos = strfind (str, \"*/\", pos + 2)\n"
   "      if not pos then return nil end\n"
   "      pos = pos + 2\n"
   "    else\n"
   "      return pos\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "local escapechars = {\n"
   "  [\"\\\"\"] = \"\\\"\", [\"\\\\\"] = \"\\\\\", [\"/\"] = \"/\", [\"b\"] = \"\\b\", [\"f\"] = \"\\f\",\n"
   "  [\"n\"] = \"\\n\", [\"r\"] = \"\\r\", [\"t\"] = \"\\t\"\n"
   "}\n"
   "\n"
   "local function unichar (value)\n"
   "  if value < 0 then\n"
   "    return nil\n"
   "  elseif value <= 0x007f then\n"
   "    return strchar (value)\n"
   "  elseif value <= 0x07ff then\n"
   "    return strchar (0xc0 + floor(value/0x40),\n"
   "                    0x80 + (floor(value) % 0x40))\n"
   "  elseif value <= 0xffff then\n"
   "    return strchar (0xe0 + floor(value/0x1000),\n"
   "                    0x80 + (floor(value/0x40) % 0x40),\n"
   "                    0x80 + (floor(value) % 0x40))\n"
   "  elseif value <= 0x10ffff then\n"
   "    return strchar (0xf0 + floor(value/0x40000),\n"
   "                    0x80 + (floor(value/0x1000) % 0x40),\n"
   "                    0x80 + (floor(value/0x40) % 0x40),\n"
   "                    0x80 + (floor(value) % 0x40))\n"
   "  else\n"
   "    return nil\n"
   "  end\n"
   "end\n"
   "\n"
   "local function scanstring (str, pos)\n"
   "  local lastpos = pos + 1\n"
   "  local buffer, n = {}, 0\n"
   "  while true do\n"
   "    local nextpos = strfind (str, \"[\\\"\\\\]\", lastpos)\n"
   "    if not nextpos then\n"
   "      return unterminated (str, \"string\", pos)\n"
   "    end\n"
   "    if nextpos > lastpos then\n"
   "      n = n + 1\n"
   "      buffer[n] = strsub (str, lastpos, nextpos - 1)\n"
   "    end\n"
   "    if strsub (str, nextpos, nextpos) == \"\\\"\" then\n"
   "      lastpos = nextpos + 1\n"
   "      break\n"
   "    else\n"
   "      local escchar = strsub (str, nextpos + 1, nextpos + 1)\n"
   "      local value\n"
   "      if escchar == \"u\" then\n"
   "        value = tonumber (strsub (str, nextpos + 2, nextpos + 5), 16)\n"
   "        if value then\n"
   "          local value2\n"
   "          if 0xD800 <= value and value <= 0xDBff then\n"
   "            -- we have the high surrogate of UTF-16. Check if there is a\n"
   "            -- low surrogate escaped nearby to combine them.\n"
   "            if strsub (str, nextpos + 6, nextpos + 7) == \"\\\\u\" then\n"
   "              value2 = tonumber (strsub (str, nextpos + 8, nextpos + 11), 16)\n"
   "              if value2 and 0xDC00 <= value2 and value2 <= 0xDFFF then\n"
   "                value = (value - 0xD800)  * 0x400 + (value2 - 0xDC00) + 0x10000\n"
   "              else\n"
   "                value2 = nil -- in case it was out of range for a low surrogate\n"
   "              end\n"
   "            end\n"
   "          end\n"
   "          value = value and unichar (value)\n"
   "          if value then\n"
   "            if value2 then\n"
   "              lastpos = nextpos + 12\n"
   "            else\n"
   "              lastpos = nextpos + 6\n"
   "            end\n"
   "          end\n"
   "        end\n"
   "      end\n"
   "      if not value then\n"
   "        value = escapechars[escchar] or escchar\n"
   "        lastpos = nextpos + 2\n"
   "      end\n"
   "      n = n + 1\n"
   "      buffer[n] = value\n"
   "    end\n"
   "  end\n"
   "  if n == 1 then\n"
   "    return buffer[1], lastpos\n"
   "  elseif n > 1 then\n"
   "    return concat (buffer), lastpos\n"
   "  else\n"
   "    return \"\", lastpos\n"
   "  end\n"
   "end\n"
   "\n"
   "local scanvalue -- forward declaration\n"
   "\n"
   "local function set_scantable_metatable (tbl, meta, str, pos)\n"
   "  if type(meta)==\"function\" then\n"
   "    meta = meta(str, pos)\n"
   "    if type(meta) ~= \"table\" then\n"
   "      return tbl\n"
   "    end\n"
   "  end\n"
   "  return setmetatable(tbl, meta)\n"
   "end\n"
   "\n"
   "local function scantable (what, closechar, str, startpos, nullval, objectmeta, arraymeta)\n"
   "  local len = strlen (str)\n"
   "  local tbl, n = {}, 0\n"
   "  local pos = startpos + 1\n"
   "  if what == 'object' then\n"
   "    set_scantable_metatable(tbl, objectmeta, str, startpos)\n"
   "  else\n"
   "    set_scantable_metatable(tbl, arraymeta, str, startpos)\n"
   "  end\n"
   "  while true do\n"
   "    pos = scanwhite (str, pos)\n"
   "    if not pos then return unterminated (str, what, startpos) end\n"
   "    local char = strsub (str, pos, pos)\n"
   "    if char == closechar then\n"
   "      return tbl, pos + 1\n"
   "    end\n"
   "    local val1, err\n"
   "    val1, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "    if err then return nil, pos, err end\n"
   "    pos = scanwhite (str, pos)\n"
   "    if not pos then return unterminated (str, what, startpos) end\n"
   "    char = strsub (str, pos, pos)\n"
   "    if char == \":\" then\n"
   "      if val1 == nil then\n"
   "        return nil, pos, \"cannot use nil as table index (at \" .. loc (str, pos) .. \")\"\n"
   "      end\n"
   "      pos = scanwhite (str, pos + 1)\n"
   "      if not pos then return unterminated (str, what, startpos) end\n"
   "      local val2\n"
   "      val2, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "      if err then return nil, pos, err end\n"
   "      tbl[val1] = val2\n"
   "      pos = scanwhite (str, pos)\n"
   "      if not pos then return unterminated (str, what, startpos) end\n"
   "      char = strsub (str, pos, pos)\n"
   "    else\n"
   "      n = n + 1\n"
   "      tbl[n] = val1\n"
   "    end\n"
   "    if char == \",\" then\n"
   "      pos = pos + 1\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "scanvalue = function (str, pos, nullval, objectmeta, arraymeta)\n"
   "  pos = pos or 1\n"
   "  pos = scanwhite (str, pos)\n"
   "  if not pos then\n"
   "    return nil, strlen (str) + 1, \"no valid JSON value (reached the end)\"\n"
   "  end\n"
   "  local char = strsub (str, pos, pos)\n"
   "  if char == \"{\" then\n"
   "    return scantable ('object', \"}\", str, pos, nullval, objectmeta, arraymeta)\n"
   "  elseif char == \"[\" then\n"
   "    return scantable ('array', \"]\", str, pos, nullval, objectmeta, arraymeta)\n"
   "  elseif char == \"\\\"\" then\n"
   "    return scanstring (str, pos)\n"
   "  else\n"
   "    local pstart, pend = strfind (str, \"^%-?[%d%.]+[eE]?[%+%-]?%d*\", pos)\n"
   "    if pstart then\n"
   "      local number = str2num (strsub (str, pstart, pend))\n"
   "      if number then\n"
   "        return number, pend + 1\n"
   "      end\n"
   "    end\n"
   "    pstart, pend = strfind (str, \"^%a%w*\", pos)\n"
   "    if pstart then\n"
   "      local name = strsub (str, pstart, pend)\n"
   "      if name == \"true\" then\n"
   "        return true, pend + 1\n"
   "      elseif name == \"false\" then\n"
   "        return false, pend + 1\n"
   "      elseif name == \"null\" then\n"
   "        return nullval, pend + 1\n"
   "      end\n"
   "    end\n"
   "    return nil, pos, \"no valid JSON value at \" .. loc (str, pos)\n"
   "  end\n"
   "end\n"
   "\n"
   "local function optionalmetatables(...)\n"
   "  if select(\"#\", ...) > 0 then\n"
   "    return ...\n"
   "  else\n"
   "    return {__jsontype = 'object'}, {__jsontype = 'array'}\n"
   "  end\n"
   "end\n"
   "\n"
   "function json.decode (str, pos, nullval, ...)\n"
   "  local objectmeta, arraymeta = optionalmetatables(...)\n"
   "  return scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "end\n"
   "\n"
   "function json.use_lpeg ()\n"
   "  local g = require (\"lpeg\")\n"
   "\n"
   "  if g.version() == \"0.11\" then\n"
   "    error \"due to a bug in LPeg 0.11, it cannot be used for JSON matching\"\n"
   "  end\n"
   "\n"
   "  local pegmatch = g.match\n"
   "  local P, S, R = g.P, g.S, g.R\n"
   "\n"
   "  local function ErrorCall (str, pos, msg, state)\n"
   "    if not state.msg then\n"
   "      state.msg = msg .. \" at \" .. loc (str, pos)\n"
   "      state.pos = pos\n"
   "    end\n"
   "    return false\n"
   "  end\n"
   "\n"
   "  local function Err (msg)\n"
   "    return g.Cmt (g.Cc (msg) * g.Carg (2), ErrorCall)\n"
   "  end\n"
   "\n"
   "  local SingleLineComment = P\"//\" * (1 - S\"\\n\\r\")^0\n"
   "  local MultiLineComment = P\"/*\" * (1 - P\"*/\")^0 * P\"*/\"\n"
   "  local Space = (S\" \\n\\r\\t\" + P\"\\239\\187\\191\" + SingleLineComment + MultiLineComment)^0\n"
   "\n"
   "  local PlainChar = 1 - S\"\\\"\\\\\\n\\r\"\n"
   "  local EscapeSequence = (P\"\\\\\" * g.C (S\"\\\"\\\\/bfnrt\" + Err \"unsupported escape sequence\")) / escapechars\n"
   "  local HexDigit = R(\"09\", \"af\", \"AF\")\n"
   "  local function UTF16Surrogate (match, pos, high, low)\n"
   "    high, low = tonumber (high, 16), tonumber (low, 16)\n"
   "    if 0xD800 <= high and high <= 0xDBff and 0xDC00 <= low and low <= 0xDFFF then\n"
   "      return true, unichar ((high - 0xD800)  * 0x400 + (low - 0xDC00) + 0x10000)\n"
   "    else\n"
   "      return false\n"
   "    end\n"
   "  end\n"
   "  local function UTF16BMP (hex)\n"
   "    return unichar (tonumber (hex, 16))\n"
   "  end\n"
   "  local U16Sequence = (P\"\\\\u\" * g.C (HexDigit * HexDigit * HexDigit * HexDigit))\n"
   "  local UnicodeEscape = g.Cmt (U16Sequence * U16Sequence, UTF16Surrogate) + U16Sequence/UTF16BMP\n"
   "  local Char = UnicodeEscape + EscapeSequence + PlainChar\n"
   "  local String = P\"\\\"\" * g.Cs (Char ^ 0) * (P\"\\\"\" + Err \"unterminated string\")\n"
   "  local Integer = P\"-\"^(-1) * (P\"0\" + (R\"19\" * R\"09\"^0))\n"
   "  local Fractal = P\".\" * R\"09\"^0\n"
   "  local Exponent = (S\"eE\") * (S\"+-\")^(-1) * R\"09\"^1\n"
   "  local Number = (Integer * Fractal^(-1) * Exponent^(-1))/str2num\n"
   "  local Constant = P\"true\" * g.Cc (true) + P\"false\" * g.Cc (false) + P\"null\" * g.Carg (1)\n"
   "  local SimpleValue = Number + String + Constant\n"
   "  local ArrayContent, ObjectContent\n"
   "\n"
   "  -- The functions parsearray and parseobject parse only a single value/pair\n"
   "  -- at a time and store them directly to avoid hitting the LPeg limits.\n"
   "  local function parsearray (str, pos, nullval, state)\n"
   "    local obj, cont\n"
   "    local npos\n"
   "    local t, nt = {}, 0\n"
   "    repeat\n"
   "      obj, cont, npos = pegmatch (ArrayContent, str, pos, nullval, state)\n"
   "      if not npos then break end\n"
   "      pos = npos\n"
   "      nt = nt + 1\n"
   "      t[nt] = obj\n"
   "    until cont == 'last'\n"
   "    return pos, setmetatable (t, state.arraymeta)\n"
   "  end\n"
   "\n"
   "  local function parseobject (str, pos, nullval, state)\n"
   "    local obj, key, cont\n"
   "    local npos\n"
   "    local t = {}\n"
   "    repeat\n"
   "      key, obj, cont, npos = pegmatch (ObjectContent, str, pos, nullval, state)\n"
   "      if not npos then break end\n"
   "      pos = npos\n"
   "      t[key] = obj\n"
   "    until cont == 'last'\n"
   "    return pos, setmetatable (t, state.objectmeta)\n"
   "  end\n"
   "\n"
   "  local Array = P\"[\" * g.Cmt (g.Carg(1) * g.Carg(2), parsearray) * Space * (P\"]\" + Err \"']' expected\")\n"
   "  local Object = P\"{\" * g.Cmt (g.Carg(1) * g.Carg(2), parseobject) * Space * (P\"}\" + Err \"'}' expected\")\n"
   "  local Value = Space * (Array + Object + SimpleValue)\n"
   "  local ExpectedValue = Value + Space * Err \"value expected\"\n"
   "  ArrayContent = Value * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
   "  local Pair = g.Cg (Space * String * Space * (P\":\" + Err \"colon expected\") * ExpectedValue)\n"
   "  ObjectContent = Pair * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
   "  local DecodeValue = ExpectedValue * g.Cp ()\n"
   "\n"
   "  function json.decode (str, pos, nullval, ...)\n"
   "    local state = {}\n"
   "    state.objectmeta, state.arraymeta = optionalmetatables(...)\n"
   "    local obj, retpos = pegmatch (DecodeValue, str, pos, nullval, state)\n"
   "    if state.msg then\n"
   "      return nil, state.pos, state.msg\n"
   "    else\n"
   "      return obj, retpos\n"
   "    end\n"
   "  end\n"
   "\n"
   "  -- use this function only once:\n"
   "  json.use_lpeg = function () return json end\n"
   "\n"
   "  json.using_lpeg = true\n"
   "\n"
   "  return json -- so you can get the module using json = require \"dkjson\".use_lpeg()\n"
   "end\n"
   "\n"
   "if always_try_using_lpeg then\n"
   "  pcall (json.use_lpeg)\n"
   "end\n"
   "\n"
   "return json\n"
   "\n"},

  {"mm", 
   "--mm, a pretty printer\n"
   "\n"
   "-- Terminal color (and formatting) codes.\n"
   "local C = {\n"
   "  e = '\\27[0m', -- reset\n"
   "\n"
   "  -- Text attributes.\n"
   "  br = '\\27[1m', -- bright\n"
   "  di = '\\27[2m', -- dim\n"
   "  it = '\\27[3m', -- italics\n"
   "  un = '\\27[4m', -- underscore\n"
   "  bl = '\\27[5m', -- blink\n"
   "  re = '\\27[7m', -- reverse\n"
   "  hi = '\\27[8m', -- hidden\n"
   "\n"
   "  -- Text colors.\n"
   "  k = '\\27[30m', -- black\n"
   "  r = '\\27[31m', -- red\n"
   "  g = '\\27[32m', -- green\n"
   "  y = '\\27[33m', -- yellow\n"
   "  b = '\\27[34m', -- blue\n"
   "  m = '\\27[35m', -- magenta\n"
   "  c = '\\27[36m', -- cyan\n"
   "  w = '\\27[37m', -- white\n"
   "\n"
   "  -- Background colors.\n"
   "  _k = '\\27[40m', -- black\n"
   "  _r = '\\27[41m', -- red\n"
   "  _g = '\\27[42m', -- green\n"
   "  _y = '\\27[43m', -- yellow\n"
   "  _b = '\\27[44m', -- blue\n"
   "  _m = '\\27[45m', -- magenta\n"
   "  _c = '\\27[46m', -- cyan\n"
   "  _w = '\\27[47m'  -- white\n"
   "}\n"
   "\n"
   "local METATABLE = { \"<metatable>\", colors = C.it .. C.y }\n"
   "local INDENT = \"   \"\n"
   "\n"
   "-- The default sequence separator.\n"
   "local SEP = \" \"\n"
   "\n"
   "-- The open and close brackets can be any piece (notably, a sequence with \n"
   "-- colors). The separator must be a plain string.\n"
   "local BOPEN, BSEP, BCLOSE = 1, 2, 3\n"
   "\n"
   "-- The default frame brackets and separator.\n"
   "local BRACKETS = {\n"
   "  { \"{\", colors = C.br },\n"
   "  \",\",\n"
   "  { \"}\", colors = C.br }\n"
   "}\n"
   "\n"
   "local STR_HALF = 30\n"
   "local MAX_STR_LEN = STR_HALF * 2\n"
   "\n"
   "-- Names to use for named references. The order is important; these are aligned \n"
   "-- with the colors in `NAME_COLORS`.\n"
   "local NAMES = {\n"
   "  \"Cherry\",\n"
   "  \"Apple\",\n"
   "  \"Lemon\",\n"
   "  \"Blueberry\",\n"
   "  \"Jam\",\n"
   "  \"Cream\",\n"
   "  \"Rhubarb\",\n"
   "  \"Lime\",\n"
   "  \"Butter\",\n"
   "  \"Grape\",\n"
   "  \"Pomegranate\",\n"
   "  \"Sugar\",\n"
   "  \"Cinnamon\",\n"
   "  \"Avocado\",\n"
   "  \"Honey\",\n"
   "}\n"
   "\n"
   "-- Colors to use for named references. Don't use black nor white.\n"
   "local NAME_COLORS = { C.r, C.g, C.y, C.b, C.m, C.c }\n"
   "\n"
   "-- Reserved Lua keywords as a convenient look-up table.\n"
   "local RESERVED = {\n"
   "  ['and'] = true,\n"
   "  ['break'] = true,\n"
   "  ['do'] = true,\n"
   "  ['else'] = true,\n"
   "  ['elseif'] = true,\n"
   "  ['end'] = true,\n"
   "  ['false'] = true,\n"
   "  ['for'] = true,\n"
   "  ['function'] = true,\n"
   "  ['goto'] = true,\n"
   "  ['if'] = true,\n"
   "  ['in'] = true,\n"
   "  ['local'] = true,\n"
   "  ['nil'] = true,\n"
   "  ['not'] = true,\n"
   "  ['or'] = true,\n"
   "  ['repeat'] = true,\n"
   "  ['return'] = true,\n"
   "  ['then'] = true,\n"
   "  ['true'] = true,\n"
   "  ['until'] = true,\n"
   "  ['while'] = true\n"
   "}\n"
   "\n"
   "\n"
   "--\n"
   "-- Namers\n"
   "--\n"
   "\n"
   "local function new_namer ()\n"
   "  local index = 1\n"
   "  local suffix = 1\n"
   "  local color_index = 1\n"
   "\n"
   "  return function ()\n"
   "    -- Pick the name.\n"
   "    local result = NAMES [index]\n"
   "    if suffix > 1 then\n"
   "      result = result .. \" \" .. tostring (suffix)\n"
   "    end\n"
   "\n"
   "    index = index + 1\n"
   "    if index > #NAMES then\n"
   "      index = 1\n"
   "      suffix = suffix + 1\n"
   "    end\n"
   "\n"
   "    -- Pick the color.\n"
   "    local color = NAME_COLORS [color_index]\n"
   "\n"
   "    color_index = color_index + 1\n"
   "    if color_index > #NAME_COLORS then\n"
   "      color_index = 1\n"
   "    end\n"
   "\n"
   "    return { result, colors = C.un .. color }\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "--\n"
   "-- Context\n"
   "--\n"
   "\n"
   "\n"
   "local function new_context ()\n"
   "  return {\n"
   "    occur = {},\n"
   "    named = {},\n"
   "    next_name = new_namer (),\n"
   "\n"
   "    prev_indent = '',\n"
   "    next_indent = INDENT,\n"
   "    line_len = 0,\n"
   "    max_width = 78,\n"
   "\n"
   "    result = ''\n"
   "  }\n"
   "end\n"
   "\n"
   "\n"
   "--\n"
   "-- Translating into pieces\n"
   "--\n"
   "\n"
   "-- Translaters take any Lua value and create pieces to represent them.\n"
   "--\n"
   "-- Some values should only be serialized once, both to prevent cycles and to \n"
   "-- prevent redundancy. Or in other cases, these values cannot be serialized \n"
   "-- (such as functions) but if they appear multiple times we want to express \n"
   "-- that they are the same.\n"
   "--\n"
   "-- When a translater encounters such a value for the first time, it is \n"
   "-- registered in the context in `occur`. The value is wrapped in a plain table \n"
   "-- with the `id` field pointing to the original value. If the value is \n"
   "-- serializable, such as a table, then the the `def` field contains the piece \n"
   "-- to display. If it is unserializable or it is not the first time this value \n"
   "-- has occurred, the `def` field is nil.\n"
   "--\n"
   "-- In the cleaning stage, these `id` fields are replaced with their names. If a \n"
   "-- `def` field is present, then a sequence is generated to define the name with \n"
   "-- the piece.\n"
   "\n"
   "local translaters = {}\n"
   "local translate, ident_friendly\n"
   "\n"
   "\n"
   "function translate (val, ctx)\n"
   "  -- Try to find a type-specific translater.\n"
   "  local by_type = translaters [type (val)]\n"
   "\n"
   "  if by_type then\n"
   "    -- If there is a type-specific translater, call it.\n"
   "    return by_type (val, ctx)\n"
   "  end\n"
   "\n"
   "  -- Otherwise perform the default translation.\n"
   "\n"
   "  -- Check whether we've already encountered this value.\n"
   "  if ctx.occur [val] then\n"
   "    -- We have; give it a name if we haven't already.\n"
   "    if not ctx.named [val] then\n"
   "      ctx.named [val] = ctx.next_name ()\n"
   "    end\n"
   "\n"
   "    -- Return the value as a reference.\n"
   "    return { id = val }\n"
   "  else\n"
   "    -- We haven't; mark it as encountered.\n"
   "    ctx.occur [val] = true\n"
   "\n"
   "    -- Return the value as a definition.\n"
   "    return { id = val, def = tostring (val) }\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "translaters ['function'] = function (val, ctx)\n"
   "  -- Check whether we've already encountered this function.\n"
   "  if ctx.occur [val] then\n"
   "    -- We have; give it a name if we haven't already.\n"
   "    if not ctx.named [val] then\n"
   "      ctx.named [val] = ctx.next_name ()\n"
   "    end\n"
   "  else\n"
   "    -- We haven't; mark it as encountered.\n"
   "    ctx.occur [val] = true\n"
   "  end\n"
   "\n"
   "  -- Return the unserialized function.\n"
   "  return { id = val }\n"
   "end\n"
   "\n"
   "\n"
   "function translaters.table (val, ctx)\n"
   "  -- Check whether we've already encountered this table.\n"
   "  if ctx.occur [val] then\n"
   "    -- We have; give it a name if we haven't already.\n"
   "    if not ctx.named [val] then\n"
   "      ctx.named [val] = ctx.next_name ()\n"
   "    end\n"
   "\n"
   "    -- Return the unserialized table.\n"
   "    return { id = val }\n"
   "  else\n"
   "    -- We haven't; mark it as encountered.\n"
   "    ctx.occur [val] = true\n"
   "\n"
   "    -- Construct the frame for this table.\n"
   "    local result = {\n"
   "      bracket = BRACKETS\n"
   "    }\n"
   "\n"
   "    -- The equals-sign between key and value.\n"
   "    local eq = { \"=\", colors = C.di }\n"
   "\n"
   "    -- Represent the metatable, if present.\n"
   "    local mt = getmetatable (val)\n"
   "    if mt then\n"
   "      -- Translate the metatable.\n"
   "      mt = translate (mt, ctx)\n"
   "      table.insert (result, { METATABLE, eq, mt })\n"
   "    end\n"
   "\n"
   "    -- Represent the contents.\n"
   "    for k, v in pairs (val) do\n"
   "      -- If it is a string key which can be represented without quotes, leave \n"
   "      -- it plain.\n"
   "      if ident_friendly (k) then\n"
   "        -- Leave the key as it is.\n"
   "        k = { k, colors = C.m }\n"
   "      else\n"
   "        -- Otherwise translate the key.\n"
   "        k = translate (k, ctx)\n"
   "      end\n"
   "\n"
   "      -- Translate the value.\n"
   "      v = translate (v, ctx)\n"
   "\n"
   "      table.insert (result, { k, eq, v })\n"
   "    end\n"
   "\n"
   "    -- Wrap the result with its id.\n"
   "    return { id = val, def = result }\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "function translaters.string (val, ctx)\n"
   "  if #val <= MAX_STR_LEN then\n"
   "    -- The string is short enough; display it all.\n"
   "    local a = string.format ('%q', val)\n"
   "    a = string.gsub (a, '\\n', 'n')\n"
   "\n"
   "    return { a, colors = C.g }\n"
   "  else\n"
   "    -- The string is too long. Only show the start and end.\n"
   "    local a = string.format ('%q', string.sub (val, 1, STR_HALF))\n"
   "    a = string.gsub (a, '\\n', 'n')\n"
   "    local b = string.format ('%q', string.sub (val, -STR_HALF))\n"
   "    b = string.gsub (b, '\\n', 'n')\n"
   "\n"
   "    return { a, { \"...\", colors = C.di }, b, colors = C.g, sep = '', tight = true }\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "function translaters.number (val, ctx)\n"
   "  return { tostring (val), colors = C.m .. C.br }\n"
   "end\n"
   "\n"
   "\n"
   "-- Check whether a value can be represented as a Lua identifier, without the \n"
   "-- need for quotes or translation.\n"
   "--\n"
   "-- If the value is not a string, this immediately returns false. Otherwise, the \n"
   "-- string must be a valid Lua name: a sequence of letters, digits, and \n"
   "-- underscores that doesn't start with a digit and isn't a reserved keyword.\n"
   "--\n"
   "-- See http://www.lua.org/manual/5.3/manual.html#3.1\n"
   "function ident_friendly (val)\n"
   "  -- The value must be a string.\n"
   "  if type (val) ~= 'string' then\n"
   "    return false\n"
   "  end\n"
   "\n"
   "  if string.find (val, '^[_%a][_%a%d]*$') then\n"
   "    -- The value is a Lua name; check if it is reserved.\n"
   "    if RESERVED [val] then\n"
   "      -- The value is a resreved keyword.\n"
   "      return false\n"
   "    else\n"
   "      -- The value is a valid name.\n"
   "      return true\n"
   "    end\n"
   "  else\n"
   "    -- The value is not a Lua name.\n"
   "    return false\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "--\n"
   "-- Cleaning pieces\n"
   "--\n"
   "\n"
   "\n"
   "local function clean (piece, ctx)\n"
   "  if type (piece) == 'table' then\n"
   "    -- Check if it's an id reference.\n"
   "    if piece.id then\n"
   "      local name = ctx.named [piece.id]\n"
   "      local def = piece.def\n"
   "\n"
   "      -- Check whether it has been given a name.\n"
   "      if name then\n"
   "        local header = {\n"
   "          \"<\", type (piece.id), \" \", name, \">\",\n"
   "          colors = C.it,\n"
   "          sep = '',\n"
   "          tight = true\n"
   "        }\n"
   "        -- Named. Check whether the reference has a definition.\n"
   "        if def then\n"
   "          -- Create a sequence defining the name to the definition.\n"
   "          return { header, { \"is\", colors = C.di }, clean (piece.def, ctx) }\n"
   "        else\n"
   "          -- Show just the name.\n"
   "          return header\n"
   "        end\n"
   "      else\n"
   "        -- No name. Check whether the reference has a definition.\n"
   "        if def then\n"
   "          -- Display the definition without any header.\n"
   "          return clean (piece.def, ctx)\n"
   "        else\n"
   "          -- Display just the type.\n"
   "          return {\n"
   "            \"<\", type (piece.id), \">\",\n"
   "            colors = C.it,\n"
   "            sep = '',\n"
   "            tight = true\n"
   "          }\n"
   "        end\n"
   "      end\n"
   "\n"
   "    -- Check if it's a frame.\n"
   "    elseif piece.bracket then\n"
   "      -- Clean each child.\n"
   "      for i, child in ipairs (piece) do\n"
   "        piece [i] = clean (child, ctx)\n"
   "      end\n"
   "      return piece\n"
   "\n"
   "    -- Otherwise it's a sequence.\n"
   "    else\n"
   "      -- Clean each child.\n"
   "      for i, child in ipairs (piece) do\n"
   "        piece [i] = clean (child, ctx)\n"
   "      end\n"
   "      return piece\n"
   "    end\n"
   "  else\n"
   "    -- It's a plain value, not a table; no cleaning is needed.\n"
   "    return piece\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "--\n"
   "-- Displaying pieces\n"
   "--\n"
   "\n"
   "\n"
   "-- Pieces are either frames (with brackets), sequences (no brackets), or \n"
   "-- strings.\n"
   "\n"
   "-- Frames are displayed either short-form as { a = 1 } or long-form as\n"
   "-- {\n"
   "--   a = 1\n"
   "-- }.\n"
   "\n"
   "\n"
   "-- Declare all the local functions first, so they can refer to each other.\n"
   "local min_len, display, display_frame, display_sequence, display_string,\n"
   "      display_frame_short, display_frame_long, newline, newline_no_indent, \n"
   "      write, write_nolength, space_here, space_newline\n"
   "\n"
   "\n"
   "-- Dispatch based on the piece's type.\n"
   "function display (piece, ctx)\n"
   "  if type (piece) == 'string' then\n"
   "    -- String.\n"
   "    return display_string (piece, ctx)\n"
   "  elseif piece.bracket then\n"
   "    -- Frame.\n"
   "    return display_frame (piece, ctx)\n"
   "  else\n"
   "    -- Sequence.\n"
   "    return display_sequence (piece, ctx)\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "-- Display a frame.\n"
   "function display_frame (frame, ctx)\n"
   "  if #frame == 0 then\n"
   "    -- If the frame is empty, just display the brackets.\n"
   "    local str = {\n"
   "      frame.bracket [BOPEN], frame.bracket [BCLOSE],\n"
   "      sep = '',\n"
   "      tight = true\n"
   "    }\n"
   "    return display (str, ctx)\n"
   "  end\n"
   "\n"
   "  local ml = min_len (frame)\n"
   "\n"
   "  -- Try to fit the frame short-form on this line.\n"
   "  if ml <= space_here (ctx) then\n"
   "    return display_frame_short (frame, ctx)\n"
   "\n"
   "  -- Otherwise try to fit it short-form on the next line.\n"
   "  elseif ml <= space_newline (ctx) then\n"
   "    newline (ctx)\n"
   "    return display_frame_short (frame, ctx)\n"
   "\n"
   "  -- Otherwise display it long-form.\n"
   "  else\n"
   "    return display_frame_long (frame, ctx)\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "function display_frame_short (frame, ctx)\n"
   "  -- Short-form frames never wrap onto new lines, so we don't need to do any \n"
   "  -- length checking (it's already been done for us).\n"
   "\n"
   "  -- Write the open bracket.\n"
   "  display (frame.bracket [BOPEN], ctx)\n"
   "  write (\" \", ctx)\n"
   "\n"
   "  -- Display the first child.\n"
   "  display (frame [1], ctx)\n"
   "\n"
   "  -- Display the remaining children.\n"
   "  for i = 2, #frame do\n"
   "    local child = frame [i]\n"
   "\n"
   "    -- Write the separator.\n"
   "    write (frame.bracket [BSEP], ctx)\n"
   "    write (\" \", ctx)\n"
   "\n"
   "    -- Display the child.\n"
   "    display (child, ctx)\n"
   "  end\n"
   "\n"
   "  -- Write the close bracket.\n"
   "  write (\" \", ctx)\n"
   "  display (frame.bracket [BCLOSE], ctx)\n"
   "end\n"
   "\n"
   "\n"
   "function display_frame_long (frame, ctx)\n"
   "  -- Remember the original value of next_indent.\n"
   "  local old_old_indent = ctx.prev_indent\n"
   "  local old_indent = ctx.next_indent\n"
   "\n"
   "  -- Display the open bracket.\n"
   "  display (frame.bracket [BOPEN], ctx)\n"
   "\n"
   "  -- Increase the indentation.\n"
   "  ctx.prev_indent = old_indent\n"
   "  ctx.next_indent = old_indent .. INDENT\n"
   "\n"
   "  -- For all but the last child...\n"
   "  for i = 1, #frame - 1 do\n"
   "    local child = frame [i]\n"
   "\n"
   "    -- Start a new line with old indentation.\n"
   "    newline_no_indent (ctx)\n"
   "    write (old_indent, ctx)\n"
   "\n"
   "    -- Display the child.\n"
   "    display (child, ctx)\n"
   "\n"
   "    -- Write the separator.\n"
   "    write (frame.bracket [BSEP], ctx)\n"
   "  end\n"
   "\n"
   "  -- For the last child...\n"
   "  do\n"
   "    local child = frame [#frame]\n"
   "\n"
   "    -- Start a new line with old indentation.\n"
   "    newline_no_indent (ctx)\n"
   "    write (old_indent, ctx)\n"
   "\n"
   "    -- Display the child.\n"
   "    display (child, ctx)\n"
   "    -- No separator.\n"
   "  end\n"
   "\n"
   "  -- Write the close bracket.\n"
   "  newline_no_indent (ctx)\n"
   "  write (old_old_indent, ctx)\n"
   "  display (frame.bracket [BCLOSE], ctx)\n"
   "\n"
   "  -- Return to the old indentation.\n"
   "  ctx.prev_indent = old_old_indent\n"
   "  ctx.next_indent = old_indent\n"
   "end\n"
   "\n"
   "\n"
   "function display_sequence (piece, ctx)\n"
   "  if #piece > 0 then\n"
   "    -- Check if this is a tight sequence.\n"
   "    if piece.tight then\n"
   "      -- Try to fit the entire sequence on one line.\n"
   "      local ml = min_len (piece, ctx)\n"
   "\n"
   "      -- If it won't fit here, but it would fit on the next line, then write it \n"
   "      -- on the next line; otherwise, write it here.\n"
   "      if ml > space_here (ctx) and ml <= space_newline (ctx) then\n"
   "        newline (ctx)\n"
   "      end\n"
   "    end\n"
   "\n"
   "    -- Apply the colors, if given.\n"
   "    if piece.colors then\n"
   "      write_nolength (piece.colors, ctx)\n"
   "    end\n"
   "\n"
   "    -- Display the first child.\n"
   "    display (piece [1], ctx)\n"
   "\n"
   "    -- For each following children:\n"
   "    for i = 2, #piece do\n"
   "      local child = piece [i]\n"
   "\n"
   "      -- Apply the colors, if given.\n"
   "      if piece.colors then\n"
   "        write_nolength (piece.colors, ctx)\n"
   "      end\n"
   "\n"
   "      -- Write a separator.\n"
   "      write (piece.sep or SEP, ctx)\n"
   "\n"
   "      -- Then display the child.\n"
   "      display (child, ctx)\n"
   "    end\n"
   "\n"
   "    -- Reset the colors.\n"
   "    if piece.colors then\n"
   "      write_nolength (C.e, ctx)\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "function display_string (piece, ctx)\n"
   "  local ml = min_len (piece)\n"
   "\n"
   "  -- If it won't fit here, but it would fit on the next line, then write it on \n"
   "  -- the next line; otherwise, write it here.\n"
   "  if ml > space_here (ctx) and ml <= space_newline (ctx) then\n"
   "    newline (ctx)\n"
   "  end\n"
   "\n"
   "  write (piece, ctx)\n"
   "end\n"
   "\n"
   "\n"
   "-- The minimum length to display this piece, if it is placed all on one line.\n"
   "function min_len (piece, ctx)\n"
   "  -- For strings, simply return their length.\n"
   "  if type (piece) == 'string' then\n"
   "    return #piece\n"
   "  end\n"
   "\n"
   "  -- Otherwise, we have some calculations to do.\n"
   "  local result = 0\n"
   "\n"
   "  if piece.bracket then\n"
   "    -- This is a frame.\n"
   "\n"
   "    -- If it's an empty frame, just the open and close brackets.\n"
   "    if #piece == 0 then\n"
   "      return min_len (piece.bracket [BOPEN]) + min_len (piece.bracket [BCLOSE])\n"
   "    end\n"
   "\n"
   "    -- Open and close brackets, plus a space for each.\n"
   "    result = result + min_len (piece.bracket [BOPEN]) +\n"
   "      min_len (piece.bracket [BCLOSE]) + 2\n"
   "\n"
   "    -- A separator between each item, plus a space for each.\n"
   "    result = result + (#piece - 1) * (#piece.bracket[BSEP] + 1)\n"
   "  else\n"
   "    -- This is a sequence.\n"
   "\n"
   "    -- If it's an empty sequence, then nothing.\n"
   "    if #piece == 0 then\n"
   "      return 0\n"
   "    end\n"
   "\n"
   "    -- A single separator between each item.\n"
   "    result = result + (#piece - 1) * #(piece.sep or SEP)\n"
   "  end\n"
   "\n"
   "  -- For both frames and sequences:\n"
   "  -- Find the minimum length of each child.\n"
   "  for _, child in ipairs (piece) do\n"
   "    result = result + min_len (child, ctx)\n"
   "  end\n"
   "\n"
   "  return result\n"
   "end\n"
   "\n"
   "\n"
   "function newline (ctx)\n"
   "  ctx.result = ctx.result .. \"\\n\"\n"
   "  ctx.line_len = 0\n"
   "  write (ctx.next_indent, ctx)\n"
   "end\n"
   "\n"
   "\n"
   "function newline_no_indent (ctx)\n"
   "  ctx.result = ctx.result .. \"\\n\"\n"
   "  ctx.line_len = 0\n"
   "end\n"
   "\n"
   "\n"
   "function write (str, ctx)\n"
   "  ctx.result = ctx.result .. str\n"
   "  ctx.line_len = ctx.line_len + #str\n"
   "end\n"
   "\n"
   "\n"
   "function write_nolength (str, ctx)\n"
   "  ctx.result = ctx.result .. str\n"
   "end\n"
   "\n"
   "\n"
   "function space_here (ctx)\n"
   "  return math.max (0, ctx.max_width - ctx.line_len)\n"
   "end\n"
   "\n"
   "\n"
   "function space_newline (ctx)\n"
   "  return math.max (0, ctx.max_width - #ctx.next_indent)\n"
   "end\n"
   "\n"
   "\n"
   "--\n"
   "-- Main function\n"
   "--\n"
   "\n"
   "\n"
   "return function (val)\n"
   "  if val == nil then\n"
   "    print (nil)\n"
   "  else\n"
   "    local ctx = new_context ()\n"
   "    local piece = translate (val, ctx)\n"
   "    piece = clean (piece, ctx)\n"
   "    display (piece, ctx)\n"
   "    print (C.e .. ctx.result .. C.e)\n"
   "  end\n"
   "end\n"},

  {"parser", 
   "local mm = require \"mm\"\n"
   "local Rule = require \"rule\"\n"
   "local json = require \"dkjson\"\n"
   "local Binding = require \"binding\"\n"
   "\n"
   "local function parseRulesetThing(parser, data_in, opt)\n"
   "  local data = data_in[opt.key]\n"
   "  parser:pushContext(data, opt.key)\n"
   "  local ruleset = parser.ruleset\n"
   "  \n"
   "  if data then\n"
   "    parser:assert_type(data, opt.type, (\"wrong type for ruleset %s, expected %s, got %s\"):format(opt.key, opt.type, parser:jsontype(data)))\n"
   "    local ret, err\n"
   "    for k,v in pairs(data) do\n"
   "      parser:assert_type(k, \"string\", (\"wrong key type for %s, expected string, got %s %s\"):format(opt.thing, parser:jsontype(k), tostring(k)))\n"
   "      ret, err = opt.parser_method(parser, v, k)\n"
   "      parser:assert(ret, err)\n"
   "      --assert(ret.id, (\"failed to generate id for %s\"):format(opt.thing))\n"
   "      parser:assert(ruleset[opt.key][ret.name] == nil, (\"%s %s already exists\"):format(opt.thing, ret.name))\n"
   "      ruleset[opt.key][ret.name]=ret\n"
   "    end\n"
   "  end\n"
   "  parser:popContext()\n"
   "  return true\n"
   "end\n"
   "\n"
   "local function jsonmeta(what)\n"
   "  return function(str, where)\n"
   "    return {__pos=where, __jsontype = what}\n"
   "  end\n"
   "end\n"
   "\n"
   "local class = {}\n"
   "\n"
   "function class:jsontype(var)\n"
   "  if type(var) == \"table\" then\n"
   "    local m = getmetatable(var)\n"
   "    return m and m.__jsontype or nil\n"
   "  else\n"
   "    return type(var)\n"
   "  end\n"
   "end\n"
   "function class:assert(cond, err)\n"
   "  if not cond then self:error(err) end\n"
   "  return cond\n"
   "end\n"
   "function class:assert_type(var, expected_type, err)\n"
   "  return self:assert(type(var) == expected_type, err or (\"expected type '%s', got '%s'\"):format(expected_type, type(var)))\n"
   "end\n"
   "function class:assert_jsontype(var, expected_type, err)\n"
   "  return self:assert(self:jsontype(var) == expected_type,\n"
   "    err or (\"expected JSON type '%s', got '%s'\"):format(expected_type, self:jsontype(var))\n"
   "  )\n"
   "end\n"
   "function class:assert_table_size(var, expected_size, err)\n"
   "  self:assert_type(var, \"table\")\n"
   "  local n = 0\n"
   "  for _, _ in pairs(var) do\n"
   "    n = n + 1\n"
   "  end\n"
   "  if n ~= expected_size then\n"
   "    self:error(err or (\"wrong table size, expected %i, got %i\"):format(expected_size, n))\n"
   "  end\n"
   "  return var\n"
   "end\n"
   "function class:error(err)\n"
   "  local getloc = function(str, where)\n"
   "    local line, pos, linepos = 1, 1, 0\n"
   "    while true do\n"
   "      pos = str:find(\"\\n\", pos, true)\n"
   "      if pos and pos < where then\n"
   "        line = line + 1\n"
   "        linepos = pos\n"
   "        pos = pos + 1\n"
   "      else\n"
   "        break\n"
   "      end\n"
   "    end\n"
   "    return \"line \" .. line .. \", column \" .. (where - linepos)\n"
   "  end\n"
   "  \n"
   "  local getpos = function(ctx)\n"
   "    local meta = getmetatable(ctx)\n"
   "    if meta then\n"
   "      return meta.__pos\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  if not err then err = \"unknown error\" end\n"
   "  \n"
   "  local nested_names = {}\n"
   "  \n"
   "  for i=#self.ctx_stack,1,-1 do\n"
   "    local cur = self.ctx_stack[i]\n"
   "    if cur.name then table.insert(nested_names, cur.name) end\n"
   "    local pos = getpos(cur.ctx)\n"
   "    if pos then\n"
   "      if self.name then table.insert(nested_names, self.name) end\n"
   "      error((\"%s at %s: %s\"):format(table.concat(nested_names, \" in \"), getloc(self.source, pos), err))\n"
   "    end\n"
   "  end\n"
   "  if self.name then table.insert(nested_names, self.name) end\n"
   "  if #nested_names > 0 then\n"
   "    error((\"%s: %s\"):format(table.concat(nested_names, \" in \"), err))\n"
   "  else\n"
   "    error(err)\n"
   "  end\n"
   "end\n"
   "function class:pushContext(ctx, name)\n"
   "  table.insert(self.ctx_stack, {ctx=ctx, name=name})\n"
   "  self.context = self.ctx_stack[#self.ctx_stack]\n"
   "  return self\n"
   "end\n"
   "function class:popContext()\n"
   "  table.remove(self.ctx_stack, #self.ctx_stack)\n"
   "  self.context = self.ctx_stack[#self.ctx_stack]\n"
   "end\n"
   "function class:getContext(name)\n"
   "  if not name then return self.context and self.context.ctx end\n"
   "  for i=#self.ctx_stack, 1, -1 do\n"
   "    local cur = self.ctx_stack[i]\n"
   "    if cur.name==name then\n"
   "      return cur.ctx\n"
   "    end\n"
   "  end\n"
   "  return nil\n"
   "end\n"
   "\n"
   "function class:parseFile(path)\n"
   "  local file = assert(io.open(path, \"rb\")) -- r read mode and b binary mode\n"
   "  local content = file:read(\"*a\") -- *a or *all reads the whole file\n"
   "  file:close()\n"
   "  self.name = path\n"
   "  return self:parseJSON(content, \"file \" .. path)\n"
   "end\n"
   "\n"
   "function class:parseJSON(json_str, json_name)\n"
   "  self:assert_type(json_str, \"string\", \"expected a JSON string\")\n"
   "  local data, _, err = json.decode(json_str, 1, json.null, jsonmeta(\"object\"), jsonmeta(\"array\"))\n"
   "  self.name = json_name or self.context_name\n"
   "  self.source = json_str\n"
   "  if not data then\n"
   "    self:error(err)\n"
   "  end\n"
   "  return self:parseRuleSet(data)\n"
   "end\n"
   "\n"
   "function class:parseRuleSet(data, name)\n"
   "  self.ruleset = {\n"
   "    limiters= {},\n"
   "    rules= {},\n"
   "    lists= {},\n"
   "    table= {},\n"
   "    name = name\n"
   "  }\n"
   "  self:pushContext(data, \"ruleset\")\n"
   "  \n"
   "  self:assert_type(data, \"table\", \"wrong type for ruleset\")\n"
   "  parseRulesetThing(self, data, {\n"
   "    thing=\"limiter\", key=\"limiters\", type=\"table\",\n"
   "    parser_method= self.parseLimiter\n"
   "  })\n"
   "  self:checkLimiters(data.limiters)\n"
   "  \n"
   "  parseRulesetThing(self, data, {\n"
   "    thing=\"rule\", key=\"rules\",  type=\"table\",\n"
   "    parser_method=function(self, data, name)\n"
   "      self:pushContext(data, \"rule\")\n"
   "      self:assert(type(data) ~= \"string\", (\"named rule \\\"%s\\\" cannot be a string referring to another named rule \\\"%s\\\"\"):format(name, tostring(data)))\n"
   "      self:popContext()\n"
   "      return self:parseRule(data, name)\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  parseRulesetThing(self, data, {\n"
   "    thing=\"list\", key=\"lists\",  type=\"table\",\n"
   "    parser_method= self.parseRuleList\n"
   "  })\n"
   "  \n"
   "  self.ruleset.phases = self:parsePhaseTable(data.phases)\n"
   "  return self.ruleset\n"
   "end\n"
   "\n"
   "function class:parsePhaseTable(data)\n"
   "  self:assert(data ~= nil, \"missing phase table (\\\"phases\\\" attribute)\")\n"
   "  self:assert_jsontype(data, \"object\", \"phase table must be an object\")\n"
   "  self:pushContext(data, \"phase table\")\n"
   "  local phase_table = {}\n"
   "  \n"
   "  for k,v in pairs(data) do\n"
   "    self:assert_type(k, \"string\", \"phase table entries must be strings\")\n"
   "    if self:jsontype(v) == \"array\" then\n"
   "      --array of lists\n"
   "      local lists = {}\n"
   "      for _, vv in ipairs(v) do\n"
   "        if type(vv)==\"string\" or self:jsontype(vv) == \"array\" or self:jsontype(vv) == \"object\" then\n"
   "          table.insert(lists, self:parseRuleList(vv))\n"
   "        else\n"
   "          self:error((\"invalid rule list type: %s\"):format(self:jsontype(vv)))\n"
   "        end\n"
   "      end\n"
   "      phase_table[k]=lists\n"
   "    elseif type(v) == \"string\" then\n"
   "      --singe named list\n"
   "      phase_table[k]={ self:parseRuleList(v) }\n"
   "    elseif self:jsontype(v)==\"object\" then\n"
   "      --single long-form list\n"
   "      phase_table[k]=self:parseRuleList(v)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  self:popContext()\n"
   "  return phase_table\n"
   "end\n"
   "\n"
   "function class:parseRuleList(data, name)\n"
   "  if type(data)==\"string\" then\n"
   "    self:assert(self.ruleset.lists[data], ([[named list \"%s\" not found]]):format(data))\n"
   "    return self.ruleset.lists[data]\n"
   "  end\n"
   "  self:pushContext(data, \"list\")\n"
   "  \n"
   "  if self:jsontype(data) == \"object\" then\n"
   "    if name then\n"
   "      self:assert(name == data.name, \"rule list 'name' attribute must match outside list name\")\n"
   "    else\n"
   "      name = tostring(data.name)\n"
   "    end\n"
   "    data = data.rules\n"
   "  end\n"
   "  self:assert_jsontype(data, \"array\", \"rule list must be an array\")\n"
   "  local rules = {}\n"
   "  for _,v in ipairs(data) do\n"
   "    table.insert(rules, self:parseRule(v))\n"
   "  end\n"
   "  self:popContext()\n"
   "  return {name=name, rules=rules}\n"
   "end\n"
   "\n"
   "local function clear_json_meta(data)\n"
   "  if type(data) == \"table\" then\n"
   "    local meta = getmetatable(data)\n"
   "    if meta and meta.__jsontype then\n"
   "      setmetatable(data, nil)\n"
   "    end\n"
   "    for _, v in pairs(data) do\n"
   "      clear_json_meta(v)\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "function class:parseRule(data, name)\n"
   "  self:pushContext(data, \"rule\")\n"
   "  local rule\n"
   "  if type(data) == \"string\" then\n"
   "    rule = self.ruleset.rules[data]\n"
   "    self:assert(rule, ([[named rule \"%s\" not found]]):format(data))\n"
   "    self:popContext()\n"
   "    return rule\n"
   "  end\n"
   "  self:assert_type(data, \"table\", \"invalid rule data type: \" .. type(data))\n"
   "  self:assert_jsontype(data, \"object\", (\"invalid rule data type: %s\"):format(self:jsontype(data)))\n"
   "  \n"
   "  if ((data[\"if\"] or data[\"if-any\"] or data[\"if-all\"]) or data[\"then\"]) then\n"
   "    self:assert(not data[\"always\"], [[\"always\" clause can't be present in if/then rule]])\n"
   "    self:assert(not data[\"switch\"], [[\"switch\" clause can't be present in if/then rule]])\n"
   "  end\n"
   "  \n"
   "  if data[\"then\"] then\n"
   "    if (data[\"if\"] and (data[\"if-any\"] or data[\"if-all\"])) or (data[\"if-any\"] and data[\"if-all\"]) then\n"
   "      self:error(\"only one of \\\"if\\\", \\\"if-any\\\" or \\\"if-all\\\" allowed in if/then rule\")\n"
   "    end\n"
   "    \n"
   "    local condition\n"
   "    if data[\"if\"] then\n"
   "      condition = self:parseCondition(data[\"if\"])\n"
   "    elseif data[\"if-any\"] or data[\"if-all\"] then\n"
   "      local conditions = {}\n"
   "      for _, v in ipairs(data[\"if-any\"] or data[\"if-all\"]) do\n"
   "        condition = self:assert(self:parseCondition(v))\n"
   "        table.insert(conditions, condition)\n"
   "      end\n"
   "      condition = {[(data[\"if-any\"] and \"any\" or \"all\")]=conditions}\n"
   "    end\n"
   "    rule = {[\"if\"]=condition, [\"then\"]=data[\"then\"], [\"else\"]=data[\"else\"], name=data[\"name\"] or name, info=data[\"info\"], key=data[\"key\"]}\n"
   "  elseif data[\"always\"] then\n"
   "    rule = {[\"if\"]={[\"true\"]={}}, [\"then\"]=data[\"always\"], name=data[\"name\"] or name, info=data[\"info\"], key=data[\"key\"]}\n"
   "  elseif next(data) == nil then\n"
   "    self:error(\"empty rule not allowed\")\n"
   "  else\n"
   "    self:error(\"rule must have at least an \\\"if\\\", \\\"then\\\", or \\\"always\\\" attribute\")\n"
   "  end\n"
   "  if rule[\"if\"] then\n"
   "    rule[\"then\"] = self:parseActions(rule[\"then\"])\n"
   "    rule[\"else\"] = self:parseActions(rule[\"else\"])\n"
   "  end\n"
   "  \n"
   "  self:popContext()\n"
   "  clear_json_meta(rule)\n"
   "  return rule\n"
   "end\n"
   "\n"
   "function class:parseCondition(data)\n"
   "  self:pushContext(data, \"condition\")\n"
   "  local condition\n"
   "  if type(data) == \"string\" then\n"
   "    condition = {[data]={}}\n"
   "  elseif type(data) == \"table\" then\n"
   "    self:assert_jsontype(data, \"object\", \"condition cannot be an array, must be an object\")\n"
   "    self:assert_table_size(data, 1, \"condition object must have exactly one attribute (the condition name)\")\n"
   "    condition = data\n"
   "  else\n"
   "    self:error((\"wrong type (%s) for condition\"):format(type(data)))\n"
   "  end\n"
   "  self:popContext()\n"
   "  -- be more specific with condition name\n"
   "  self:pushContext(data, \"condition \" .. (next(condition)))\n"
   "  condition = Rule.condition.parse(condition, self)\n"
   "  self:popContext()\n"
   "  return condition\n"
   "end\n"
   "  \n"
   "function class:parseAction(data)\n"
   "  self:pushContext(data, \"action\")\n"
   "  local action\n"
   "  if type(data) == \"string\" then\n"
   "    action = {[data]={}}\n"
   "  elseif self:jsontype(data) == \"object\" then\n"
   "    self:assert(next(data, next(data)) == nil, \"action object must have only 1 attribute -- the action name\")\n"
   "    action = data\n"
   "  else\n"
   "    self:error((\"action must be string on 1-attribute object, but instead was a %s\"):format(self:jsontype(data)))\n"
   "  end\n"
   "  self:popContext()\n"
   "  --we can be more specific about the action name now\n"
   "  self:pushContext(data, \"action \" .. (next(action)))\n"
   "  action = Rule.action.parse(action, self)\n"
   "  self:popContext()\n"
   "  return action\n"
   "end\n"
   "\n"
   "function class:parseActions(data)\n"
   "  if data == nil then\n"
   "    return {}\n"
   "  end\n"
   "  self:pushContext(data) --no context name plz\n"
   "  local actions = {}\n"
   "  if self:jsontype(data) == \"object\" or type(data)==\"string\" or (#data == 0 and next(data) ~= nil) then\n"
   "    table.insert(actions, self:parseAction(data))\n"
   "  elseif type(data) == \"table\" then\n"
   "    for _, v in ipairs(data) do\n"
   "      table.insert(actions, self:parseAction(v))\n"
   "    end\n"
   "  end\n"
   "  self:popContext()\n"
   "  return actions\n"
   "end\n"
   "\n"
   "function class:parseTimeInterval(data, err)\n"
   "  if err then err = \" for \" .. err end\n"
   "  local typ = self:jsontype(data)\n"
   "  if typ == \"number\" then\n"
   "    return data\n"
   "  elseif typ == \"string\" then\n"
   "    local num, unit = data:match(\"^([%d.]+)(%w*)\")\n"
   "    local scale\n"
   "    num = tonumber(num)\n"
   "    self:assert(num and unit, (\"invalid time string \\\"%s\\\"%s\"):format(data, err))\n"
   "    if unit == \"ms\" or unit:match(\"^millisec(ond(s?))?\") then\n"
   "      scale = .01\n"
   "    elseif unit == \"\" or unit == \"s\" or unit:match(\"^sec(ond(s?))?\") then\n"
   "      scale = 1\n"
   "    elseif unit == \"m\" or unit:match(\"^min(ute(s)?)?\") then\n"
   "      scale = 60\n"
   "    elseif unit == \"h\" or unit:match(\"^hour(s?)\") then\n"
   "      scale = 3600\n"
   "    elseif unit == \"d\" or unit:match(\"^day(s)?\") then\n"
   "      scale = 86400\n"
   "    elseif unit == \"w\" or unit == \"wk\" or unit:match(\"^week(s)?\") then\n"
   "      scale = 604800\n"
   "    elseif unit == \"M\" or unit:match(\"^month(s)?\") then\n"
   "      scale = 2628001\n"
   "    else\n"
   "      self:error((\"unknown time unit \\\"%s\\\"%s\"):format(unit, err))\n"
   "    end\n"
   "    return num * scale\n"
   "  else\n"
   "    self:error((\"invalid time inteval type \\\"%s\\\"%s\"):format(self:jsontype(data), err))\n"
   "  end\n"
   "end\n"
   "\n"
   "function class:parseLimiter(data, name)\n"
   "  self:pushContext(data, \"limiter\")\n"
   "  \n"
   "  if not data.name then data.name = name end\n"
   "  data.interval = self:parseTimeInterval(data.interval, \"interval value\")\n"
   "  self:assert(data.limit, \"missing \\\"limit\\\" value\")\n"
   "  data.limit = self:assert(tonumber(data.limit), \"invalid \\\"limit\\\" value, must be a number\")\n"
   "  if data.sync_steps then\n"
   "    data.sync_steps = self:assert(tonumber(data.sync_steps), \"invalid \\\"sync-steps\\\" value\")\n"
   "  end\n"
   "  if data.burst then \n"
   "    self:assert_type(data.burst, \"string\", \"invalid \\\"burst\\\" value type\")\n"
   "  end\n"
   "  if data[\"burst-expire\"] then\n"
   "    data.burst_expire = self:parseTimeInterval(data[\"burst-expire\"], \"burst_expire value\")\n"
   "    data[\"burst-expire\"] = nil\n"
   "  end\n"
   "  \n"
   "  self:assert_type(data.name, \"string\", \"invalid limiter name\")\n"
   "  self:popContext()\n"
   "  return data\n"
   "end\n"
   "function class:checkLimiters(data)\n"
   "  self:pushContext(data, \"limiters\")\n"
   "  for k, v in pairs(data) do\n"
   "    self:pushContext(v, (\"limiter \\\"%s\\\"\"):format(v.name))\n"
   "    if v.burst then\n"
   "      --make sure the burst value refers to a known limiter\n"
   "      self:assert(data[v.burst], (\"limiter references unknown burst limiter \\\"%s\\\"\"):format(v.burst))\n"
   "    end\n"
   "    self:popContext()\n"
   "  end\n"
   "  self:popContext()\n"
   "end\n"
   "\n"
   "local function newparser()\n"
   "  local parser = {\n"
   "    name = \"<?>\",\n"
   "    ctx_stack = {}\n"
   "  }\n"
   "  \n"
   "  setmetatable(parser, {__index = class})\n"
   "  return parser\n"
   "end\n"
   "\n"
   "local Parser = {new = newparser}\n"
   "\n"
   "return Parser\n"},

  {"rule", 
   "local mm = require \"mm\"\n"
   "local Binding = require \"binding\"\n"
   "\n"
   "local function ignore_leading_hash(str)\n"
   "  return str:sub(1,1)==\"#\" and str:sub(2) or str\n"
   "end\n"
   "\n"
   "local thingstorage_meta = {__index = function(self, key)\n"
   "  local unhashed = ignore_leading_hash(key)\n"
   "  if unhashed ~= key then\n"
   "    return self[ignore_leading_hash(key)]\n"
   "  end\n"
   "end}\n"
   "\n"
   "local function create_thing_storage(thing_name)\n"
   "  local self = {table = setmetatable({}, thingstorage_meta)}\n"
   "  \n"
   "  local function unpack_thing(data, parser)\n"
   "    local name, val = next(data)\n"
   "    local thing = self.table[name]\n"
   "    if parser then\n"
   "      parser:assert(thing, (\"Unknown %s \\\"%s\\\"\"):format(thing_name, name))\n"
   "    else\n"
   "      assert(thing, (\"Unknown %s \\\"%s\\\"\"):format(thing_name, name))\n"
   "    end\n"
   "    return name, val\n"
   "  end\n"
   "  \n"
   "  function self.add(name, funcs, metaindex)\n"
   "    if type(name) == \"table\" then\n"
   "      for _,v in pairs(name) do\n"
   "        self.add(v, funcs, metaindex)\n"
   "      end\n"
   "      return true\n"
   "    end\n"
   "    assert(funcs.parse, (\"%s missing parse callback\"):format(thing_name))\n"
   "    assert(self.table[name] == nil, (\"%s %s already exists\"):format(thing_name, name))\n"
   "    local added = {\n"
   "      parse=funcs.parse,\n"
   "      init=funcs.init or function() end\n"
   "    }\n"
   "    if metaindex then\n"
   "      added.meta={__index = metaindex}\n"
   "    end\n"
   "    self.table[name]=added\n"
   "    return true\n"
   "  end\n"
   "  \n"
   "  function self.parse(data, parser)\n"
   "    local name, val = unpack_thing(data, parser)\n"
   "    val = self.table[name].parse(val, parser) or val\n"
   "    return {[name]=val}\n"
   "  end\n"
   "  \n"
   "  function self.new(data, ruleset)\n"
   "    local name, val = unpack_thing(data)\n"
   "    local thing_preset = self.table[name]\n"
   "    local thing = setmetatable({[thing_name]=ignore_leading_hash(name), [\"data\"]=val}, thing_preset.meta)\n"
   "    thing_preset.init(val, thing, ruleset)\n"
   "    Binding.call(thing_name, \"create\", thing)\n"
   "    return thing\n"
   "  end\n"
   "  \n"
   "  return self\n"
   "end\n"
   "\n"
   "local Rule = {\n"
   "  condition = create_thing_storage(\"condition\"),\n"
   "  action = create_thing_storage(\"action\")\n"
   "}\n"
   "\n"
   "--now let's add some basic conditions and actions\n"
   "Rule.condition.add(\"any\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"array\", \"\\\"any\\\" condition value must be an array of conditions\")\n"
   "    for i, v in ipairs(data) do\n"
   "      local condition = parser:parseCondition(v)\n"
   "      data[i]=condition\n"
   "    end\n"
   "  end,\n"
   "  init = function(data, thing, ruleset)\n"
   "    for i, v in ipairs(data) do\n"
   "      data[i] = Rule.condition.new(v, ruleset)\n"
   "    end\n"
   "  end\n"
   "})\n"
   "\n"
   "Rule.condition.add(\"all\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"array\", \"\\\"all\\\" condition value must be an array of conditions\")\n"
   "    for _, v in ipairs(data) do\n"
   "      local condition = parser:parseCondition(v)\n"
   "      data[i]=condition\n"
   "    end\n"
   "  end,\n"
   "  init = function(data, thing, ruleset)\n"
   "    for i, v in ipairs(data) do\n"
   "      data[i] = Rule.condition.new(v, ruleset)\n"
   "    end\n"
   "  end\n"
   "})\n"
   "\n"
   "Rule.condition.add({\"true\", \"false\"}, {parse = function(data, parser)\n"
   "  --parser:assert(next(data) == nil, \"\\\"true\\\" condition must have empty parameters\")\n"
   "end})\n"
   "\n"
   "Rule.condition.add(\"tag-check\", {parse = function(data, parser)\n"
   "  parser:assert_type(data, \"string\", \"\\\"tag-check\\\" value must be a string\")\n"
   "end})\n"
   "\n"
   "Rule.condition.add(\"match\", {parse = function(data, parser)\n"
   "  parser:assert_jsontype(data, \"array\", \"\\\"match\\\" value must be an array of strings\")\n"
   "  for _, v in ipairs(data) do\n"
   "    parser:assert_jsontype(v, \"string\", \"\\\"match\\\" value must be an array of strings\")\n"
   "  end\n"
   "end})\n"
   "\n"
   "--limiter conditions\n"
   "Rule.condition.add({\"limit-break\", \"limit-check\"}, {parse = function(data, parser)\n"
   "  if type(data) == \"string\" then\n"
   "    data = {name=data}\n"
   "  elseif type(data) == \"table\" then\n"
   "    \n"
   "  else\n"
   "    parser:error(\"invalid value type \" .. type(data))\n"
   "  end\n"
   "  local condition_name = next(parser:getContext())\n"
   "  local rule = parser:getContext(\"rule\")\n"
   "  \n"
   "  if not data.key then\n"
   "    data.key = rule.key\n"
   "  end\n"
   "  parser:assert(data.key, \"limiter \\\"key\\\" missing, and no default \\\"key\\\" in rule\")\n"
   "  parser:assert_type(data.key, \"string\", \"invalid limiter \\\"key\\\" type\")\n"
   "  \n"
   "  if not data.increment then\n"
   "    if condition_name == \"limit-break\" then\n"
   "      data.increment = 1\n"
   "    elseif condition_name == \"limit-check\" then\n"
   "      data.increment = 0\n"
   "    end\n"
   "  end\n"
   "  data.increment = parser:assert(tonumber(data.increment), \"invalid or empty \\\"increment\\\" value\")\n"
   "  \n"
   "  parser:assert(data.name, \"name missing\")\n"
   "  parser:assert_type(data.name, \"string\", \"invalid \\\"name\\\" type\")\n"
   "  return data\n"
   "end})\n"
   "\n"
   "--some actions, too\n"
   "Rule.action.add(\"tag\", {parse = function(data, parser)\n"
   "  parser:assert_jsontype(data, \"string\", \"\\\"tag\\\" value must be a string\")\n"
   "end})\n"
   "\n"
   "Rule.action.add(\"accept\", {parse = function(data, parser)\n"
   "  parser:assert_type(data, \"table\", \"\\\"accept\\\" value must be an object\")\n"
   "  parser:assert_table_size(data, 0, \"\\\"accept\\\" value must be empty\")\n"
   "end})\n"
   "Rule.action.add(\"reject\", {parse = function(data, parser)\n"
   "  parser:assert_type(data, \"table\", \"\\\"reject\\\" value must be an object\")\n"
   "  --parser:assert_table_size(data, 0, \"\\\"reject\\\" value must be empty\")\n"
   "end})\n"
   "\n"
   "return Rule\n"},

  {"ruleset", 
   "local Rule = require \"rule\"\n"
   "local Binding = require \"binding\"\n"
   "\n"
   "local function assert_unique_name(what, tbl, data)\n"
   "  assert(data.name, (\"a %s must have a name\"):format(what))\n"
   "  assert(not tbl[data.name], (\"%s \\\"%s\\\" already exists\"):format(what, data.name))\n"
   "end\n"
   "\n"
   "local function thing_name(thing)\n"
   "  if type(thing)==\"string\" then\n"
   "    return thing\n"
   "  elseif type(thing) == \"table\" then\n"
   "    return thing.name\n"
   "  else\n"
   "    return thing\n"
   "  end\n"
   "end\n"
   "\n"
   "local ruleset_meta = { __index = {\n"
   "  type=\"ruleset\",\n"
   "  \n"
   "  findLimiter = function(self, name)\n"
   "    return self.limiters[thing_name(name)]\n"
   "  end,\n"
   "  \n"
   "  addLimiter = function(self, data)\n"
   "    assert_unique_name(\"limiter\", self.limiters, data)\n"
   "    local limiter = setmetatable(data, self.__submeta.limiter)\n"
   "    self.limiters[data.name]=limiter\n"
   "    Binding.call(\"limiter\", \"create\", limiter)\n"
   "    return self\n"
   "  end,\n"
   "  \n"
   "  findRule = function(self, name)\n"
   "    return self.rules[thing_name(name)]\n"
   "  end,\n"
   "  addRule = function(self, data)\n"
   "    if not data.name then\n"
   "      data.name = self:uniqueName(self.rules, \"rule\")\n"
   "    else\n"
   "      assert_unique_name(\"rule\", self.rules, data)\n"
   "    end\n"
   "    \n"
   "    local rule =setmetatable(data, self.__submeta.rule)\n"
   "    rule.ruleset = nil\n"
   "    if data[\"if\"] then\n"
   "      data[\"if\"] = Rule.condition.new(rule[\"if\"], rule)\n"
   "    end\n"
   "    for _,clause in pairs{\"then\", \"else\"} do\n"
   "      if data[clause] then\n"
   "        local actions = {}\n"
   "        for _,v in pairs(data[clause]) do\n"
   "          table.insert(actions, Rule.action.new(v, self))\n"
   "        end\n"
   "        data[clause]=actions\n"
   "      end\n"
   "    end\n"
   "    \n"
   "    self.rules[data.name]=rule\n"
   "    Binding.call(\"rule\", \"create\", rule)\n"
   "    return rule\n"
   "  end,\n"
   "  \n"
   "  findList = function(self, name)\n"
   "    return self.lists[thing_name(name)]\n"
   "  end,\n"
   "  addList = function(self, data)\n"
   "    if not data.name then\n"
   "      data.name = self:uniqueName(self.lists, \"list\")\n"
   "    else\n"
   "      assert_unique_name(\"list\", self.lists, data)\n"
   "    end\n"
   "    \n"
   "    for i, rule_data in ipairs(data.rules) do\n"
   "      data.rules[i]= self:findRule(rule_data.name) or self:addRule(rule_data)\n"
   "    end\n"
   "    local list = setmetatable(data, self.__submeta.list)\n"
   "    self.lists[data.name] = list\n"
   "    Binding.call(\"list\", \"create\", list)\n"
   "    return list\n"
   "  end,\n"
   "  \n"
   "  setTable = function(self, data)\n"
   "    self.phases = {}\n"
   "    for k,v in pairs(data) do\n"
   "      for i, list in pairs(v) do\n"
   "        v[i]=self:findList(list) or self:addList(list)\n"
   "      end\n"
   "      self.phases[k]=v\n"
   "    end\n"
   "    return self.phases\n"
   "  end,\n"
   "  \n"
   "  uniqueName = function(self, names_tbl, prefix)\n"
   "    if not self.__n then\n"
   "      self.__n = 0\n"
   "    else\n"
   "      self.__n = self.__n + 1\n"
   "    end\n"
   "    local name = (\"%s%i\"):format(prefix, self.__n)\n"
   "    if names_tbl[name] then --oh no it's not unique. try again\n"
   "      return self:uniqueName(names_tbl, prefix)\n"
   "    else\n"
   "      return name\n"
   "    end\n"
   "  end\n"
   "  \n"
   "}}\n"
   "\n"
   "local function newRuleset(data)\n"
   "  local ruleset = setmetatable({\n"
   "    rules={},\n"
   "    lists={},\n"
   "    limiters={},\n"
   "    table={},\n"
   "    name = data and data.name or nil\n"
   "  }, ruleset_meta)\n"
   "  \n"
   "  ruleset.__submeta = {\n"
   "    rule = {__index = {\n"
   "      type=\"rule\",\n"
   "      ruleset = ruleset,\n"
   "      in_lists = {},\n"
   "    }},\n"
   "    list = {__index = {\n"
   "      type=\"list\",\n"
   "      ruleset = ruleset,\n"
   "      in_tables = {}\n"
   "    }},\n"
   "    limiter = {__index = {\n"
   "      type=\"limiter\",\n"
   "      ruleset = ruleset\n"
   "    }}\n"
   "  }\n"
   "\n"
   "  if not ruleset.name then ruleset.name = ruleset:uniqueName({}, \"ruleset\") end\n"
   "  \n"
   "  if data then\n"
   "    --load data\n"
   "    for _, v in pairs(data.limiters) do\n"
   "      ruleset:addLimiter(v)\n"
   "    end\n"
   "    \n"
   "    for _, v in pairs(data.rules) do\n"
   "      ruleset:addRule(v)\n"
   "    end\n"
   "    \n"
   "    for _, v in pairs(data.lists) do\n"
   "      ruleset:addList(v)\n"
   "    end\n"
   "    \n"
   "    ruleset:setTable(data.phases)\n"
   "  end\n"
   "  Binding.call(\"ruleset\", \"create\", ruleset)\n"
   "  return ruleset\n"
   "end\n"
   "\n"
   "local Ruleset = {new = newRuleset}\n"
   "\n"
   "return Ruleset\n"
   "\n"}
};

const int wfx_module_lua_scripts_count=6;
#define WFX_MODULE_LUA_SCRIPTS_EACH(script) \
for((script)=(wfx_module_lua_script_t *)&wfx_module_lua_scripts; (script) < (wfx_module_lua_script_t *)(&wfx_module_lua_scripts + 1); (script)++) 
