// don't edit this please, it was auto-generated by hsss
// https://github.com/slact/hsss

typedef struct {
  //David Kolf's JSON module for Lua 5.1/5.2
  char *dkjson;

} ngx_wfx_parser_lua_scripts_t;

ngx_wfx_parser_lua_scripts_t ngx_wfx_parser_lua_scripts = {
  //dkjson
  "--David Kolf's JSON module for Lua 5.1/5.2\n"
  "\n"
  "local always_try_using_lpeg = true\n"
  "local register_global_module_table = false\n"
  "local global_module_name = 'json'\n"
  "\n"
  "--[==[\n"
  "\n"
  "David Kolf's JSON module for Lua 5.1/5.2\n"
  "\n"
  "Version 2.5\n"
  "\n"
  "\n"
  "For the documentation see the corresponding readme.txt or visit\n"
  "<http://dkolf.de/src/dkjson-lua.fsl/>.\n"
  "\n"
  "You can contact the author by sending an e-mail to 'david' at the\n"
  "domain 'dkolf.de'.\n"
  "\n"
  "\n"
  "Copyright (C) 2010-2013 David Heiko Kolf\n"
  "\n"
  "Permission is hereby granted, free of charge, to any person obtaining\n"
  "a copy of this software and associated documentation files (the\n"
  "\"Software\"), to deal in the Software without restriction, including\n"
  "without limitation the rights to use, copy, modify, merge, publish,\n"
  "distribute, sublicense, and/or sell copies of the Software, and to\n"
  "permit persons to whom the Software is furnished to do so, subject to\n"
  "the following conditions:\n"
  "\n"
  "The above copyright notice and this permission notice shall be\n"
  "included in all copies or substantial portions of the Software.\n"
  "\n"
  "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n"
  "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
  "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
  "NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n"
  "BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n"
  "ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n"
  "CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
  "SOFTWARE.\n"
  "\n"
  "--]==]\n"
  "\n"
  "-- global dependencies:\n"
  "local pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset =\n"
  "      pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset\n"
  "local error, require, pcall, select = error, require, pcall, select\n"
  "local floor, huge = math.floor, math.huge\n"
  "local strrep, gsub, strsub, strbyte, strchar, strfind, strlen, strformat =\n"
  "      string.rep, string.gsub, string.sub, string.byte, string.char,\n"
  "      string.find, string.len, string.format\n"
  "local strmatch = string.match\n"
  "local concat = table.concat\n"
  "\n"
  "local json = { version = \"dkjson 2.5\" }\n"
  "\n"
  "if register_global_module_table then\n"
  "  _G[global_module_name] = json\n"
  "end\n"
  "\n"
  "local _ENV = nil -- blocking globals in Lua 5.2\n"
  "\n"
  "pcall (function()\n"
  "  -- Enable access to blocked metatables.\n"
  "  -- Don't worry, this module doesn't change anything in them.\n"
  "  local debmeta = require \"debug\".getmetatable\n"
  "  if debmeta then getmetatable = debmeta end\n"
  "end)\n"
  "\n"
  "json.null = setmetatable ({}, {\n"
  "  __tojson = function () return \"null\" end\n"
  "})\n"
  "\n"
  "local function isarray (tbl)\n"
  "  local max, n, arraylen = 0, 0, 0\n"
  "  for k,v in pairs (tbl) do\n"
  "    if k == 'n' and type(v) == 'number' then\n"
  "      arraylen = v\n"
  "      if v > max then\n"
  "        max = v\n"
  "      end\n"
  "    else\n"
  "      if type(k) ~= 'number' or k < 1 or floor(k) ~= k then\n"
  "        return false\n"
  "      end\n"
  "      if k > max then\n"
  "        max = k\n"
  "      end\n"
  "      n = n + 1\n"
  "    end\n"
  "  end\n"
  "  if max > 10 and max > arraylen and max > n * 2 then\n"
  "    return false -- don't create an array with too many holes\n"
  "  end\n"
  "  return true, max\n"
  "end\n"
  "\n"
  "local escapecodes = {\n"
  "  [\"\\\"\"] = \"\\\\\\\"\", [\"\\\\\"] = \"\\\\\\\\\", [\"\\b\"] = \"\\\\b\", [\"\\f\"] = \"\\\\f\",\n"
  "  [\"\\n\"] = \"\\\\n\",  [\"\\r\"] = \"\\\\r\",  [\"\\t\"] = \"\\\\t\"\n"
  "}\n"
  "\n"
  "local function escapeutf8 (uchar)\n"
  "  local value = escapecodes[uchar]\n"
  "  if value then\n"
  "    return value\n"
  "  end\n"
  "  local a, b, c, d = strbyte (uchar, 1, 4)\n"
  "  a, b, c, d = a or 0, b or 0, c or 0, d or 0\n"
  "  if a <= 0x7f then\n"
  "    value = a\n"
  "  elseif 0xc0 <= a and a <= 0xdf and b >= 0x80 then\n"
  "    value = (a - 0xc0) * 0x40 + b - 0x80\n"
  "  elseif 0xe0 <= a and a <= 0xef and b >= 0x80 and c >= 0x80 then\n"
  "    value = ((a - 0xe0) * 0x40 + b - 0x80) * 0x40 + c - 0x80\n"
  "  elseif 0xf0 <= a and a <= 0xf7 and b >= 0x80 and c >= 0x80 and d >= 0x80 then\n"
  "    value = (((a - 0xf0) * 0x40 + b - 0x80) * 0x40 + c - 0x80) * 0x40 + d - 0x80\n"
  "  else\n"
  "    return \"\"\n"
  "  end\n"
  "  if value <= 0xffff then\n"
  "    return strformat (\"\\\\u%.4x\", value)\n"
  "  elseif value <= 0x10ffff then\n"
  "    -- encode as UTF-16 surrogate pair\n"
  "    value = value - 0x10000\n"
  "    local highsur, lowsur = 0xD800 + floor (value/0x400), 0xDC00 + (value % 0x400)\n"
  "    return strformat (\"\\\\u%.4x\\\\u%.4x\", highsur, lowsur)\n"
  "  else\n"
  "    return \"\"\n"
  "  end\n"
  "end\n"
  "\n"
  "local function fsub (str, pattern, repl)\n"
  "  -- gsub always builds a new string in a buffer, even when no match\n"
  "  -- exists. First using find should be more efficient when most strings\n"
  "  -- don't contain the pattern.\n"
  "  if strfind (str, pattern) then\n"
  "    return gsub (str, pattern, repl)\n"
  "  else\n"
  "    return str\n"
  "  end\n"
  "end\n"
  "\n"
  "local function quotestring (value)\n"
  "  -- based on the regexp \"escapable\" in https://github.com/douglascrockford/JSON-js\n"
  "  value = fsub (value, \"[%z\\1-\\31\\\"\\\\\\127]\", escapeutf8)\n"
  "  if strfind (value, \"[\\194\\216\\220\\225\\226\\239]\") then\n"
  "    value = fsub (value, \"\\194[\\128-\\159\\173]\", escapeutf8)\n"
  "    value = fsub (value, \"\\216[\\128-\\132]\", escapeutf8)\n"
  "    value = fsub (value, \"\\220\\143\", escapeutf8)\n"
  "    value = fsub (value, \"\\225\\158[\\180\\181]\", escapeutf8)\n"
  "    value = fsub (value, \"\\226\\128[\\140-\\143\\168-\\175]\", escapeutf8)\n"
  "    value = fsub (value, \"\\226\\129[\\160-\\175]\", escapeutf8)\n"
  "    value = fsub (value, \"\\239\\187\\191\", escapeutf8)\n"
  "    value = fsub (value, \"\\239\\191[\\176-\\191]\", escapeutf8)\n"
  "  end\n"
  "  return \"\\\"\" .. value .. \"\\\"\"\n"
  "end\n"
  "json.quotestring = quotestring\n"
  "\n"
  "local function replace(str, o, n)\n"
  "  local i, j = strfind (str, o, 1, true)\n"
  "  if i then\n"
  "    return strsub(str, 1, i-1) .. n .. strsub(str, j+1, -1)\n"
  "  else\n"
  "    return str\n"
  "  end\n"
  "end\n"
  "\n"
  "-- locale independent num2str and str2num functions\n"
  "local decpoint, numfilter\n"
  "\n"
  "local function updatedecpoint ()\n"
  "  decpoint = strmatch(tostring(0.5), \"([^05+])\")\n"
  "  -- build a filter that can be used to remove group separators\n"
  "  numfilter = \"[^0-9%-%+eE\" .. gsub(decpoint, \"[%^%$%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\") .. \"]+\"\n"
  "end\n"
  "\n"
  "updatedecpoint()\n"
  "\n"
  "local function num2str (num)\n"
  "  return replace(fsub(tostring(num), numfilter, \"\"), decpoint, \".\")\n"
  "end\n"
  "\n"
  "local function str2num (str)\n"
  "  local num = tonumber(replace(str, \".\", decpoint))\n"
  "  if not num then\n"
  "    updatedecpoint()\n"
  "    num = tonumber(replace(str, \".\", decpoint))\n"
  "  end\n"
  "  return num\n"
  "end\n"
  "\n"
  "local function addnewline2 (level, buffer, buflen)\n"
  "  buffer[buflen+1] = \"\\n\"\n"
  "  buffer[buflen+2] = strrep (\"  \", level)\n"
  "  buflen = buflen + 2\n"
  "  return buflen\n"
  "end\n"
  "\n"
  "function json.addnewline (state)\n"
  "  if state.indent then\n"
  "    state.bufferlen = addnewline2 (state.level or 0,\n"
  "                           state.buffer, state.bufferlen or #(state.buffer))\n"
  "  end\n"
  "end\n"
  "\n"
  "local encode2 -- forward declaration\n"
  "\n"
  "local function addpair (key, value, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
  "  local kt = type (key)\n"
  "  if kt ~= 'string' and kt ~= 'number' then\n"
  "    return nil, \"type '\" .. kt .. \"' is not supported as a key by JSON.\"\n"
  "  end\n"
  "  if prev then\n"
  "    buflen = buflen + 1\n"
  "    buffer[buflen] = \",\"\n"
  "  end\n"
  "  if indent then\n"
  "    buflen = addnewline2 (level, buffer, buflen)\n"
  "  end\n"
  "  buffer[buflen+1] = quotestring (key)\n"
  "  buffer[buflen+2] = \":\"\n"
  "  return encode2 (value, indent, level, buffer, buflen + 2, tables, globalorder, state)\n"
  "end\n"
  "\n"
  "local function appendcustom(res, buffer, state)\n"
  "  local buflen = state.bufferlen\n"
  "  if type (res) == 'string' then\n"
  "    buflen = buflen + 1\n"
  "    buffer[buflen] = res\n"
  "  end\n"
  "  return buflen\n"
  "end\n"
  "\n"
  "local function exception(reason, value, state, buffer, buflen, defaultmessage)\n"
  "  defaultmessage = defaultmessage or reason\n"
  "  local handler = state.exception\n"
  "  if not handler then\n"
  "    return nil, defaultmessage\n"
  "  else\n"
  "    state.bufferlen = buflen\n"
  "    local ret, msg = handler (reason, value, state, defaultmessage)\n"
  "    if not ret then return nil, msg or defaultmessage end\n"
  "    return appendcustom(ret, buffer, state)\n"
  "  end\n"
  "end\n"
  "\n"
  "function json.encodeexception(reason, value, state, defaultmessage)\n"
  "  return quotestring(\"<\" .. defaultmessage .. \">\")\n"
  "end\n"
  "\n"
  "encode2 = function (value, indent, level, buffer, buflen, tables, globalorder, state)\n"
  "  local valtype = type (value)\n"
  "  local valmeta = getmetatable (value)\n"
  "  valmeta = type (valmeta) == 'table' and valmeta -- only tables\n"
  "  local valtojson = valmeta and valmeta.__tojson\n"
  "  if valtojson then\n"
  "    if tables[value] then\n"
  "      return exception('reference cycle', value, state, buffer, buflen)\n"
  "    end\n"
  "    tables[value] = true\n"
  "    state.bufferlen = buflen\n"
  "    local ret, msg = valtojson (value, state)\n"
  "    if not ret then return exception('custom encoder failed', value, state, buffer, buflen, msg) end\n"
  "    tables[value] = nil\n"
  "    buflen = appendcustom(ret, buffer, state)\n"
  "  elseif value == nil then\n"
  "    buflen = buflen + 1\n"
  "    buffer[buflen] = \"null\"\n"
  "  elseif valtype == 'number' then\n"
  "    local s\n"
  "    if value ~= value or value >= huge or -value >= huge then\n"
  "      -- This is the behaviour of the original JSON implementation.\n"
  "      s = \"null\"\n"
  "    else\n"
  "      s = num2str (value)\n"
  "    end\n"
  "    buflen = buflen + 1\n"
  "    buffer[buflen] = s\n"
  "  elseif valtype == 'boolean' then\n"
  "    buflen = buflen + 1\n"
  "    buffer[buflen] = value and \"true\" or \"false\"\n"
  "  elseif valtype == 'string' then\n"
  "    buflen = buflen + 1\n"
  "    buffer[buflen] = quotestring (value)\n"
  "  elseif valtype == 'table' then\n"
  "    if tables[value] then\n"
  "      return exception('reference cycle', value, state, buffer, buflen)\n"
  "    end\n"
  "    tables[value] = true\n"
  "    level = level + 1\n"
  "    local isa, n = isarray (value)\n"
  "    if n == 0 and valmeta and valmeta.__jsontype == 'object' then\n"
  "      isa = false\n"
  "    end\n"
  "    local msg\n"
  "    if isa then -- JSON array\n"
  "      buflen = buflen + 1\n"
  "      buffer[buflen] = \"[\"\n"
  "      for i = 1, n do\n"
  "        buflen, msg = encode2 (value[i], indent, level, buffer, buflen, tables, globalorder, state)\n"
  "        if not buflen then return nil, msg end\n"
  "        if i < n then\n"
  "          buflen = buflen + 1\n"
  "          buffer[buflen] = \",\"\n"
  "        end\n"
  "      end\n"
  "      buflen = buflen + 1\n"
  "      buffer[buflen] = \"]\"\n"
  "    else -- JSON object\n"
  "      local prev = false\n"
  "      buflen = buflen + 1\n"
  "      buffer[buflen] = \"{\"\n"
  "      local order = valmeta and valmeta.__jsonorder or globalorder\n"
  "      if order then\n"
  "        local used = {}\n"
  "        n = #order\n"
  "        for i = 1, n do\n"
  "          local k = order[i]\n"
  "          local v = value[k]\n"
  "          if v then\n"
  "            used[k] = true\n"
  "            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
  "            prev = true -- add a seperator before the next element\n"
  "          end\n"
  "        end\n"
  "        for k,v in pairs (value) do\n"
  "          if not used[k] then\n"
  "            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
  "            if not buflen then return nil, msg end\n"
  "            prev = true -- add a seperator before the next element\n"
  "          end\n"
  "        end\n"
  "      else -- unordered\n"
  "        for k,v in pairs (value) do\n"
  "          buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
  "          if not buflen then return nil, msg end\n"
  "          prev = true -- add a seperator before the next element\n"
  "        end\n"
  "      end\n"
  "      if indent then\n"
  "        buflen = addnewline2 (level - 1, buffer, buflen)\n"
  "      end\n"
  "      buflen = buflen + 1\n"
  "      buffer[buflen] = \"}\"\n"
  "    end\n"
  "    tables[value] = nil\n"
  "  else\n"
  "    return exception ('unsupported type', value, state, buffer, buflen,\n"
  "      \"type '\" .. valtype .. \"' is not supported by JSON.\")\n"
  "  end\n"
  "  return buflen\n"
  "end\n"
  "\n"
  "function json.encode (value, state)\n"
  "  state = state or {}\n"
  "  local oldbuffer = state.buffer\n"
  "  local buffer = oldbuffer or {}\n"
  "  state.buffer = buffer\n"
  "  updatedecpoint()\n"
  "  local ret, msg = encode2 (value, state.indent, state.level or 0,\n"
  "                   buffer, state.bufferlen or 0, state.tables or {}, state.keyorder, state)\n"
  "  if not ret then\n"
  "    error (msg, 2)\n"
  "  elseif oldbuffer == buffer then\n"
  "    state.bufferlen = ret\n"
  "    return true\n"
  "  else\n"
  "    state.bufferlen = nil\n"
  "    state.buffer = nil\n"
  "    return concat (buffer)\n"
  "  end\n"
  "end\n"
  "\n"
  "local function loc (str, where)\n"
  "  local line, pos, linepos = 1, 1, 0\n"
  "  while true do\n"
  "    pos = strfind (str, \"\\n\", pos, true)\n"
  "    if pos and pos < where then\n"
  "      line = line + 1\n"
  "      linepos = pos\n"
  "      pos = pos + 1\n"
  "    else\n"
  "      break\n"
  "    end\n"
  "  end\n"
  "  return \"line \" .. line .. \", column \" .. (where - linepos)\n"
  "end\n"
  "\n"
  "local function unterminated (str, what, where)\n"
  "  return nil, strlen (str) + 1, \"unterminated \" .. what .. \" at \" .. loc (str, where)\n"
  "end\n"
  "\n"
  "local function scanwhite (str, pos)\n"
  "  while true do\n"
  "    pos = strfind (str, \"%S\", pos)\n"
  "    if not pos then return nil end\n"
  "    local sub2 = strsub (str, pos, pos + 1)\n"
  "    if sub2 == \"\\239\\187\" and strsub (str, pos + 2, pos + 2) == \"\\191\" then\n"
  "      -- UTF-8 Byte Order Mark\n"
  "      pos = pos + 3\n"
  "    elseif sub2 == \"//\" then\n"
  "      pos = strfind (str, \"[\\n\\r]\", pos + 2)\n"
  "      if not pos then return nil end\n"
  "    elseif sub2 == \"/*\" then\n"
  "      pos = strfind (str, \"*/\", pos + 2)\n"
  "      if not pos then return nil end\n"
  "      pos = pos + 2\n"
  "    else\n"
  "      return pos\n"
  "    end\n"
  "  end\n"
  "end\n"
  "\n"
  "local escapechars = {\n"
  "  [\"\\\"\"] = \"\\\"\", [\"\\\\\"] = \"\\\\\", [\"/\"] = \"/\", [\"b\"] = \"\\b\", [\"f\"] = \"\\f\",\n"
  "  [\"n\"] = \"\\n\", [\"r\"] = \"\\r\", [\"t\"] = \"\\t\"\n"
  "}\n"
  "\n"
  "local function unichar (value)\n"
  "  if value < 0 then\n"
  "    return nil\n"
  "  elseif value <= 0x007f then\n"
  "    return strchar (value)\n"
  "  elseif value <= 0x07ff then\n"
  "    return strchar (0xc0 + floor(value/0x40),\n"
  "                    0x80 + (floor(value) % 0x40))\n"
  "  elseif value <= 0xffff then\n"
  "    return strchar (0xe0 + floor(value/0x1000),\n"
  "                    0x80 + (floor(value/0x40) % 0x40),\n"
  "                    0x80 + (floor(value) % 0x40))\n"
  "  elseif value <= 0x10ffff then\n"
  "    return strchar (0xf0 + floor(value/0x40000),\n"
  "                    0x80 + (floor(value/0x1000) % 0x40),\n"
  "                    0x80 + (floor(value/0x40) % 0x40),\n"
  "                    0x80 + (floor(value) % 0x40))\n"
  "  else\n"
  "    return nil\n"
  "  end\n"
  "end\n"
  "\n"
  "local function scanstring (str, pos)\n"
  "  local lastpos = pos + 1\n"
  "  local buffer, n = {}, 0\n"
  "  while true do\n"
  "    local nextpos = strfind (str, \"[\\\"\\\\]\", lastpos)\n"
  "    if not nextpos then\n"
  "      return unterminated (str, \"string\", pos)\n"
  "    end\n"
  "    if nextpos > lastpos then\n"
  "      n = n + 1\n"
  "      buffer[n] = strsub (str, lastpos, nextpos - 1)\n"
  "    end\n"
  "    if strsub (str, nextpos, nextpos) == \"\\\"\" then\n"
  "      lastpos = nextpos + 1\n"
  "      break\n"
  "    else\n"
  "      local escchar = strsub (str, nextpos + 1, nextpos + 1)\n"
  "      local value\n"
  "      if escchar == \"u\" then\n"
  "        value = tonumber (strsub (str, nextpos + 2, nextpos + 5), 16)\n"
  "        if value then\n"
  "          local value2\n"
  "          if 0xD800 <= value and value <= 0xDBff then\n"
  "            -- we have the high surrogate of UTF-16. Check if there is a\n"
  "            -- low surrogate escaped nearby to combine them.\n"
  "            if strsub (str, nextpos + 6, nextpos + 7) == \"\\\\u\" then\n"
  "              value2 = tonumber (strsub (str, nextpos + 8, nextpos + 11), 16)\n"
  "              if value2 and 0xDC00 <= value2 and value2 <= 0xDFFF then\n"
  "                value = (value - 0xD800)  * 0x400 + (value2 - 0xDC00) + 0x10000\n"
  "              else\n"
  "                value2 = nil -- in case it was out of range for a low surrogate\n"
  "              end\n"
  "            end\n"
  "          end\n"
  "          value = value and unichar (value)\n"
  "          if value then\n"
  "            if value2 then\n"
  "              lastpos = nextpos + 12\n"
  "            else\n"
  "              lastpos = nextpos + 6\n"
  "            end\n"
  "          end\n"
  "        end\n"
  "      end\n"
  "      if not value then\n"
  "        value = escapechars[escchar] or escchar\n"
  "        lastpos = nextpos + 2\n"
  "      end\n"
  "      n = n + 1\n"
  "      buffer[n] = value\n"
  "    end\n"
  "  end\n"
  "  if n == 1 then\n"
  "    return buffer[1], lastpos\n"
  "  elseif n > 1 then\n"
  "    return concat (buffer), lastpos\n"
  "  else\n"
  "    return \"\", lastpos\n"
  "  end\n"
  "end\n"
  "\n"
  "local scanvalue -- forward declaration\n"
  "\n"
  "local function scantable (what, closechar, str, startpos, nullval, objectmeta, arraymeta)\n"
  "  local len = strlen (str)\n"
  "  local tbl, n = {}, 0\n"
  "  local pos = startpos + 1\n"
  "  if what == 'object' then\n"
  "    setmetatable (tbl, objectmeta)\n"
  "  else\n"
  "    setmetatable (tbl, arraymeta)\n"
  "  end\n"
  "  while true do\n"
  "    pos = scanwhite (str, pos)\n"
  "    if not pos then return unterminated (str, what, startpos) end\n"
  "    local char = strsub (str, pos, pos)\n"
  "    if char == closechar then\n"
  "      return tbl, pos + 1\n"
  "    end\n"
  "    local val1, err\n"
  "    val1, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
  "    if err then return nil, pos, err end\n"
  "    pos = scanwhite (str, pos)\n"
  "    if not pos then return unterminated (str, what, startpos) end\n"
  "    char = strsub (str, pos, pos)\n"
  "    if char == \":\" then\n"
  "      if val1 == nil then\n"
  "        return nil, pos, \"cannot use nil as table index (at \" .. loc (str, pos) .. \")\"\n"
  "      end\n"
  "      pos = scanwhite (str, pos + 1)\n"
  "      if not pos then return unterminated (str, what, startpos) end\n"
  "      local val2\n"
  "      val2, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
  "      if err then return nil, pos, err end\n"
  "      tbl[val1] = val2\n"
  "      pos = scanwhite (str, pos)\n"
  "      if not pos then return unterminated (str, what, startpos) end\n"
  "      char = strsub (str, pos, pos)\n"
  "    else\n"
  "      n = n + 1\n"
  "      tbl[n] = val1\n"
  "    end\n"
  "    if char == \",\" then\n"
  "      pos = pos + 1\n"
  "    end\n"
  "  end\n"
  "end\n"
  "\n"
  "scanvalue = function (str, pos, nullval, objectmeta, arraymeta)\n"
  "  pos = pos or 1\n"
  "  pos = scanwhite (str, pos)\n"
  "  if not pos then\n"
  "    return nil, strlen (str) + 1, \"no valid JSON value (reached the end)\"\n"
  "  end\n"
  "  local char = strsub (str, pos, pos)\n"
  "  if char == \"{\" then\n"
  "    return scantable ('object', \"}\", str, pos, nullval, objectmeta, arraymeta)\n"
  "  elseif char == \"[\" then\n"
  "    return scantable ('array', \"]\", str, pos, nullval, objectmeta, arraymeta)\n"
  "  elseif char == \"\\\"\" then\n"
  "    return scanstring (str, pos)\n"
  "  else\n"
  "    local pstart, pend = strfind (str, \"^%-?[%d%.]+[eE]?[%+%-]?%d*\", pos)\n"
  "    if pstart then\n"
  "      local number = str2num (strsub (str, pstart, pend))\n"
  "      if number then\n"
  "        return number, pend + 1\n"
  "      end\n"
  "    end\n"
  "    pstart, pend = strfind (str, \"^%a%w*\", pos)\n"
  "    if pstart then\n"
  "      local name = strsub (str, pstart, pend)\n"
  "      if name == \"true\" then\n"
  "        return true, pend + 1\n"
  "      elseif name == \"false\" then\n"
  "        return false, pend + 1\n"
  "      elseif name == \"null\" then\n"
  "        return nullval, pend + 1\n"
  "      end\n"
  "    end\n"
  "    return nil, pos, \"no valid JSON value at \" .. loc (str, pos)\n"
  "  end\n"
  "end\n"
  "\n"
  "local function optionalmetatables(...)\n"
  "  if select(\"#\", ...) > 0 then\n"
  "    return ...\n"
  "  else\n"
  "    return {__jsontype = 'object'}, {__jsontype = 'array'}\n"
  "  end\n"
  "end\n"
  "\n"
  "function json.decode (str, pos, nullval, ...)\n"
  "  local objectmeta, arraymeta = optionalmetatables(...)\n"
  "  return scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
  "end\n"
  "\n"
  "function json.use_lpeg ()\n"
  "  local g = require (\"lpeg\")\n"
  "\n"
  "  if g.version() == \"0.11\" then\n"
  "    error \"due to a bug in LPeg 0.11, it cannot be used for JSON matching\"\n"
  "  end\n"
  "\n"
  "  local pegmatch = g.match\n"
  "  local P, S, R = g.P, g.S, g.R\n"
  "\n"
  "  local function ErrorCall (str, pos, msg, state)\n"
  "    if not state.msg then\n"
  "      state.msg = msg .. \" at \" .. loc (str, pos)\n"
  "      state.pos = pos\n"
  "    end\n"
  "    return false\n"
  "  end\n"
  "\n"
  "  local function Err (msg)\n"
  "    return g.Cmt (g.Cc (msg) * g.Carg (2), ErrorCall)\n"
  "  end\n"
  "\n"
  "  local SingleLineComment = P\"//\" * (1 - S\"\\n\\r\")^0\n"
  "  local MultiLineComment = P\"/*\" * (1 - P\"*/\")^0 * P\"*/\"\n"
  "  local Space = (S\" \\n\\r\\t\" + P\"\\239\\187\\191\" + SingleLineComment + MultiLineComment)^0\n"
  "\n"
  "  local PlainChar = 1 - S\"\\\"\\\\\\n\\r\"\n"
  "  local EscapeSequence = (P\"\\\\\" * g.C (S\"\\\"\\\\/bfnrt\" + Err \"unsupported escape sequence\")) / escapechars\n"
  "  local HexDigit = R(\"09\", \"af\", \"AF\")\n"
  "  local function UTF16Surrogate (match, pos, high, low)\n"
  "    high, low = tonumber (high, 16), tonumber (low, 16)\n"
  "    if 0xD800 <= high and high <= 0xDBff and 0xDC00 <= low and low <= 0xDFFF then\n"
  "      return true, unichar ((high - 0xD800)  * 0x400 + (low - 0xDC00) + 0x10000)\n"
  "    else\n"
  "      return false\n"
  "    end\n"
  "  end\n"
  "  local function UTF16BMP (hex)\n"
  "    return unichar (tonumber (hex, 16))\n"
  "  end\n"
  "  local U16Sequence = (P\"\\\\u\" * g.C (HexDigit * HexDigit * HexDigit * HexDigit))\n"
  "  local UnicodeEscape = g.Cmt (U16Sequence * U16Sequence, UTF16Surrogate) + U16Sequence/UTF16BMP\n"
  "  local Char = UnicodeEscape + EscapeSequence + PlainChar\n"
  "  local String = P\"\\\"\" * g.Cs (Char ^ 0) * (P\"\\\"\" + Err \"unterminated string\")\n"
  "  local Integer = P\"-\"^(-1) * (P\"0\" + (R\"19\" * R\"09\"^0))\n"
  "  local Fractal = P\".\" * R\"09\"^0\n"
  "  local Exponent = (S\"eE\") * (S\"+-\")^(-1) * R\"09\"^1\n"
  "  local Number = (Integer * Fractal^(-1) * Exponent^(-1))/str2num\n"
  "  local Constant = P\"true\" * g.Cc (true) + P\"false\" * g.Cc (false) + P\"null\" * g.Carg (1)\n"
  "  local SimpleValue = Number + String + Constant\n"
  "  local ArrayContent, ObjectContent\n"
  "\n"
  "  -- The functions parsearray and parseobject parse only a single value/pair\n"
  "  -- at a time and store them directly to avoid hitting the LPeg limits.\n"
  "  local function parsearray (str, pos, nullval, state)\n"
  "    local obj, cont\n"
  "    local npos\n"
  "    local t, nt = {}, 0\n"
  "    repeat\n"
  "      obj, cont, npos = pegmatch (ArrayContent, str, pos, nullval, state)\n"
  "      if not npos then break end\n"
  "      pos = npos\n"
  "      nt = nt + 1\n"
  "      t[nt] = obj\n"
  "    until cont == 'last'\n"
  "    return pos, setmetatable (t, state.arraymeta)\n"
  "  end\n"
  "\n"
  "  local function parseobject (str, pos, nullval, state)\n"
  "    local obj, key, cont\n"
  "    local npos\n"
  "    local t = {}\n"
  "    repeat\n"
  "      key, obj, cont, npos = pegmatch (ObjectContent, str, pos, nullval, state)\n"
  "      if not npos then break end\n"
  "      pos = npos\n"
  "      t[key] = obj\n"
  "    until cont == 'last'\n"
  "    return pos, setmetatable (t, state.objectmeta)\n"
  "  end\n"
  "\n"
  "  local Array = P\"[\" * g.Cmt (g.Carg(1) * g.Carg(2), parsearray) * Space * (P\"]\" + Err \"']' expected\")\n"
  "  local Object = P\"{\" * g.Cmt (g.Carg(1) * g.Carg(2), parseobject) * Space * (P\"}\" + Err \"'}' expected\")\n"
  "  local Value = Space * (Array + Object + SimpleValue)\n"
  "  local ExpectedValue = Value + Space * Err \"value expected\"\n"
  "  ArrayContent = Value * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
  "  local Pair = g.Cg (Space * String * Space * (P\":\" + Err \"colon expected\") * ExpectedValue)\n"
  "  ObjectContent = Pair * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
  "  local DecodeValue = ExpectedValue * g.Cp ()\n"
  "\n"
  "  function json.decode (str, pos, nullval, ...)\n"
  "    local state = {}\n"
  "    state.objectmeta, state.arraymeta = optionalmetatables(...)\n"
  "    local obj, retpos = pegmatch (DecodeValue, str, pos, nullval, state)\n"
  "    if state.msg then\n"
  "      return nil, state.pos, state.msg\n"
  "    else\n"
  "      return obj, retpos\n"
  "    end\n"
  "  end\n"
  "\n"
  "  -- use this function only once:\n"
  "  json.use_lpeg = function () return json end\n"
  "\n"
  "  json.using_lpeg = true\n"
  "\n"
  "  return json -- so you can get the module using json = require \"dkjson\".use_lpeg()\n"
  "end\n"
  "\n"
  "if always_try_using_lpeg then\n"
  "  pcall (json.use_lpeg)\n"
  "end\n"
  "\n"
  "return json\n"
  "\n"
};

