#include <ngx_wafflex_nginx_lua_scripts.h>

wfx_lua_scripts_t wfx_lua_scripts = {
  {"init", 
   "--lua environs initializer\n"
   "\n"
   "--luacheck: globals Parser Ruleset Binding\n"
   "--luacheck: globals parseRulesetFile deferRulesetCreation createDeferredRulesets\n"
   "--luacheck: globals deferRulesetRedisLoad loadDeferredRedisRulesets\n"
   "--luacheck: globals shutdown printFunctions\n"
   "--luacheck: globals findRuleset\n"
   "\n"
   "--luacheck: globals getRedisRulesetJSON redisRulesetSubscribe redisRulesetUnsubscribe --external crud\n"
   "\n"
   "--setup package loading\n"
   "local package_loader\n"
   "package.path = \"\"\n"
   "package.cpath= \"\"\n"
   "setmetatable(package.preload, {__index = function(self, name)\n"
   "  local pkg = package_loader(name)\n"
   "  local loader\n"
   "  if pkg then\n"
   "    loader = function()\n"
   "      return pkg\n"
   "    end\n"
   "    self[name]=loader\n"
   "  end\n"
   "  return loader\n"
   "end})\n"
   "\n"
   "\n"
   "return function(package_loader_cfunc, manager, init_bind_cfunc, ruleset_confset_cfunc)\n"
   "  package_loader = package_loader_cfunc\n"
   "  \n"
   "  local rulesets = {}\n"
   "  \n"
   "  Parser = require \"parser\"\n"
   "  Ruleset = require \"ruleset\"\n"
   "  Binding = require \"binding\"\n"
   "  local mm = require \"mm\"\n"
   "  \n"
   "  function findRuleset(name)\n"
   "    return rulesets[name]\n"
   "  end\n"
   "  \n"
   "  do\n"
   "    local ruleset_n = 0\n"
   "    local function uniqueName(thing, thingtbl, ruleset)\n"
   "      local name\n"
   "      if ruleset then\n"
   "        if not ruleset.__n then\n"
   "          ruleset.__n = 0\n"
   "        else\n"
   "          ruleset.__n = ruleset.__n + 1\n"
   "        end\n"
   "        name = (\"%s%i\"):format(thing, ruleset.__n)\n"
   "        if thingtbl[name] then --oh no it's not unique. try again\n"
   "          return uniqueName(thing, thingtbl, ruleset)\n"
   "        else\n"
   "          return name\n"
   "        end\n"
   "      else\n"
   "        assert(thing == \"ruleset\")\n"
   "        ruleset_n = ruleset_n + 1\n"
   "        name = \"ruleset\"..ruleset_n\n"
   "        if rulesets[name] then  --oh no it's not unique. try again\n"
   "          return uniqueName(thing, thingtbl, ruleset)\n"
   "        else\n"
   "          return name\n"
   "        end\n"
   "      end\n"
   "    end\n"
   "    Ruleset.uniqueName = uniqueName\n"
   "  end\n"
   "  \n"
   "  \n"
   "  Binding.require_create_userdata = true\n"
   "  Binding.require_binding = true\n"
   "  \n"
   "  --local mm = require \"mm\"\n"
   "  \n"
   "  if init_bind_cfunc then\n"
   "    init_bind_cfunc(Binding.set)\n"
   "  end\n"
   "  \n"
   "  if manager then\n"
   "    local parsed_ruleset_data = {}\n"
   "    \n"
   "    function parseRulesetFile(prefix, path, ruleset_name)\n"
   "      local p = Parser.new()\n"
   "      \n"
   "      local fullpath\n"
   "      if path:match(\"^/\") then\n"
   "        fullpath = path\n"
   "      elseif prefix then\n"
   "        fullpath = (prefix:match(\"/$\") and \"%s%s\" or \"%s/%s\"):format(prefix, path)\n"
   "      end\n"
   "      \n"
   "      local res, err = p:parseFile(fullpath)\n"
   "      if not res then\n"
   "        return nil, err\n"
   "      end\n"
   "      \n"
   "      if ruleset_name then\n"
   "        res.name = ruleset_name\n"
   "      end\n"
   "      if not res.name then\n"
   "        local filename = path:match(\"[^/]+$\")\n"
   "        local sansext = filename:match(\"(.*)%.[^.]+$\")\n"
   "        filename = sansext or filename\n"
   "        res.name = filename\n"
   "      end\n"
   "      \n"
   "      if res.name and parsed_ruleset_data[res.name] then\n"
   "        return nil, (\"ruleset \\\"%s\\\" already exists\"):format(res.name)\n"
   "      end\n"
   "      parsed_ruleset_data[res.name] = res\n"
   "      \n"
   "      return res\n"
   "    end\n"
   "    \n"
   "    local deferred = setmetatable({}, {__index = function(t,k)\n"
   "      t[k]={}\n"
   "      return t[k]\n"
   "    end})\n"
   "  \n"
   "    function deferRulesetCreation(name, conf_ptr)\n"
   "      if not parsed_ruleset_data[name] then\n"
   "        return nil, (\"unknown ruleset \\\"%s\\\"\"):format(name)\n"
   "      end\n"
   "      table.insert(deferred[name], conf_ptr)\n"
   "      return true\n"
   "    end\n"
   "    \n"
   "    local function createRuleset(parsed_data)\n"
   "      local rs = Ruleset.new(parsed_data)\n"
   "      assert(rulesets[rs.name] == nil)\n"
   "      rulesets[rs.name] = rs\n"
   "      return rs\n"
   "    end\n"
   "    \n"
   "    function createDeferredRulesets()\n"
   "      for name, def in pairs(deferred) do\n"
   "        local ruleset = createRuleset(parsed_ruleset_data[name])\n"
   "        for _, conf_ptr in pairs(def) do\n"
   "          ruleset_confset_cfunc(ruleset, conf_ptr)\n"
   "        end\n"
   "      end\n"
   "      deferred = setmetatable({}, getmetatable(deferred)) -- clear 'deferred' table\n"
   "    end\n"
   "    \n"
   "    local deferred_redis_rulesets = setmetatable({}, {__index = function(t,k)\n"
   "      t[k]={}\n"
   "      return t[k]\n"
   "    end})\n"
   "    \n"
   "    function deferRulesetRedisLoad(name, loc_conf_ptr, conf_ptr)\n"
   "      table.insert(deferred_redis_rulesets[name], {lcf_ptr=loc_conf_ptr, rcf_ptr = conf_ptr})\n"
   "      return true\n"
   "    end\n"
   "    \n"
   "    function loadDeferredRedisRulesets()\n"
   "      local co = coroutine.wrap(function()\n"
   "        local ruleset_json, parser, parsed, ruleset, err\n"
   "        for name, rs in pairs(deferred_redis_rulesets) do\n"
   "          for _, config in ipairs(rs) do\n"
   "            if rulesets[name] then\n"
   "              ruleset = rulesets[name]\n"
   "            else\n"
   "              redisRulesetSubscribe(config.lcf_ptr, name)\n"
   "              ruleset_json, err = getRedisRulesetJSON(config.lcf_ptr, name)\n"
   "              if not ruleset_json then\n"
   "                redisRulesetUnsubscribe(config.lcf_ptr, name)\n"
   "                error(err)\n"
   "              end\n"
   "              print(ruleset_json)\n"
   "              parser = Parser.new()\n"
   "              parsed, err = parser:parseJSON(\"ruleset\", ruleset_json, name, true)\n"
   "              if not parsed then error(err) end\n"
   "              ruleset = createRuleset(parsed)\n"
   "              mm(ruleset)\n"
   "            end\n"
   "            ruleset_confset_cfunc(ruleset, config.rcf_ptr)\n"
   "          end\n"
   "        end\n"
   "      end)\n"
   "      co()\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function shutdown(is_manager)\n"
   "    if is_manager then\n"
   "      for name, ruleset in pairs(rulesets) do\n"
   "        print(\"kill a ruleset named \" .. name)\n"
   "        ruleset:destroy()\n"
   "      end\n"
   "    end\n"
   "    rulesets = {}\n"
   "  end\n"
   "\n"
   "  function printFunctions(pattern)\n"
   "    for k,v in pairs(_G) do\n"
   "      if type(v) == \"function\" then\n"
   "        if not pattern or k:match(pattern) then\n"
   "          local info = debug.getinfo(v)\n"
   "          print((\"%s: function %s (%s %s %s:%i-%i)\"):format(tostring(k), tostring(v), info.what, info.namewhat, info.short_src, info.linedefined, info.lastlinedefined))\n"
   "        end\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "end\n"},

  {"ipc", 
   "local handlers = {}\n"
   "local rawget = rawget\n"
   "--luacheck: globals setAlertHandler getAlertHandler\n"
   "function setAlertHandler(name, callback)\n"
   "  rawset(handlers, name, callback)\n"
   "end\n"
   "function getAlertHandler(name, data_ptr)\n"
   "  return rawget(handlers, name)\n"
   "end\n"},

  {"limiter", 
   "\n"
   "--luacheck: globals findLimiterValue setLimiterValue unsetLimiterValue\n"
   "--local mm = require \"mm\"\n"
   "local setmetatable, rawset, rawget = setmetatable, rawset, rawget\n"
   "\n"
   "local function tabling_meta(depth, ephemeron)\n"
   "  return {__index = function(t,k)\n"
   "    local v = {}\n"
   "    if depth > 0 then\n"
   "      setmetatable(v, tabling_meta(depth-1, type(ephemeron) == \"number\" and ephemeron-1 or ephemeron))\n"
   "    end\n"
   "    t[k]=v\n"
   "    return v\n"
   "  end, __mode = (ephemeron == true or (ephemeron and ephemeron > 0)) and \"k\" or nil }\n"
   "end\n"
   "\n"
   "local limiters = setmetatable({}, tabling_meta(2))\n"
   "\n"
   "function findLimiterValue(limiter_ptr, key)\n"
   "  local limit = rawget(limiters, limiter_ptr)\n"
   "  if not limit then\n"
   "    return nil\n"
   "  end\n"
   "  local data = rawget(limit, key)\n"
   "  if not data then\n"
   "    return nil\n"
   "  end\n"
   "  return data\n"
   "end\n"
   "\n"
   "function setLimiterValue(limiter_ptr, key, limit_data_ptr)\n"
   "  limiters[limiter_ptr][key]=limit_data_ptr\n"
   "  \n"
   "  --check uniqueness\n"
   "  --[[\n"
   "  local uniq = {}\n"
   "  mm(limiters[limiter_ptr])\n"
   "  for k, v in pairs(limiters[limiter_ptr]) do\n"
   "    assert(not uniq[v], \"found two different keys mapping to same limiter value\")\n"
   "    uniq[v] = true\n"
   "  end\n"
   "  ]]\n"
   "  \n"
   "  return limit_data_ptr\n"
   "end\n"
   "  \n"
   "function unsetLimiterValue(limiter_ptr, key, limit_data_ptr)\n"
   "  --mm(limiters)\n"
   "  local limit = rawget(limiters, limiter_ptr)\n"
   "  local data = rawget(limit, key)\n"
   "  if data then\n"
   "    assert(type(data) == \"userdata\")\n"
   "    if limit_data_ptr then\n"
   "      assert(data == limit_data_ptr)\n"
   "    end\n"
   "    rawset(limit, key, nil)\n"
   "    if next(limit) == nil then\n"
   "      rawset(limiters, limiter_ptr, nil)\n"
   "    end\n"
   "    return true\n"
   "  else\n"
   "    return nil\n"
   "  end\n"
   "end\n"
   "\n"},

  {"redis", 
   "local Redis = require \"redis\"\n"
   "--local mm = require \"mm\"\n"
   "local json = require \"dkjson\"\n"
   "local Parser = require \"parser\"\n"
   "\n"
   "--luacheck: globals registerRedis connectRedises testRedisConnector findRedis getRedisRulesetJSON redisRulesetSubscribe redisRulesetUnsubscribe findRuleset\n"
   "\n"
   "local function parseRedisUrl(url)\n"
   "  local host, port, pass, db\n"
   "  local rest\n"
   "  \n"
   "  url = url:match(\"^redis://(.*)\") or url\n"
   "  pass, rest = url:match(\"^:([^@]+)@(.*)\")\n"
   "  if pass then url = rest end\n"
   "  host, rest = url:match(\"^([^:/]+)(.*)\")\n"
   "  if host then url = rest end\n"
   "  port, rest = url:match(\"^:(%d+)(.*)\")\n"
   "  if port then port=tonumber(port); url = rest end\n"
   "  db = url:match(\"^/(%d+)\")\n"
   "  if db then db = tonumber(db) end\n"
   "  \n"
   "  local ret = {\n"
   "    url=(\"redis://%s%s:%i%s\"):format(pass and \":\"..pass..\"@\" or \"\", host, port, db and \"/\"..db or \"\"),\n"
   "    host = host,\n"
   "    port = port,\n"
   "    pass = pass,\n"
   "    db = db\n"
   "  }\n"
   "  \n"
   "  return ret\n"
   "end\n"
   "\n"
   "local redises = {}\n"
   "local redis_conf = {}\n"
   "\n"
   "function findRedis(conf_ptr)\n"
   "  return redis_conf[conf_ptr]\n"
   "end\n"
   "\n"
   "function registerRedis(url, conf_ptr)\n"
   "  local exists = redises[url]\n"
   "  if exists then\n"
   "    table.insert(exists.conf_ptrs, conf_ptr)\n"
   "    redis_conf[conf_ptr]=exists\n"
   "    return exists\n"
   "  end\n"
   "  \n"
   "  local parsedUrl = parseRedisUrl(url)\n"
   "  \n"
   "  local r = Redis.new(parsedUrl.host, parsedUrl.port, parsedUrl.pass, parsedUrl.db)\n"
   "  redises[parsedUrl.url]=r\n"
   "  \n"
   "  if not r.conf_ptrs then\n"
   "    r.conf_ptrs = {}\n"
   "  end\n"
   "  table.insert(r.conf_ptrs, conf_ptr)\n"
   "  redis_conf[conf_ptr]=r\n"
   "  return parsedUrl.url\n"
   "end\n"
   "\n"
   "function connectRedises()\n"
   "  for _, r in pairs(redises) do\n"
   "    r:connect()\n"
   "  end\n"
   "end\n"
   "\n"
   "function getRedisRulesetJSON(conf_ptr, ruleset_name)\n"
   "  local redis = findRedis(conf_ptr)\n"
   "  if not redis then return nil, \"no redis found for conf_ptr \" .. tostring(conf_ptr) end\n"
   "  local ruleset_json, err  = redis:script(\"ruleset_read\", \"\", ruleset_name,  \"ruleset\")\n"
   "  if ruleset_json == 0 then\n"
   "    return nil, err\n"
   "  else\n"
   "    return ruleset_json\n"
   "  end\n"
   "end\n"
   "\n"
   "function redisRulesetSubscribe(conf_ptr, ruleset_name)\n"
   "  local redis = findRedis(conf_ptr)\n"
   "  if not redis then return nil, \"no redis found for conf_ptr \" .. tostring(conf_ptr) end\n"
   "  --TODO: prefix\n"
   "  \n"
   "  local updater = function(data)\n"
   "    local parser = Parser.new()\n"
   "    local ruleset = findRuleset(ruleset_name)\n"
   "    if not ruleset then\n"
   "      error(\"can't find ruleset \" .. ruleset_name)\n"
   "    end\n"
   "    local msg = json.decode(data, 1, json.null, nil)\n"
   "    if msg.action == \"create\" then\n"
   "      --create stuff\n"
   "      if msg.type == \"rule\" then\n"
   "        local rule = parser:parseJSON(\"rule\", msg.data)\n"
   "        rule.name = msg.name\n"
   "        ruleset:addRule(rule)\n"
   "      end\n"
   "    elseif msg.action == \"update\" then\n"
   "      if msg.type == \"rule\" then\n"
   "        local rule = parser:parseJSON(\"rule\", msg.data)\n"
   "        rule.name = msg.name\n"
   "        ruleset:updateRule(rule)\n"
   "      else\n"
   "        error(\"don't know what to do\")\n"
   "      end\n"
   "    else\n"
   "      error(\"don't know what action this is\")\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  return redis:subscribe((\"ruleset:%s:pubsub\"):format(ruleset_name), updater)\n"
   "end\n"
   "function redisRulesetUnsubscribe(conf_ptr, ruleset_name)\n"
   "  local redis = findRedis(conf_ptr)\n"
   "  if not redis then return nil, \"no redis found for conf_ptr \" .. tostring(conf_ptr) end\n"
   "  return redis:unsubscribe((\"ruleset:%s:pubsub\"):format(ruleset_name))\n"
   "end\n"
   "\n"
   "function testRedisConnector()\n"
   "  local r = Redis.new(\"localhost\", 8537, nil, 2)\n"
   "  coroutine.wrap(function()\n"
   "    print(r:connect())\n"
   "    \n"
   "    local tend = os.clock() + 3\n"
   "    while os.clock()<tend do\n"
   "    --nothing\n"
   "    end\n"
   "    \n"
   "    print(r:script(\"init\"))\n"
   "    \n"
   "    r:subscribe(\"channel2\", function(msg, channel)\n"
   "      print(\"SUBSCRIBE2 GOT\")\n"
   "      r:unsubscribe(\"channel1\")\n"
   "    end)\n"
   "    \n"
   "    r:subscribe(\"channel1\", function(msg, channel)\n"
   "      print(\"SUBSCRIBE GOT\")\n"
   "      print(msg, channel)\n"
   "    end)\n"
   "    \n"
   "    print(\"OKAY THEN\")\n"
   "  end)()\n"
   "end\n"
   "\n"
   "return function(redis_connect, redis_close, redis_command, get_hiredis_asyncContext_peername, timeout, log_error, scripts)\n"
   "  assert(type(redis_connect) == \"function\")\n"
   "  assert(type(redis_command) == \"function\")\n"
   "  assert(type(timeout) == \"function\")\n"
   "  Redis.c.redis_connect = redis_connect\n"
   "  Redis.c.redis_close = redis_close\n"
   "  Redis.c.redis_command = redis_command\n"
   "  Redis.c.timeout = timeout\n"
   "  Redis.c.get_hiredis_asyncContext_peername = get_hiredis_asyncContext_peername\n"
   "  Redis.c.log_error = log_error\n"
   "  for _, script in ipairs(scripts) do\n"
   "    Redis.addScript(script.name, script.hash, script.src)\n"
   "  end\n"
   "end\n"},

  {"tag", 
   "local tags = {}\n"
   "local rawset, rawget = rawset, rawget\n"
   "\n"
   "--luacheck: globals findTag setTag clearTags\n"
   "\n"
   "function findTag(ref, key)\n"
   "  local mytags = rawget(tags, ref)\n"
   "  return mytags and rawget(mytags, key) or nil\n"
   "end\n"
   "\n"
   "function setTag(ref, key)\n"
   "  local mytags = rawget(tags, ref)\n"
   "  if not mytags then\n"
   "    rawset(tags, ref, {[key]=true})\n"
   "    return true\n"
   "  else\n"
   "    rawset(mytags, key, true)\n"
   "    return nil\n"
   "  end\n"
   "end\n"
   "function clearTags(ref)\n"
   "  rawset(tags, ref, nil)\n"
   "end\n"},

  {"tracer", 
   "local mm = require \"mm\"\n"
   "--luacheck: globals newTracer getTracer\n"
   "local ngx = {}\n"
   "\n"
   "local tracers = {}\n"
   "  \n"
   "local Tracer = {}\n"
   "local tracer_mt = {__index = Tracer}\n"
   "\n"
   "local function tracerCleaner(ref)\n"
   "  print(\"CLEANED UP AFTER TRACER\")\n"
   "  tracers[ref] = nil\n"
   "end\n"
   "\n"
   "function newTracer(ref_type, req_ref)\n"
   "  local tracer = {\n"
   "    stack = {},\n"
   "    complete = {},\n"
   "    defer = 0,\n"
   "    cur = 0,\n"
   "    \n"
   "    profile = true\n"
   "  }\n"
   "  setmetatable(tracer, tracer_mt)\n"
   "  tracers[req_ref] = tracer\n"
   "  if ref_type == \"request\" then\n"
   "    ngx.add_request_cleanup_handler(req_ref, tracerCleaner)\n"
   "  else\n"
   "    error(\"don't know how to do this\")\n"
   "  end\n"
   "  \n"
   "  return tracer\n"
   "end\n"
   "\n"
   "function getTracer(ref_type, req_ref)\n"
   "  local tracer =  tracers[req_ref] or newTracer(ref_type, req_ref)\n"
   "  --mm(tracer)\n"
   "  return tracer\n"
   "end\n"
   "\n"
   "function Tracer:push(element, el_name, el_gen, el_ref)\n"
   "  print(\"pushing\", element, el_name, \"defer:\", self.defer)\n"
   "  self.cur = self.cur + 1\n"
   "  local el\n"
   "  if self.defer == 0 then\n"
   "    el = {\n"
   "      type = element,\n"
   "      name = el_name,\n"
   "      --gen = el_gen,\n"
   "      --ref = el_ref,\n"
   "      \n"
   "      time = { }\n"
   "    }\n"
   "    if self.profile then\n"
   "      el.time.start = ngx.time_msec()\n"
   "    end\n"
   "    table.insert(self.stack, self.cur, el)\n"
   "  else\n"
   "    el = self.stack[self.cur]\n"
   "    self.defer = self.defer - 1\n"
   "    assert(el.deferred)\n"
   "    --assert(el.ref == el_ref)\n"
   "    el.deferred = nil\n"
   "    if el.time.defer_start then\n"
   "      el.time.defer = (el.time.defer or 0) + (ngx.time_msec() - el.time.defer_start)\n"
   "      el.time.defer_start = nil\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "function Tracer:pop(element, rc, ...)\n"
   "  local el\n"
   "  print(\"popping\", element, rc)\n"
   "  if rc == \"defer\" then\n"
   "    self.defer = self.defer + 1\n"
   "    el = self.stack[self.cur]\n"
   "    assert(el.type == element)\n"
   "    el.deferred = true\n"
   "    if self.profile then\n"
   "      el.time.defer_start = ngx.time_msec()\n"
   "    end\n"
   "    if el.time.start then\n"
   "      el.time.run = el.time.run or 0 + (ngx.time_msec() - el.time.start)\n"
   "      el.time.start = nil\n"
   "    end\n"
   "  else\n"
   "    el = self.stack[self.cur]\n"
   "    assert(el.type == element)\n"
   "    el.result = rc\n"
   "    if rc == \"error\" then\n"
   "      el.error = ({...})[1]\n"
   "    end\n"
   "    if el.time.start then\n"
   "      el.time.run = el.time.run or 0 + (ngx.time_msec() - el.time.start)\n"
   "      el.time.total = el.time.run + (el.time.defer or 0)\n"
   "      el.time.start = nil\n"
   "    end\n"
   "    table.remove(self.stack, self.cur)\n"
   "    self:completeElement(el);\n"
   "  end\n"
   "  self.cur = self.cur - 1\n"
   "end\n"
   "\n"
   "function Tracer:log(data_name, data)\n"
   "  local el = self.stack[self.cur]\n"
   "  if not el.data then el.data = {} end\n"
   "  el.data[data_name]=data\n"
   "end\n"
   "\n"
   "function Tracer:log_array(data_name, data)\n"
   "  local el = self.stack[self.cur]\n"
   "  if not el.data then el.data = {} end\n"
   "  if not el.data[data_name] then\n"
   "    el.data[data_name] = {}\n"
   "  end\n"
   "  table.insert(el.data[data_name], data)\n"
   "end\n"
   "\n"
   "local parent_type = {\n"
   "  condition=  \"rule\",\n"
   "  action=     \"rule\",\n"
   "  rule=       \"list\",\n"
   "  list=       \"phase\",\n"
   "  phase=      \"ruleset\",\n"
   "  ruleset=    \"root\"\n"
   "}\n"
   "\n"
   "function Tracer:getTop(element)\n"
   "  mm(self.stack)\n"
   "  if element == \"root\" then\n"
   "    return self.complete\n"
   "  end\n"
   "  local cur\n"
   "  for i = #self.stack, 1, -1 do\n"
   "    cur = self.stack[i]\n"
   "    if cur.type == element then\n"
   "      return cur\n"
   "    end\n"
   "  end\n"
   "  error(\"element type \" .. element .. \" not found in stack\")\n"
   "end\n"
   "\n"
   "function Tracer:completeElement(el)\n"
   "  local parent = self:getTop(parent_type[el.type])\n"
   "  if not parent[el.type] then parent[el.type]={} end\n"
   "  table.insert(parent[el.type], el)\n"
   "end\n"
   "\n"
   "function Tracer:finish()\n"
   "  if self.defer >  0 then\n"
   "    return\n"
   "  end\n"
   "  mm(self)\n"
   "end\n"
   "\n"
   "return function(ngx_cached_msec_time, ngx_cached_time, ngx_add_request_cleanup_handler, ngx_error_log)\n"
   "  ngx.time_msec = function()\n"
   "    local sec, msec = ngx_cached_msec_time()\n"
   "    return sec + msec/1000\n"
   "  end\n"
   "  ngx.time_cached = ngx_cached_time\n"
   "  ngx.error_log = ngx_error_log\n"
   "  ngx.add_request_cleanup_handler = ngx_add_request_cleanup_handler\n"
   "end\n"},

  {"util", 
   "local reqs = {}\n"
   "--luacheck: globals trackPtr getTrackedPtr untrackPtr\n"
   "function trackPtr(request_ptr, data)\n"
   "  local first_time = reqs[request_ptr] == nil\n"
   "  reqs[request_ptr] = true\n"
   "  return first_time\n"
   "end\n"
   "\n"
   "function getTrackedPtr(request_ptr)\n"
   "  return reqs[request_ptr]\n"
   "end\n"
   "\n"
   "function untrackPtr(request_ptr)\n"
   "  reqs[request_ptr]=nil\n"
   "end\n"}
};
wfx_module_lua_scripts_t wfx_module_lua_scripts = {
  {"binding", 
   "local binds = {}\n"
   "local Binding = {\n"
   "  bindings = binds,\n"
   "  require_create_userdata = false,\n"
   "  require_binding = false\n"
   "}\n"
   "setmetatable(binds, {__index = function(t,k)\n"
   "  if Binding.require_binding then\n"
   "    error(\"missing binding for \" .. tostring(k))\n"
   "  end\n"
   "end})\n"
   "--local mm = require \"mm\"\n"
   "\n"
   "local calls = {\n"
   "  create = function(create_callback, self, ...)\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'self' to be table, got %s)\"):format(type(self))\n"
   "    end\n"
   "    local ref = create_callback(self, ...)\n"
   "    if (Binding.require_create_userdata or ref) and type(ref) ~= \"userdata\" then\n"
   "      return nil, (\"expected userdata, got %s\"):format(type(ref))\n"
   "    elseif type(ref) == \"userdata\" then\n"
   "      self.__binding = ref\n"
   "    end\n"
   "    return true\n"
   "  end,\n"
   "  update = function(update_callback, self, delta)\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected self (current data) to be table, got %s)\"):format(type(self))\n"
   "    end\n"
   "    if not self.name then\n"
   "      return nil, \"can't update nameless thing\"\n"
   "    end\n"
   "    local ref = update_callback(self, delta)\n"
   "    if type(ref) == \"userdata\" then\n"
   "      self.__binding = ref\n"
   "    end\n"
   "    return true\n"
   "  end,\n"
   "  delete = function(delete_callback, self, ...)\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'self' to be table, got %s)\"):format(type(self))\n"
   "    end\n"
   "    assert(type(self.__binding) == \"userdata\", (\"expected seld.__binding userdata, got %s\"):format(type(self.__binding)))\n"
   "    delete_callback(self.__binding, self, ...)\n"
   "    return true\n"
   "  end\n"
   "}\n"
   "\n"
   "function Binding.set(name, create, update, delete)\n"
   "  assert(not rawget(binds, name), (\"binding %s already set\"):format(name))\n"
   "  assert(type(name)==\"string\", \"binding name must be a string, got \" .. type(name))\n"
   "  if type(create) == \"table\" and update == nil and delete == nil then\n"
   "    local tbl = create\n"
   "    create = tbl.create\n"
   "    update = tbl.update\n"
   "    delete = tbl.delete\n"
   "  end\n"
   "  \n"
   "  local callbacks = {\n"
   "    create = create,\n"
   "    update = update,\n"
   "    delete = delete\n"
   "  }\n"
   "  \n"
   "  for n,f in pairs(callbacks) do\n"
   "    assert(type(f) == \"function\" or type(f) == nil, (\"\\\"%s\\\" binding \\\"%s\\\" callback must be function or nil, was %s\"):format(name, n, type(f)))\n"
   "  end\n"
   "  \n"
   "  binds[name]=callbacks\n"
   "end\n"
   "function Binding.call(binding_name, call_name, ...)\n"
   "  local callbacks = binds[binding_name]\n"
   "  if not callbacks then return end\n"
   "  local binding_call = calls[call_name]\n"
   "  if not binding_call then\n"
   "    error((\"unknown binding call \\\"%s\\\" for \\\"%s\\\"\"):format(call_name, binding_name))\n"
   "  end\n"
   "  if not callbacks[call_name] then\n"
   "    error((\"no callback for binding call \\\"%s\\\" for \\\"%s\\\"\"):format(call_name, binding_name))\n"
   "  end\n"
   "  local ok, err = binding_call(callbacks[call_name], ...)\n"
   "  if not ok then\n"
   "    error((\"Binding \\\"%s\\\" call \\\"%s\\\" error: %s\"):format(binding_name, call_name, err))\n"
   "  end\n"
   "  return ok\n"
   "end\n"
   "\n"
   "return Binding\n"},

  {"dkjson", 
   "--David Kolf's JSON module for Lua 5.1/5.2\n"
   "-- small hack to generate object and array metatables, \n"
   "-- and key ordering callbacks by slact\n"
   "\n"
   "local always_try_using_lpeg = false\n"
   "local register_global_module_table = false\n"
   "local global_module_name = 'json'\n"
   "\n"
   "--luacheck: ignore\n"
   "\n"
   "--[==[\n"
   "\n"
   "David Kolf's JSON module for Lua 5.1/5.2\n"
   "\n"
   "Version 2.5\n"
   "\n"
   "\n"
   "For the documentation see the corresponding readme.txt or visit\n"
   "<http://dkolf.de/src/dkjson-lua.fsl/>.\n"
   "\n"
   "You can contact the author by sending an e-mail to 'david' at the\n"
   "domain 'dkolf.de'.\n"
   "\n"
   "\n"
   "Copyright (C) 2010-2013 David Heiko Kolf\n"
   "\n"
   "Permission is hereby granted, free of charge, to any person obtaining\n"
   "a copy of this software and associated documentation files (the\n"
   "\"Software\"), to deal in the Software without restriction, including\n"
   "without limitation the rights to use, copy, modify, merge, publish,\n"
   "distribute, sublicense, and/or sell copies of the Software, and to\n"
   "permit persons to whom the Software is furnished to do so, subject to\n"
   "the following conditions:\n"
   "\n"
   "The above copyright notice and this permission notice shall be\n"
   "included in all copies or substantial portions of the Software.\n"
   "\n"
   "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n"
   "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
   "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
   "NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n"
   "BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n"
   "ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n"
   "CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
   "SOFTWARE.\n"
   "\n"
   "--]==]\n"
   "\n"
   "-- global dependencies:\n"
   "local pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset =\n"
   "      pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset\n"
   "local error, require, pcall, select = error, require, pcall, select\n"
   "local floor, huge = math.floor, math.huge\n"
   "local strrep, gsub, strsub, strbyte, strchar, strfind, strlen, strformat =\n"
   "      string.rep, string.gsub, string.sub, string.byte, string.char,\n"
   "      string.find, string.len, string.format\n"
   "local strmatch = string.match\n"
   "local concat = table.concat\n"
   "\n"
   "local json = { version = \"dkjson 2.5\" }\n"
   "\n"
   "if register_global_module_table then\n"
   "  _G[global_module_name] = json\n"
   "end\n"
   "\n"
   "local _ENV = nil -- blocking globals in Lua 5.2\n"
   "\n"
   "pcall (function()\n"
   "  -- Enable access to blocked metatables.\n"
   "  -- Don't worry, this module doesn't change anything in them.\n"
   "  local debmeta = require \"debug\".getmetatable\n"
   "  if debmeta then getmetatable = debmeta end\n"
   "end)\n"
   "\n"
   "json.null = setmetatable ({}, {\n"
   "  __tojson = function () return \"null\" end\n"
   "})\n"
   "\n"
   "local function isarray (tbl)\n"
   "  local max, n, arraylen = 0, 0, 0\n"
   "  for k,v in pairs (tbl) do\n"
   "    if k == 'n' and type(v) == 'number' then\n"
   "      arraylen = v\n"
   "      if v > max then\n"
   "        max = v\n"
   "      end\n"
   "    else\n"
   "      if type(k) ~= 'number' or k < 1 or floor(k) ~= k then\n"
   "        return false\n"
   "      end\n"
   "      if k > max then\n"
   "        max = k\n"
   "      end\n"
   "      n = n + 1\n"
   "    end\n"
   "  end\n"
   "  if max > 10 and max > arraylen and max > n * 2 then\n"
   "    return false -- don't create an array with too many holes\n"
   "  end\n"
   "  return true, max\n"
   "end\n"
   "\n"
   "local escapecodes = {\n"
   "  [\"\\\"\"] = \"\\\\\\\"\", [\"\\\\\"] = \"\\\\\\\\\", [\"\\b\"] = \"\\\\b\", [\"\\f\"] = \"\\\\f\",\n"
   "  [\"\\n\"] = \"\\\\n\",  [\"\\r\"] = \"\\\\r\",  [\"\\t\"] = \"\\\\t\"\n"
   "}\n"
   "\n"
   "local function escapeutf8 (uchar)\n"
   "  local value = escapecodes[uchar]\n"
   "  if value then\n"
   "    return value\n"
   "  end\n"
   "  local a, b, c, d = strbyte (uchar, 1, 4)\n"
   "  a, b, c, d = a or 0, b or 0, c or 0, d or 0\n"
   "  if a <= 0x7f then\n"
   "    value = a\n"
   "  elseif 0xc0 <= a and a <= 0xdf and b >= 0x80 then\n"
   "    value = (a - 0xc0) * 0x40 + b - 0x80\n"
   "  elseif 0xe0 <= a and a <= 0xef and b >= 0x80 and c >= 0x80 then\n"
   "    value = ((a - 0xe0) * 0x40 + b - 0x80) * 0x40 + c - 0x80\n"
   "  elseif 0xf0 <= a and a <= 0xf7 and b >= 0x80 and c >= 0x80 and d >= 0x80 then\n"
   "    value = (((a - 0xf0) * 0x40 + b - 0x80) * 0x40 + c - 0x80) * 0x40 + d - 0x80\n"
   "  else\n"
   "    return \"\"\n"
   "  end\n"
   "  if value <= 0xffff then\n"
   "    return strformat (\"\\\\u%.4x\", value)\n"
   "  elseif value <= 0x10ffff then\n"
   "    -- encode as UTF-16 surrogate pair\n"
   "    value = value - 0x10000\n"
   "    local highsur, lowsur = 0xD800 + floor (value/0x400), 0xDC00 + (value % 0x400)\n"
   "    return strformat (\"\\\\u%.4x\\\\u%.4x\", highsur, lowsur)\n"
   "  else\n"
   "    return \"\"\n"
   "  end\n"
   "end\n"
   "\n"
   "local function fsub (str, pattern, repl)\n"
   "  -- gsub always builds a new string in a buffer, even when no match\n"
   "  -- exists. First using find should be more efficient when most strings\n"
   "  -- don't contain the pattern.\n"
   "  if strfind (str, pattern) then\n"
   "    return gsub (str, pattern, repl)\n"
   "  else\n"
   "    return str\n"
   "  end\n"
   "end\n"
   "\n"
   "local function quotestring (value)\n"
   "  -- based on the regexp \"escapable\" in https://github.com/douglascrockford/JSON-js\n"
   "  value = fsub (value, \"[%z\\1-\\31\\\"\\\\\\127]\", escapeutf8)\n"
   "  if strfind (value, \"[\\194\\216\\220\\225\\226\\239]\") then\n"
   "    value = fsub (value, \"\\194[\\128-\\159\\173]\", escapeutf8)\n"
   "    value = fsub (value, \"\\216[\\128-\\132]\", escapeutf8)\n"
   "    value = fsub (value, \"\\220\\143\", escapeutf8)\n"
   "    value = fsub (value, \"\\225\\158[\\180\\181]\", escapeutf8)\n"
   "    value = fsub (value, \"\\226\\128[\\140-\\143\\168-\\175]\", escapeutf8)\n"
   "    value = fsub (value, \"\\226\\129[\\160-\\175]\", escapeutf8)\n"
   "    value = fsub (value, \"\\239\\187\\191\", escapeutf8)\n"
   "    value = fsub (value, \"\\239\\191[\\176-\\191]\", escapeutf8)\n"
   "  end\n"
   "  return \"\\\"\" .. value .. \"\\\"\"\n"
   "end\n"
   "json.quotestring = quotestring\n"
   "\n"
   "local function replace(str, o, n)\n"
   "  local i, j = strfind (str, o, 1, true)\n"
   "  if i then\n"
   "    return strsub(str, 1, i-1) .. n .. strsub(str, j+1, -1)\n"
   "  else\n"
   "    return str\n"
   "  end\n"
   "end\n"
   "\n"
   "-- locale independent num2str and str2num functions\n"
   "local decpoint, numfilter\n"
   "\n"
   "local function updatedecpoint ()\n"
   "  decpoint = strmatch(tostring(0.5), \"([^05+])\")\n"
   "  -- build a filter that can be used to remove group separators\n"
   "  numfilter = \"[^0-9%-%+eE\" .. gsub(decpoint, \"[%^%$%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\") .. \"]+\"\n"
   "end\n"
   "\n"
   "updatedecpoint()\n"
   "\n"
   "local function num2str (num)\n"
   "  return replace(fsub(tostring(num), numfilter, \"\"), decpoint, \".\")\n"
   "end\n"
   "\n"
   "local function str2num (str)\n"
   "  local num = tonumber(replace(str, \".\", decpoint))\n"
   "  if not num then\n"
   "    updatedecpoint()\n"
   "    num = tonumber(replace(str, \".\", decpoint))\n"
   "  end\n"
   "  return num\n"
   "end\n"
   "\n"
   "local function addnewline2 (level, buffer, buflen)\n"
   "  buffer[buflen+1] = \"\\n\"\n"
   "  buffer[buflen+2] = strrep (\"  \", level)\n"
   "  buflen = buflen + 2\n"
   "  return buflen\n"
   "end\n"
   "\n"
   "function json.addnewline (state)\n"
   "  if state.indent then\n"
   "    state.bufferlen = addnewline2 (state.level or 0,\n"
   "                           state.buffer, state.bufferlen or #(state.buffer))\n"
   "  end\n"
   "end\n"
   "\n"
   "local encode2 -- forward declaration\n"
   "\n"
   "local function addpair (key, value, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "  local kt = type (key)\n"
   "  if kt ~= 'string' and kt ~= 'number' then\n"
   "    return nil, \"type '\" .. kt .. \"' is not supported as a key by JSON.\"\n"
   "  end\n"
   "  if prev then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = \",\"\n"
   "  end\n"
   "  if indent then\n"
   "    buflen = addnewline2 (level, buffer, buflen)\n"
   "  end\n"
   "  buffer[buflen+1] = quotestring (key)\n"
   "  buffer[buflen+2] = \":\"\n"
   "  return encode2 (value, indent, level, buffer, buflen + 2, tables, globalorder, state)\n"
   "end\n"
   "\n"
   "local function appendcustom(res, buffer, state)\n"
   "  local buflen = state.bufferlen\n"
   "  if type (res) == 'string' then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = res\n"
   "  end\n"
   "  return buflen\n"
   "end\n"
   "\n"
   "local function exception(reason, value, state, buffer, buflen, defaultmessage)\n"
   "  defaultmessage = defaultmessage or reason\n"
   "  local handler = state.exception\n"
   "  if not handler then\n"
   "    return nil, defaultmessage\n"
   "  else\n"
   "    state.bufferlen = buflen\n"
   "    local ret, msg = handler (reason, value, state, defaultmessage)\n"
   "    if not ret then return nil, msg or defaultmessage end\n"
   "    return appendcustom(ret, buffer, state)\n"
   "  end\n"
   "end\n"
   "\n"
   "function json.encodeexception(reason, value, state, defaultmessage)\n"
   "  return quotestring(\"<\" .. defaultmessage .. \">\")\n"
   "end\n"
   "\n"
   "encode2 = function (value, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "  local valtype = type (value)\n"
   "  local valmeta = getmetatable (value)\n"
   "  valmeta = type (valmeta) == 'table' and valmeta -- only tables\n"
   "  local replacementjsonval = valmeta and valmeta.__jsonval\n"
   "  if replacementjsonval then\n"
   "    if type(replacementjsonval) == \"function\" then\n"
   "      value = replacementjsonval(value)\n"
   "    else\n"
   "      value = replacementjsonval\n"
   "    end\n"
   "    valtype = type (value)\n"
   "  end\n"
   "  \n"
   "  local valtojson = valmeta and valmeta.__tojson\n"
   "  if valtojson then\n"
   "    if tables[value] then\n"
   "      return exception('reference cycle', value, state, buffer, buflen)\n"
   "    end\n"
   "    tables[value] = true\n"
   "    state.bufferlen = buflen\n"
   "    local ret, msg = valtojson (value, state)\n"
   "    if not ret then return exception('custom encoder failed', value, state, buffer, buflen, msg) end\n"
   "    tables[value] = nil\n"
   "    buflen = appendcustom(ret, buffer, state)\n"
   "  elseif value == nil then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = \"null\"\n"
   "  elseif valtype == 'number' then\n"
   "    local s\n"
   "    if value ~= value or value >= huge or -value >= huge then\n"
   "      -- This is the behaviour of the original JSON implementation.\n"
   "      s = \"null\"\n"
   "    else\n"
   "      s = num2str (value)\n"
   "    end\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = s\n"
   "  elseif valtype == 'boolean' then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = value and \"true\" or \"false\"\n"
   "  elseif valtype == 'string' then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = quotestring (value)\n"
   "  elseif valtype == 'table' then\n"
   "    if tables[value] then\n"
   "      return exception('reference cycle', value, state, buffer, buflen)\n"
   "    end\n"
   "    tables[value] = true\n"
   "    level = level + 1\n"
   "    local isa, n = isarray (value)\n"
   "    if n == 0 and valmeta and valmeta.__jsontype == 'object' then\n"
   "      isa = false\n"
   "    end\n"
   "    local msg\n"
   "    if isa then -- JSON array\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"[\"\n"
   "      for i = 1, n do\n"
   "        buflen, msg = encode2 (value[i], indent, level, buffer, buflen, tables, globalorder, state)\n"
   "        if not buflen then return nil, msg end\n"
   "        if i < n then\n"
   "          buflen = buflen + 1\n"
   "          buffer[buflen] = \",\"\n"
   "        end\n"
   "      end\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"]\"\n"
   "    else -- JSON object\n"
   "      local prev = false\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"{\"\n"
   "      local order = valmeta and valmeta.__jsonorder or globalorder\n"
   "      if order then\n"
   "        if type(order) == \"function\" then order = order(value) end\n"
   "        local used = {}\n"
   "        n = #order\n"
   "        for i = 1, n do\n"
   "          local k = order[i]\n"
   "          local v = value[k]\n"
   "          if v then\n"
   "            used[k] = true\n"
   "            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "            prev = true -- add a seperator before the next element\n"
   "          end\n"
   "        end\n"
   "        for k,v in pairs (value) do\n"
   "          if not used[k] then\n"
   "            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "            if not buflen then return nil, msg end\n"
   "            prev = true -- add a seperator before the next element\n"
   "          end\n"
   "        end\n"
   "      else -- unordered\n"
   "        for k,v in pairs (value) do\n"
   "          buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "          if not buflen then return nil, msg end\n"
   "          prev = true -- add a seperator before the next element\n"
   "        end\n"
   "      end\n"
   "      if indent then\n"
   "        buflen = addnewline2 (level - 1, buffer, buflen)\n"
   "      end\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"}\"\n"
   "    end\n"
   "    tables[value] = nil\n"
   "  else\n"
   "    return exception ('unsupported type', value, state, buffer, buflen,\n"
   "      \"type '\" .. valtype .. \"' is not supported by JSON.\")\n"
   "  end\n"
   "  return buflen\n"
   "end\n"
   "\n"
   "function json.encode (value, state)\n"
   "  state = state or {}\n"
   "  local oldbuffer = state.buffer\n"
   "  local buffer = oldbuffer or {}\n"
   "  state.buffer = buffer\n"
   "  updatedecpoint()\n"
   "  local ret, msg = encode2 (value, state.indent, state.level or 0,\n"
   "                   buffer, state.bufferlen or 0, state.tables or {}, state.keyorder, state)\n"
   "  if not ret then\n"
   "    error (msg, 2)\n"
   "  elseif oldbuffer == buffer then\n"
   "    state.bufferlen = ret\n"
   "    return true\n"
   "  else\n"
   "    state.bufferlen = nil\n"
   "    state.buffer = nil\n"
   "    return concat (buffer)\n"
   "  end\n"
   "end\n"
   "\n"
   "local function loc(str, where)\n"
   "  local line, pos, linepos = 1, 1, 0\n"
   "  while true do\n"
   "    pos = strfind (str, \"\\n\", pos, true)\n"
   "    if pos and pos < where then\n"
   "      line = line + 1\n"
   "      linepos = pos\n"
   "      pos = pos + 1\n"
   "    else\n"
   "      break\n"
   "    end\n"
   "  end\n"
   "  return \"line \" .. line .. \", column \" .. (where - linepos)\n"
   "end\n"
   "\n"
   "local function unterminated (str, what, where)\n"
   "  return nil, strlen (str) + 1, \"unterminated \" .. what .. \" at \" .. loc (str, where)\n"
   "end\n"
   "\n"
   "local function scanwhite (str, pos)\n"
   "  while true do\n"
   "    pos = strfind (str, \"%S\", pos)\n"
   "    if not pos then return nil end\n"
   "    local sub2 = strsub (str, pos, pos + 1)\n"
   "    if sub2 == \"\\239\\187\" and strsub (str, pos + 2, pos + 2) == \"\\191\" then\n"
   "      -- UTF-8 Byte Order Mark\n"
   "      pos = pos + 3\n"
   "    elseif sub2 == \"//\" then\n"
   "      pos = strfind (str, \"[\\n\\r]\", pos + 2)\n"
   "      if not pos then return nil end\n"
   "    elseif sub2 == \"/*\" then\n"
   "      pos = strfind (str, \"*/\", pos + 2)\n"
   "      if not pos then return nil end\n"
   "      pos = pos + 2\n"
   "    else\n"
   "      return pos\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "local escapechars = {\n"
   "  [\"\\\"\"] = \"\\\"\", [\"\\\\\"] = \"\\\\\", [\"/\"] = \"/\", [\"b\"] = \"\\b\", [\"f\"] = \"\\f\",\n"
   "  [\"n\"] = \"\\n\", [\"r\"] = \"\\r\", [\"t\"] = \"\\t\"\n"
   "}\n"
   "\n"
   "local function unichar (value)\n"
   "  if value < 0 then\n"
   "    return nil\n"
   "  elseif value <= 0x007f then\n"
   "    return strchar (value)\n"
   "  elseif value <= 0x07ff then\n"
   "    return strchar (0xc0 + floor(value/0x40),\n"
   "                    0x80 + (floor(value) % 0x40))\n"
   "  elseif value <= 0xffff then\n"
   "    return strchar (0xe0 + floor(value/0x1000),\n"
   "                    0x80 + (floor(value/0x40) % 0x40),\n"
   "                    0x80 + (floor(value) % 0x40))\n"
   "  elseif value <= 0x10ffff then\n"
   "    return strchar (0xf0 + floor(value/0x40000),\n"
   "                    0x80 + (floor(value/0x1000) % 0x40),\n"
   "                    0x80 + (floor(value/0x40) % 0x40),\n"
   "                    0x80 + (floor(value) % 0x40))\n"
   "  else\n"
   "    return nil\n"
   "  end\n"
   "end\n"
   "\n"
   "local function scanstring (str, pos)\n"
   "  local lastpos = pos + 1\n"
   "  local buffer, n = {}, 0\n"
   "  while true do\n"
   "    local nextpos = strfind (str, \"[\\\"\\\\]\", lastpos)\n"
   "    if not nextpos then\n"
   "      return unterminated (str, \"string\", pos)\n"
   "    end\n"
   "    if nextpos > lastpos then\n"
   "      n = n + 1\n"
   "      buffer[n] = strsub (str, lastpos, nextpos - 1)\n"
   "    end\n"
   "    if strsub (str, nextpos, nextpos) == \"\\\"\" then\n"
   "      lastpos = nextpos + 1\n"
   "      break\n"
   "    else\n"
   "      local escchar = strsub (str, nextpos + 1, nextpos + 1)\n"
   "      local value\n"
   "      if escchar == \"u\" then\n"
   "        value = tonumber (strsub (str, nextpos + 2, nextpos + 5), 16)\n"
   "        if value then\n"
   "          local value2\n"
   "          if 0xD800 <= value and value <= 0xDBff then\n"
   "            -- we have the high surrogate of UTF-16. Check if there is a\n"
   "            -- low surrogate escaped nearby to combine them.\n"
   "            if strsub (str, nextpos + 6, nextpos + 7) == \"\\\\u\" then\n"
   "              value2 = tonumber (strsub (str, nextpos + 8, nextpos + 11), 16)\n"
   "              if value2 and 0xDC00 <= value2 and value2 <= 0xDFFF then\n"
   "                value = (value - 0xD800)  * 0x400 + (value2 - 0xDC00) + 0x10000\n"
   "              else\n"
   "                value2 = nil -- in case it was out of range for a low surrogate\n"
   "              end\n"
   "            end\n"
   "          end\n"
   "          value = value and unichar (value)\n"
   "          if value then\n"
   "            if value2 then\n"
   "              lastpos = nextpos + 12\n"
   "            else\n"
   "              lastpos = nextpos + 6\n"
   "            end\n"
   "          end\n"
   "        end\n"
   "      end\n"
   "      if not value then\n"
   "        value = escapechars[escchar] or escchar\n"
   "        lastpos = nextpos + 2\n"
   "      end\n"
   "      n = n + 1\n"
   "      buffer[n] = value\n"
   "    end\n"
   "  end\n"
   "  if n == 1 then\n"
   "    return buffer[1], lastpos\n"
   "  elseif n > 1 then\n"
   "    return concat (buffer), lastpos\n"
   "  else\n"
   "    return \"\", lastpos\n"
   "  end\n"
   "end\n"
   "\n"
   "local scanvalue -- forward declaration\n"
   "\n"
   "local function set_scantable_metatable (tbl, meta, str, pos)\n"
   "  if type(meta)==\"function\" then\n"
   "    meta = meta(str, pos)\n"
   "    if type(meta) ~= \"table\" then\n"
   "      return tbl\n"
   "    end\n"
   "  end\n"
   "  return setmetatable(tbl, meta)\n"
   "end\n"
   "\n"
   "local function scantable (what, closechar, str, startpos, nullval, objectmeta, arraymeta)\n"
   "  local len = strlen (str)\n"
   "  local tbl, n = {}, 0\n"
   "  local pos = startpos + 1\n"
   "  if what == 'object' then\n"
   "    set_scantable_metatable(tbl, objectmeta, str, startpos)\n"
   "  else\n"
   "    set_scantable_metatable(tbl, arraymeta, str, startpos)\n"
   "  end\n"
   "  while true do\n"
   "    pos = scanwhite (str, pos)\n"
   "    if not pos then return unterminated (str, what, startpos) end\n"
   "    local char = strsub (str, pos, pos)\n"
   "    if char == closechar then\n"
   "      return tbl, pos + 1\n"
   "    end\n"
   "    local val1, err\n"
   "    val1, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "    if err then return nil, pos, err end\n"
   "    pos = scanwhite (str, pos)\n"
   "    if not pos then return unterminated (str, what, startpos) end\n"
   "    char = strsub (str, pos, pos)\n"
   "    if char == \":\" then\n"
   "      if val1 == nil then\n"
   "        return nil, pos, \"cannot use nil as table index (at \" .. loc (str, pos) .. \")\"\n"
   "      end\n"
   "      pos = scanwhite (str, pos + 1)\n"
   "      if not pos then return unterminated (str, what, startpos) end\n"
   "      local val2\n"
   "      val2, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "      if err then return nil, pos, err end\n"
   "      tbl[val1] = val2\n"
   "      pos = scanwhite (str, pos)\n"
   "      if not pos then return unterminated (str, what, startpos) end\n"
   "      char = strsub (str, pos, pos)\n"
   "    else\n"
   "      n = n + 1\n"
   "      tbl[n] = val1\n"
   "    end\n"
   "    if char == \",\" then\n"
   "      pos = pos + 1\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "scanvalue = function (str, pos, nullval, objectmeta, arraymeta)\n"
   "  pos = pos or 1\n"
   "  pos = scanwhite (str, pos)\n"
   "  if not pos then\n"
   "    return nil, strlen (str) + 1, \"no valid JSON value (reached the end)\"\n"
   "  end\n"
   "  local char = strsub (str, pos, pos)\n"
   "  if char == \"{\" then\n"
   "    return scantable ('object', \"}\", str, pos, nullval, objectmeta, arraymeta)\n"
   "  elseif char == \"[\" then\n"
   "    return scantable ('array', \"]\", str, pos, nullval, objectmeta, arraymeta)\n"
   "  elseif char == \"\\\"\" then\n"
   "    return scanstring (str, pos)\n"
   "  else\n"
   "    local pstart, pend = strfind (str, \"^%-?[%d%.]+[eE]?[%+%-]?%d*\", pos)\n"
   "    if pstart then\n"
   "      local number = str2num (strsub (str, pstart, pend))\n"
   "      if number then\n"
   "        return number, pend + 1\n"
   "      end\n"
   "    end\n"
   "    pstart, pend = strfind (str, \"^%a%w*\", pos)\n"
   "    if pstart then\n"
   "      local name = strsub (str, pstart, pend)\n"
   "      if name == \"true\" then\n"
   "        return true, pend + 1\n"
   "      elseif name == \"false\" then\n"
   "        return false, pend + 1\n"
   "      elseif name == \"null\" then\n"
   "        return nullval, pend + 1\n"
   "      end\n"
   "    end\n"
   "    return nil, pos, \"no valid JSON value at \" .. loc (str, pos)\n"
   "  end\n"
   "end\n"
   "\n"
   "local function optionalmetatables(...)\n"
   "  if select(\"#\", ...) > 0 then\n"
   "    return ...\n"
   "  else\n"
   "    return {__jsontype = 'object'}, {__jsontype = 'array'}\n"
   "  end\n"
   "end\n"
   "\n"
   "function json.decode (str, pos, nullval, ...)\n"
   "  local objectmeta, arraymeta = optionalmetatables(...)\n"
   "  return scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "end\n"
   "\n"
   "function json.use_lpeg ()\n"
   "  local g = require (\"lpeg\")\n"
   "\n"
   "  if g.version() == \"0.11\" then\n"
   "    error \"due to a bug in LPeg 0.11, it cannot be used for JSON matching\"\n"
   "  end\n"
   "\n"
   "  local pegmatch = g.match\n"
   "  local P, S, R = g.P, g.S, g.R\n"
   "\n"
   "  local function ErrorCall (str, pos, msg, state)\n"
   "    if not state.msg then\n"
   "      state.msg = msg .. \" at \" .. loc (str, pos)\n"
   "      state.pos = pos\n"
   "    end\n"
   "    return false\n"
   "  end\n"
   "\n"
   "  local function Err (msg)\n"
   "    return g.Cmt (g.Cc (msg) * g.Carg (2), ErrorCall)\n"
   "  end\n"
   "\n"
   "  local SingleLineComment = P\"//\" * (1 - S\"\\n\\r\")^0\n"
   "  local MultiLineComment = P\"/*\" * (1 - P\"*/\")^0 * P\"*/\"\n"
   "  local Space = (S\" \\n\\r\\t\" + P\"\\239\\187\\191\" + SingleLineComment + MultiLineComment)^0\n"
   "\n"
   "  local PlainChar = 1 - S\"\\\"\\\\\\n\\r\"\n"
   "  local EscapeSequence = (P\"\\\\\" * g.C (S\"\\\"\\\\/bfnrt\" + Err \"unsupported escape sequence\")) / escapechars\n"
   "  local HexDigit = R(\"09\", \"af\", \"AF\")\n"
   "  local function UTF16Surrogate (match, pos, high, low)\n"
   "    high, low = tonumber (high, 16), tonumber (low, 16)\n"
   "    if 0xD800 <= high and high <= 0xDBff and 0xDC00 <= low and low <= 0xDFFF then\n"
   "      return true, unichar ((high - 0xD800)  * 0x400 + (low - 0xDC00) + 0x10000)\n"
   "    else\n"
   "      return false\n"
   "    end\n"
   "  end\n"
   "  local function UTF16BMP (hex)\n"
   "    return unichar (tonumber (hex, 16))\n"
   "  end\n"
   "  local U16Sequence = (P\"\\\\u\" * g.C (HexDigit * HexDigit * HexDigit * HexDigit))\n"
   "  local UnicodeEscape = g.Cmt (U16Sequence * U16Sequence, UTF16Surrogate) + U16Sequence/UTF16BMP\n"
   "  local Char = UnicodeEscape + EscapeSequence + PlainChar\n"
   "  local String = P\"\\\"\" * g.Cs (Char ^ 0) * (P\"\\\"\" + Err \"unterminated string\")\n"
   "  local Integer = P\"-\"^(-1) * (P\"0\" + (R\"19\" * R\"09\"^0))\n"
   "  local Fractal = P\".\" * R\"09\"^0\n"
   "  local Exponent = (S\"eE\") * (S\"+-\")^(-1) * R\"09\"^1\n"
   "  local Number = (Integer * Fractal^(-1) * Exponent^(-1))/str2num\n"
   "  local Constant = P\"true\" * g.Cc (true) + P\"false\" * g.Cc (false) + P\"null\" * g.Carg (1)\n"
   "  local SimpleValue = Number + String + Constant\n"
   "  local ArrayContent, ObjectContent\n"
   "\n"
   "  -- The functions parsearray and parseobject parse only a single value/pair\n"
   "  -- at a time and store them directly to avoid hitting the LPeg limits.\n"
   "  local function parsearray (str, pos, nullval, state)\n"
   "    local obj, cont\n"
   "    local npos\n"
   "    local t, nt = {}, 0\n"
   "    repeat\n"
   "      obj, cont, npos = pegmatch (ArrayContent, str, pos, nullval, state)\n"
   "      if not npos then break end\n"
   "      pos = npos\n"
   "      nt = nt + 1\n"
   "      t[nt] = obj\n"
   "    until cont == 'last'\n"
   "    return pos, setmetatable (t, state.arraymeta)\n"
   "  end\n"
   "\n"
   "  local function parseobject (str, pos, nullval, state)\n"
   "    local obj, key, cont\n"
   "    local npos\n"
   "    local t = {}\n"
   "    repeat\n"
   "      key, obj, cont, npos = pegmatch (ObjectContent, str, pos, nullval, state)\n"
   "      if not npos then break end\n"
   "      pos = npos\n"
   "      t[key] = obj\n"
   "    until cont == 'last'\n"
   "    return pos, setmetatable (t, state.objectmeta)\n"
   "  end\n"
   "\n"
   "  local Array = P\"[\" * g.Cmt (g.Carg(1) * g.Carg(2), parsearray) * Space * (P\"]\" + Err \"']' expected\")\n"
   "  local Object = P\"{\" * g.Cmt (g.Carg(1) * g.Carg(2), parseobject) * Space * (P\"}\" + Err \"'}' expected\")\n"
   "  local Value = Space * (Array + Object + SimpleValue)\n"
   "  local ExpectedValue = Value + Space * Err \"value expected\"\n"
   "  ArrayContent = Value * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
   "  local Pair = g.Cg (Space * String * Space * (P\":\" + Err \"colon expected\") * ExpectedValue)\n"
   "  ObjectContent = Pair * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
   "  local DecodeValue = ExpectedValue * g.Cp ()\n"
   "\n"
   "  function json.decode (str, pos, nullval, ...)\n"
   "    local state = {}\n"
   "    state.objectmeta, state.arraymeta = optionalmetatables(...)\n"
   "    local obj, retpos = pegmatch (DecodeValue, str, pos, nullval, state)\n"
   "    if state.msg then\n"
   "      return nil, state.pos, state.msg\n"
   "    else\n"
   "      return obj, retpos\n"
   "    end\n"
   "  end\n"
   "\n"
   "  -- use this function only once:\n"
   "  json.use_lpeg = function () return json end\n"
   "\n"
   "  json.using_lpeg = true\n"
   "\n"
   "  return json -- so you can get the module using json = require \"dkjson\".use_lpeg()\n"
   "end\n"
   "\n"
   "if always_try_using_lpeg then\n"
   "  pcall (json.use_lpeg)\n"
   "end\n"
   "\n"
   "return json\n"
   "\n"},

  {"inspect", 
   "local inspect ={\n"
   "  _VERSION = 'inspect.lua 3.1.0',\n"
   "  _URL     = 'http://github.com/kikito/inspect.lua',\n"
   "  _DESCRIPTION = 'human-readable representations of tables',\n"
   "  _LICENSE = \"MIT LICENSE; Copyright (c) 2013 Enrique García Cota\"\n"
   "}\n"
   "\n"
   "local tostring = tostring\n"
   "\n"
   "inspect.KEY       = setmetatable({}, {__tostring = function() return 'inspect.KEY' end})\n"
   "inspect.METATABLE = setmetatable({}, {__tostring = function() return 'inspect.METATABLE' end})\n"
   "\n"
   "-- Apostrophizes the string if it has quotes, but not aphostrophes\n"
   "-- Otherwise, it returns a regular quoted string\n"
   "local function smartQuote(str)\n"
   "  if str:match('\"') and not str:match(\"'\") then\n"
   "    return \"'\" .. str .. \"'\"\n"
   "  end\n"
   "  return '\"' .. str:gsub('\"', '\\\\\"') .. '\"'\n"
   "end\n"
   "\n"
   "-- \\a => '\\\\a', \\0 => '\\\\0', 31 => '\\31'\n"
   "local shortControlCharEscapes = {\n"
   "  [\"\\a\"] = \"\\\\a\",  [\"\\b\"] = \"\\\\b\", [\"\\f\"] = \"\\\\f\", [\"\\n\"] = \"\\\\n\",\n"
   "  [\"\\r\"] = \"\\\\r\",  [\"\\t\"] = \"\\\\t\", [\"\\v\"] = \"\\\\v\"\n"
   "}\n"
   "local longControlCharEscapes = {} -- \\a => nil, \\0 => \\000, 31 => \\031\n"
   "for i=0, 31 do\n"
   "  local ch = string.char(i)\n"
   "  if not shortControlCharEscapes[ch] then\n"
   "    shortControlCharEscapes[ch] = \"\\\\\"..i\n"
   "    longControlCharEscapes[ch]  = string.format(\"\\\\%03d\", i)\n"
   "  end\n"
   "end\n"
   "\n"
   "local function escape(str)\n"
   "  return (str:gsub(\"\\\\\", \"\\\\\\\\\")\n"
   "             :gsub(\"(%c)%f[0-9]\", longControlCharEscapes)\n"
   "             :gsub(\"%c\", shortControlCharEscapes))\n"
   "end\n"
   "\n"
   "local function isIdentifier(str)\n"
   "  return type(str) == 'string' and str:match( \"^[_%a][_%a%d]*$\" )\n"
   "end\n"
   "\n"
   "local function isSequenceKey(k, sequenceLength)\n"
   "  return type(k) == 'number'\n"
   "     and 1 <= k\n"
   "     and k <= sequenceLength\n"
   "     and math.floor(k) == k\n"
   "end\n"
   "\n"
   "local defaultTypeOrders = {\n"
   "  ['number']   = 1, ['boolean']  = 2, ['string'] = 3, ['table'] = 4,\n"
   "  ['function'] = 5, ['userdata'] = 6, ['thread'] = 7\n"
   "}\n"
   "\n"
   "local function sortKeys(a, b)\n"
   "  local ta, tb = type(a), type(b)\n"
   "\n"
   "  -- strings and numbers are sorted numerically/alphabetically\n"
   "  if ta == tb and (ta == 'string' or ta == 'number') then return a < b end\n"
   "\n"
   "  local dta, dtb = defaultTypeOrders[ta], defaultTypeOrders[tb]\n"
   "  -- Two default types are compared according to the defaultTypeOrders table\n"
   "  if dta and dtb then return defaultTypeOrders[ta] < defaultTypeOrders[tb]\n"
   "  elseif dta     then return true  -- default types before custom ones\n"
   "  elseif dtb     then return false -- custom types after default ones\n"
   "  end\n"
   "\n"
   "  -- custom types are sorted out alphabetically\n"
   "  return ta < tb\n"
   "end\n"
   "\n"
   "-- For implementation reasons, the behavior of rawlen & # is \"undefined\" when\n"
   "-- tables aren't pure sequences. So we implement our own # operator.\n"
   "local function getSequenceLength(t)\n"
   "  local len = 1\n"
   "  local v = rawget(t,len)\n"
   "  while v ~= nil do\n"
   "    len = len + 1\n"
   "    v = rawget(t,len)\n"
   "  end\n"
   "  return len - 1\n"
   "end\n"
   "\n"
   "local function getNonSequentialKeys(t)\n"
   "  local keys = {}\n"
   "  local sequenceLength = getSequenceLength(t)\n"
   "  for k,_ in pairs(t) do\n"
   "    if not isSequenceKey(k, sequenceLength) then table.insert(keys, k) end\n"
   "  end\n"
   "  table.sort(keys, sortKeys)\n"
   "  return keys, sequenceLength\n"
   "end\n"
   "\n"
   "local function getToStringResultSafely(t, mt)\n"
   "  local __tostring = type(mt) == 'table' and rawget(mt, '__tostring')\n"
   "  local str, ok\n"
   "  if type(__tostring) == 'function' then\n"
   "    ok, str = pcall(__tostring, t)\n"
   "    str = ok and str or 'error: ' .. tostring(str)\n"
   "  end\n"
   "  if type(str) == 'string' and #str > 0 then return str end\n"
   "end\n"
   "\n"
   "local function countTableAppearances(t, tableAppearances)\n"
   "  tableAppearances = tableAppearances or {}\n"
   "\n"
   "  if type(t) == 'table' then\n"
   "    if not tableAppearances[t] then\n"
   "      tableAppearances[t] = 1\n"
   "      for k,v in pairs(t) do\n"
   "        countTableAppearances(k, tableAppearances)\n"
   "        countTableAppearances(v, tableAppearances)\n"
   "      end\n"
   "      countTableAppearances(getmetatable(t), tableAppearances)\n"
   "    else\n"
   "      tableAppearances[t] = tableAppearances[t] + 1\n"
   "    end\n"
   "  end\n"
   "\n"
   "  return tableAppearances\n"
   "end\n"
   "\n"
   "local copySequence = function(s)\n"
   "  local copy, len = {}, #s\n"
   "  for i=1, len do copy[i] = s[i] end\n"
   "  return copy, len\n"
   "end\n"
   "\n"
   "local function makePath(path, ...)\n"
   "  local keys = {...}\n"
   "  local newPath, len = copySequence(path)\n"
   "  for i=1, #keys do\n"
   "    newPath[len + i] = keys[i]\n"
   "  end\n"
   "  return newPath\n"
   "end\n"
   "\n"
   "local function processRecursive(process, item, path, visited)\n"
   "\n"
   "    if item == nil then return nil end\n"
   "    if visited[item] then return visited[item] end\n"
   "\n"
   "    local processed = process(item, path)\n"
   "    if type(processed) == 'table' then\n"
   "      local processedCopy = {}\n"
   "      visited[item] = processedCopy\n"
   "      local processedKey\n"
   "\n"
   "      for k,v in pairs(processed) do\n"
   "        processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY), visited)\n"
   "        if processedKey ~= nil then\n"
   "          processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey), visited)\n"
   "        end\n"
   "      end\n"
   "\n"
   "      local mt  = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE), visited)\n"
   "      setmetatable(processedCopy, mt)\n"
   "      processed = processedCopy\n"
   "    end\n"
   "    return processed\n"
   "end\n"
   "\n"
   "\n"
   "\n"
   "-------------------------------------------------------------------\n"
   "\n"
   "local Inspector = {}\n"
   "local Inspector_mt = {__index = Inspector}\n"
   "\n"
   "function Inspector:puts(...)\n"
   "  local args   = {...}\n"
   "  local buffer = self.buffer\n"
   "  local len    = #buffer\n"
   "  for i=1, #args do\n"
   "    len = len + 1\n"
   "    buffer[len] = args[i]\n"
   "  end\n"
   "end\n"
   "\n"
   "function Inspector:down(f)\n"
   "  self.level = self.level + 1\n"
   "  f()\n"
   "  self.level = self.level - 1\n"
   "end\n"
   "\n"
   "function Inspector:tabify()\n"
   "  self:puts(self.newline, string.rep(self.indent, self.level))\n"
   "end\n"
   "\n"
   "function Inspector:alreadyVisited(v)\n"
   "  return self.ids[v] ~= nil\n"
   "end\n"
   "\n"
   "function Inspector:getId(v)\n"
   "  local id = self.ids[v]\n"
   "  if not id then\n"
   "    local tv = type(v)\n"
   "    id              = (self.maxIds[tv] or 0) + 1\n"
   "    self.maxIds[tv] = id\n"
   "    self.ids[v]     = id\n"
   "  end\n"
   "  return tostring(id)\n"
   "end\n"
   "\n"
   "function Inspector:putKey(k)\n"
   "  if isIdentifier(k) then return self:puts(k) end\n"
   "  self:puts(\"[\")\n"
   "  self:putValue(k)\n"
   "  self:puts(\"]\")\n"
   "end\n"
   "\n"
   "function Inspector:putTable(t)\n"
   "  if t == inspect.KEY or t == inspect.METATABLE then\n"
   "    self:puts(tostring(t))\n"
   "  elseif self:alreadyVisited(t) then\n"
   "    self:puts('<table ', self:getId(t), '>')\n"
   "  elseif self.level >= self.depth then\n"
   "    self:puts('{...}')\n"
   "  else\n"
   "    if self.tableAppearances[t] > 1 then self:puts('<', self:getId(t), '>') end\n"
   "\n"
   "    local nonSequentialKeys, sequenceLength = getNonSequentialKeys(t)\n"
   "    local mt                = getmetatable(t)\n"
   "    local toStringResult    = getToStringResultSafely(t, mt)\n"
   "\n"
   "    self:puts('{')\n"
   "    self:down(function()\n"
   "      if toStringResult then\n"
   "        self:puts(' -- ', escape(toStringResult))\n"
   "        if sequenceLength >= 1 then self:tabify() end\n"
   "      end\n"
   "\n"
   "      local count = 0\n"
   "      for i=1, sequenceLength do\n"
   "        if count > 0 then self:puts(',') end\n"
   "        self:puts(' ')\n"
   "        self:putValue(t[i])\n"
   "        count = count + 1\n"
   "      end\n"
   "\n"
   "      for _,k in ipairs(nonSequentialKeys) do\n"
   "        if count > 0 then self:puts(',') end\n"
   "        self:tabify()\n"
   "        self:putKey(k)\n"
   "        self:puts(' = ')\n"
   "        self:putValue(t[k])\n"
   "        count = count + 1\n"
   "      end\n"
   "\n"
   "      if mt then\n"
   "        if count > 0 then self:puts(',') end\n"
   "        self:tabify()\n"
   "        self:puts('<metatable> = ')\n"
   "        self:putValue(mt)\n"
   "      end\n"
   "    end)\n"
   "\n"
   "    if #nonSequentialKeys > 0 or mt then -- result is multi-lined. Justify closing }\n"
   "      self:tabify()\n"
   "    elseif sequenceLength > 0 then -- array tables have one extra space before closing }\n"
   "      self:puts(' ')\n"
   "    end\n"
   "\n"
   "    self:puts('}')\n"
   "  end\n"
   "end\n"
   "\n"
   "function Inspector:putValue(v)\n"
   "  local tv = type(v)\n"
   "\n"
   "  if tv == 'string' then\n"
   "    self:puts(smartQuote(escape(v)))\n"
   "  elseif tv == 'number' or tv == 'boolean' or tv == 'nil' then\n"
   "    self:puts(tostring(v))\n"
   "  elseif tv == 'table' then\n"
   "    self:putTable(v)\n"
   "  else\n"
   "    self:puts('<',tv,' ',self:getId(v),'>')\n"
   "  end\n"
   "end\n"
   "\n"
   "-------------------------------------------------------------------\n"
   "\n"
   "function inspect.inspect(root, options)\n"
   "  options       = options or {}\n"
   "\n"
   "  local depth   = options.depth   or math.huge\n"
   "  local newline = options.newline or '\\n'\n"
   "  local indent  = options.indent  or '  '\n"
   "  local process = options.process\n"
   "\n"
   "  if process then\n"
   "    root = processRecursive(process, root, {}, {})\n"
   "  end\n"
   "\n"
   "  local inspector = setmetatable({\n"
   "    depth            = depth,\n"
   "    level            = 0,\n"
   "    buffer           = {},\n"
   "    ids              = {},\n"
   "    maxIds           = {},\n"
   "    newline          = newline,\n"
   "    indent           = indent,\n"
   "    tableAppearances = countTableAppearances(root)\n"
   "  }, Inspector_mt)\n"
   "\n"
   "  inspector:putValue(root)\n"
   "\n"
   "  return table.concat(inspector.buffer)\n"
   "end\n"
   "\n"
   "setmetatable(inspect, { __call = function(_, ...) return inspect.inspect(...) end })\n"
   "\n"
   "return inspect\n"
   "\n"},

  {"mm", 
   "local a={e='\\27[0m',br='\\27[1m',di='\\27[2m',it='\\27[3m',un='\\27[4m',bl='\\27[5m',re='\\27[7m',hi='\\27[8m',k='\\27[30m',r='\\27[31m',g='\\27[32m',y='\\27[33m',b='\\27[34m',m='\\27[35m',c='\\27[36m',w='\\27[37m',_k='\\27[40m',_r='\\27[41m',_g='\\27[42m',_y='\\27[43m',_b='\\27[44m',_m='\\27[45m',_c='\\27[46m',_w='\\27[47m'}local b={\"<metatable>\",colors=a.it..a.y}local c=\"   \"local d=\" \"local e,f,g=1,2,3;local h={{\"{\",colors=a.br},\",\",{\"}\",colors=a.br}}local i=30;local j=i*2;local k={\"Cherry\",\"Apple\",\"Lemon\",\"Blueberry\",\"Jam\",\"Cream\",\"Rhubarb\",\"Lime\",\"Butter\",\"Grape\",\"Pomegranate\",\"Sugar\",\"Cinnamon\",\"Avocado\",\"Honey\"}local l={a.r,a.g,a.y,a.b,a.m,a.c}local m={['and']=true,['break']=true,['do']=true,['else']=true,['elseif']=true,['end']=true,['false']=true,['for']=true,['function']=true,['goto']=true,['if']=true,['in']=true,['local']=true,['nil']=true,['not']=true,['or']=true,['repeat']=true,['return']=true,['then']=true,['true']=true,['until']=true,['while']=true}local function n()local o=1;local p=1;local q=1;return function()local r=k[o]if p>1 then r=r..\" \"..tostring(p)end;o=o+1;if o>#k then o=1;p=p+1 end;local s=l[q]q=q+1;if q>#l then q=1 end;return{r,colors=a.un..s}end end;local function t()return{occur={},named={},next_name=n(),prev_indent='',next_indent=c,line_len=0,max_width=78,result=''}end;local u={}local v,w;function v(x,y)local z=u[type(x)]if z then return z(x,y)end;if y.occur[x]then if not y.named[x]then y.named[x]=y.next_name()end;return{id=x}else y.occur[x]=true;return{id=x,def=tostring(x)}end end;u['function']=function(x,y)if y.occur[x]then if not y.named[x]then y.named[x]=y.next_name()end else y.occur[x]=true end;return{id=x}end;function u.table(x,y)if y.occur[x]then if not y.named[x]then y.named[x]=y.next_name()end;return{id=x}else y.occur[x]=true;local r={bracket=h}local A={\"=\",colors=a.di}local B=getmetatable(x)if B then B=v(B,y)table.insert(r,{b,A,B})end;for C,D in pairs(x)do if w(C)then C={C,colors=a.m}else C=v(C,y)end;D=v(D,y)table.insert(r,{C,A,D})end;return{id=x,def=r}end end;function u.string(x,y)if#x<=j then local E=string.format('%q',x)E=string.gsub(E,'\\n','n')return{E,colors=a.g}else local E=string.format('%q',string.sub(x,1,i))E=string.gsub(E,'\\n','n')local F=string.format('%q',string.sub(x,-i))F=string.gsub(F,'\\n','n')return{E,{\"...\",colors=a.di},F,colors=a.g,sep='',tight=true}end end;function u.number(x,y)return{tostring(x),colors=a.m..a.br}end;function w(x)if type(x)~='string'then return false end;if string.find(x,'^[_%a][_%a%d]*$')then if m[x]then return false else return true end else return false end end;local function G(H,y)if type(H)=='table'then if H.id then local I=y.named[H.id]local J=H.def;if I then local K={\"<\",type(H.id),\" \",I,\">\",colors=a.it,sep='',tight=true}if J then return{K,{\"is\",colors=a.di},G(H.def,y)}else return K end else if J then return G(H.def,y)else return{\"<\",type(H.id),\">\",colors=a.it,sep='',tight=true}end end elseif H.bracket then for L,M in ipairs(H)do H[L]=G(M,y)end;return H else for L,M in ipairs(H)do H[L]=G(M,y)end;return H end else return H end end;local N,O,P,Q,R,S,T,U,V,W,X,Y,Z;function O(H,y)if type(H)=='string'then return R(H,y)elseif H.bracket then return P(H,y)else return Q(H,y)end end;function P(_,y)if#_==0 then local a0={_.bracket[e],_.bracket[g],sep='',tight=true}return O(a0,y)end;local a1=N(_)if a1<=Y(y)then return S(_,y)elseif a1<=Z(y)then U(y)return S(_,y)else return T(_,y)end end;function S(_,y)O(_.bracket[e],y)W(\" \",y)O(_[1],y)for L=2,#_ do local M=_[L]W(_.bracket[f],y)W(\" \",y)O(M,y)end;W(\" \",y)O(_.bracket[g],y)end;function T(_,y)local a2=y.prev_indent;local a3=y.next_indent;O(_.bracket[e],y)y.prev_indent=a3;y.next_indent=a3 ..c;for L=1,#_-1 do local M=_[L]V(y)W(a3,y)O(M,y)W(_.bracket[f],y)end;do local M=_[#_]V(y)W(a3,y)O(M,y)end;V(y)W(a2,y)O(_.bracket[g],y)y.prev_indent=a2;y.next_indent=a3 end;function Q(H,y)if#H>0 then if H.tight then local a1=N(H,y)if a1>Y(y)and a1<=Z(y)then U(y)end end;if H.colors then X(H.colors,y)end;O(H[1],y)for L=2,#H do local M=H[L]if H.colors then X(H.colors,y)end;W(H.sep or d,y)O(M,y)end;if H.colors then X(a.e,y)end end end;function R(H,y)local a1=N(H)if a1>Y(y)and a1<=Z(y)then U(y)end;W(H,y)end;function N(H,y)if type(H)=='string'then return#H end;local r=0;if H.bracket then if#H==0 then return N(H.bracket[e])+N(H.bracket[g])end;r=r+N(H.bracket[e])+N(H.bracket[g])+2;r=r+(#H-1)*(#H.bracket[f]+1)else if#H==0 then return 0 end;r=r+(#H-1)*#(H.sep or d)end;for a4,M in ipairs(H)do r=r+N(M,y)end;return r end;function U(y)y.result=y.result..\"\\n\"y.line_len=0;W(y.next_indent,y)end;function V(y)y.result=y.result..\"\\n\"y.line_len=0 end;function W(a0,y)y.result=y.result..a0;y.line_len=y.line_len+#a0 end;function X(a0,y)y.result=y.result..a0 end;function Y(y)return math.max(0,y.max_width-y.line_len)end;function Z(y)return math.max(0,y.max_width-#y.next_indent)end;return function(x)if x==nil then print(nil)else local y=t()local H=v(x,y)H=G(H,y)O(H,y)print(a.e..y.result..a.e)end end\n"},

  {"parser", 
   "local RuleComponent = require \"rulecomponent\"\n"
   "local json = require \"dkjson\"\n"
   "--local mm = require \"mm\"\n"
   "\n"
   "local function parseRulesetThing(parser, data_in, opt)\n"
   "  local data = data_in[opt.key]\n"
   "  parser:pushContext(data, opt.key)\n"
   "  local ruleset = parser.ruleset\n"
   "  \n"
   "  if data then\n"
   "    parser:assert_type(data, opt.type, \"wrong type for ruleset %s, expected %s, got %s\", opt.key, opt.type, parser:jsontype(data))\n"
   "    local ret, err\n"
   "    for k,v in pairs(data) do\n"
   "      parser:assert_type(k, \"string\", \"wrong key type for %s, expected string, got %s %s\", opt.thing, parser:jsontype(k), tostring(k))\n"
   "      ret, err = opt.parser_method(parser, v, k)\n"
   "      parser:assert(ret, err)\n"
   "      parser:assert(ruleset[opt.key][ret.name] == nil, \"%s %s already exists\", opt.thing, ret.name)\n"
   "      ruleset[opt.key][ret.name]=ret\n"
   "    end\n"
   "  end\n"
   "  parser:popContext()\n"
   "  return true\n"
   "end\n"
   "\n"
   "local function inheritmetatable(dst, src)\n"
   "  if type(dst) == type(src) then\n"
   "    setmetatable(dst, getmetatable(src))\n"
   "  end\n"
   "end\n"
   "\n"
   "local getloc; do --location caching\n"
   "  local lc = setmetatable({}, {__mode=\"k\"}) -- weak keys\n"
   "  getloc = function(str, where)\n"
   "    local line, pos, linepos = 1, 1, 0\n"
   "    local prev = lc[str]\n"
   "    if prev and prev.pos < where then\n"
   "      line = prev.line\n"
   "      pos = prev.pos\n"
   "    end\n"
   "    while true do\n"
   "      pos = str:find(\"\\n\", pos, true)\n"
   "      if pos and pos < where then\n"
   "        line = line + 1\n"
   "        linepos = pos\n"
   "        pos = pos + 1\n"
   "      else\n"
   "        break\n"
   "      end\n"
   "    end\n"
   "    return line, (where - linepos) -- line, column\n"
   "  end\n"
   "end\n"
   "\n"
   "local function jsonmeta(what)\n"
   "  return function(str, where)\n"
   "    local line, column = getloc(str, where)\n"
   "    return {__pos=where,__line=line, __column=column,  __jsontype = what, __jsonmeta = true}\n"
   "  end\n"
   "end\n"
   "\n"
   "local Parser = {}\n"
   "\n"
   "function Parser:jsontype(var)\n"
   "  if type(var) == \"table\" then\n"
   "    local m = getmetatable(var)\n"
   "    return m and m.__jsontype or nil\n"
   "  else\n"
   "    return type(var)\n"
   "  end\n"
   "end\n"
   "function Parser:assert(cond, err, ...)\n"
   "  if not cond then self:error(err, ...) end\n"
   "  return cond\n"
   "end\n"
   "function Parser:assert_type(var, expected_type, err, ...)\n"
   "  if err then\n"
   "    return self:assert(type(var) == expected_type, err, ...)\n"
   "  else\n"
   "    return self:assert(type(var) == expected_type, \"expected type '%s', got '%s'\", expected_type, type(var))\n"
   "  end\n"
   "end\n"
   "function Parser:assert_jsontype(var, expected_type, err, ...)\n"
   "  if err then\n"
   "    return self:assert(self:jsontype(var) == expected_type, err, ...)\n"
   "  else\n"
   "    return self:assert(self:jsontype(var) == expected_type,\"expected JSON type '%s', got '%s'\", expected_type, self:jsontype(var))\n"
   "  end\n"
   "end\n"
   "function Parser:assert_table_size(var, expected_size, err, ...)\n"
   "  self:assert_type(var, \"table\")\n"
   "  local n = 0\n"
   "  for _, _ in pairs(var) do\n"
   "    n = n + 1\n"
   "  end\n"
   "  if n ~= expected_size then\n"
   "    if err then\n"
   "      self:error(err, ...)\n"
   "    else\n"
   "      self:error(\"wrong table size, expected %i, got %i\", expected_size, n)\n"
   "    end\n"
   "  end\n"
   "  return var\n"
   "end\n"
   "\n"
   "local function getlc(tbl)\n"
   "  local mt = getmetatable(tbl)\n"
   "  if mt.__line and mt.__column then\n"
   "    return mt.__line, mt.__column\n"
   "  end\n"
   "end\n"
   "\n"
   "local function getlc_str(tbl)\n"
   "  local line, col = getlc(tbl)\n"
   "  if line and col then\n"
   "    return (\"line %s column %i\"):format(line, col)\n"
   "  else\n"
   "    return nil\n"
   "  end\n"
   "end\n"
   "\n"
   "function Parser:get(what, name)\n"
   "  if     what == \"rule\" then return self:getRule(name)\n"
   "  elseif what == \"list\" then return self:getList(name)\n"
   "  elseif what == \"limiter\" then return self:getLimiter(name)\n"
   "  else\n"
   "    error(\"unknown thing to get\")\n"
   "  end\n"
   "end\n"
   "\n"
   "function Parser:error(err, ...)\n"
   "  \n"
   "  if not err then err = \"unknown error\" end\n"
   "  if select(\"#\", ...) > 0 then\n"
   "    err = err:format(...)\n"
   "  end\n"
   "  \n"
   "  local nested_names = {}\n"
   "  \n"
   "  for i=#self.ctx_stack,1,-1 do\n"
   "    local cur = self.ctx_stack[i]\n"
   "    if cur.name then table.insert(nested_names, cur.name) end\n"
   "    local lc_str = getlc_str(cur.ctx)\n"
   "    if lc_str then\n"
   "      if self.name then table.insert(nested_names, self.name) end\n"
   "      error((\"%s at %s: %s\"):format(table.concat(nested_names, \" in \"), lc_str, err))\n"
   "    end\n"
   "  end\n"
   "  if self.name then table.insert(nested_names, self.name) end\n"
   "  if #nested_names > 0 then\n"
   "    error((\"%s: %s\"):format(table.concat(nested_names, \" in \"), err))\n"
   "  else\n"
   "    error(err)\n"
   "  end\n"
   "end\n"
   "\n"
   "function Parser:setInterpolationChecker(func)\n"
   "  self.interpolation_checker = func\n"
   "end\n"
   "function Parser:checkInterpolatedString(str)\n"
   "  if self.interpolation_checker then\n"
   "    self.interpolation_checker(str, self)\n"
   "  end\n"
   "  return true\n"
   "end\n"
   "\n"
   "function Parser:pushContext(ctx, name)\n"
   "  table.insert(self.ctx_stack, {ctx=ctx, name=name})\n"
   "  self.context = self.ctx_stack[#self.ctx_stack]\n"
   "  return self\n"
   "end\n"
   "function Parser:popContext()\n"
   "  table.remove(self.ctx_stack, #self.ctx_stack)\n"
   "  self.context = self.ctx_stack[#self.ctx_stack]\n"
   "end\n"
   "function Parser:getContext(name)\n"
   "  if not name then return self.context and self.context.ctx end\n"
   "  for i=#self.ctx_stack, 1, -1 do\n"
   "    local cur = self.ctx_stack[i]\n"
   "    if cur.name==name then\n"
   "      return cur.ctx\n"
   "    end\n"
   "  end\n"
   "  return nil\n"
   "end\n"
   "function Parser:printContext()\n"
   "  for i=#self.ctx_stack, 1, -1 do\n"
   "    local cur = self.ctx_stack[i]\n"
   "    print(cur.name or \"<?>\", self:jsontype(cur.ctx) or \"<?>\", getlc_str(cur.ctx) or \"\")\n"
   "  end\n"
   "end\n"
   "\n"
   "function Parser:parseFile(path, unprotected)\n"
   "  local file, err = io.open(path, \"rb\") -- r read mode and b binary mode\n"
   "  if not file then return nil, err end\n"
   "  local content = file:read(\"*a\") -- *a or *all reads the whole file\n"
   "  file:close()\n"
   "  self.name = path\n"
   "  return self:parseJSON(\"ruleset\", content, \"file \" .. path, unprotected)\n"
   "end\n"
   "\n"
   "function Parser:parseJSON(element_name, json_str, json_name, unprotected)\n"
   "  self:assert_type(json_str, \"string\", (\"expected a JSON string, got %s\"):format(type(json_str)))\n"
   "  local data, _, err = json.decode(json_str, 1, json.null, jsonmeta(\"object\"), jsonmeta(\"array\"))\n"
   "  if not self.name then self.name = json_name end\n"
   "  \n"
   "  local function parse_it()\n"
   "    if not data then self:error(\"Error parsing JSON: \" .. err) end\n"
   "    if element_name == \"ruleset\" then\n"
   "      return self:parseRuleSet(data)\n"
   "    elseif element_name == \"phase\" then\n"
   "      return self:parsePhase(data)\n"
   "    elseif element_name == \"limiter\" then\n"
   "      return self:parseLimiter(data)\n"
   "    elseif element_name == \"list\" then\n"
   "      return self:parseList(data)\n"
   "    elseif element_name == \"rule\" then\n"
   "      return self:parseRule(data)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  if unprotected then\n"
   "    return parse_it()\n"
   "  else\n"
   "    local ok, res = pcall(parse_it)\n"
   "    if not ok then\n"
   "      return nil, (res:match(\"[^:]*:%d+: (.*)\") or res)\n"
   "    else\n"
   "      return res\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "function Parser:parseInterpolatedString(str)\n"
   "  --validate the string\n"
   "  for sub in str:gmatch(\"%$%b{}\") do\n"
   "    if not sub:match(\"^%${[%w_]+}\") then\n"
   "      self:error(\"invalid variable \\\"%s\\\" in interpolated string\", sub)\n"
   "    end\n"
   "  end\n"
   "  for sub in str:gmatch(\"%${?[%w_]*}?\") do\n"
   "    if sub:sub(2,2) == \"{\" then\n"
   "      if sub:sub(-1) ~=\"}\" then --unterminated bracket\n"
   "        self:error(\"missing '}' in interpolated string\")\n"
   "      end\n"
   "      sub=sub:sub(3, -2)\n"
   "      if sub == \"\" then\n"
   "        self:error(\"invalid variable ${} in interpolated string\")\n"
   "      elseif sub:match(\"^%d%d+\") then\n"
   "        self:error(\"invalid regex capture \\\"%s\\\" in interpolated string. 1-9 only (nginx quirk)\", sub)\n"
   "      elseif sub:match(\"^%d.+\") then\n"
   "        self:error(\"invalid variable \\\"%s\\\" in interpolated string. can't sart with a number (nginx quirk)\", sub)\n"
   "      end\n"
   "    else\n"
   "      sub=sub:sub(2, -1)\n"
   "    end\n"
   "    if sub == \"\" then\n"
   "      self:error(\"invalid empty variable in interpolated string\")\n"
   "    end\n"
   "    \n"
   "  end\n"
   "  \n"
   "  return {string = str}\n"
   "end\n"
   "\n"
   "local function attr_present(parser, data, attr_name, err)\n"
   "  local target = attr_name and data[attr_name] or data\n"
   "  if not target then\n"
   "    if parser.allow_incomplete then\n"
   "      data.incomplete = true\n"
   "      parser.incomplete = true\n"
   "    else\n"
   "      parser:error(err or \"missing required attribute \\\"%s\\\"\", attr_name)\n"
   "    end\n"
   "    return false\n"
   "  else\n"
   "    return true\n"
   "  end\n"
   "end\n"
   "\n"
   "function Parser:parseRuleSet(data, name)\n"
   "  self:pushContext(data, \"ruleset\")\n"
   "  \n"
   "  self:assert_type(data, \"table\", \"wrong type for ruleset\")\n"
   "  self.ruleset.name = name or data.name\n"
   "  \n"
   "  if attr_present(self, data, \"limiters\") then\n"
   "    parseRulesetThing(self, data, {\n"
   "      thing=\"limiter\", key=\"limiters\", type=\"table\",\n"
   "      parser_method= self.parseLimiter\n"
   "    })\n"
   "    self:checkLimiters(data.limiters)\n"
   "  end\n"
   "  \n"
   "  --luacheck: push ignore 432 --don't mind the shadowing\n"
   "  if attr_present(self, data, \"rules\") then\n"
   "    parseRulesetThing(self, data, {\n"
   "      thing=\"rule\", key=\"rules\",  type=\"table\",\n"
   "      parser_method=function(self, data, name)\n"
   "        self:pushContext(data, \"rule\")\n"
   "        self:assert(type(data) ~= \"string\", (\"named rule \\\"%s\\\" cannot be a string referring to another named rule \\\"%s\\\"\"):format(name, tostring(data)))\n"
   "        self:popContext()\n"
   "        return self:parseRule(data, name)\n"
   "      end\n"
   "    })\n"
   "  end\n"
   "  --luacheck: pop\n"
   "  \n"
   "  if attr_present(self, data, \"lists\") then\n"
   "    parseRulesetThing(self, data, {\n"
   "      thing=\"list\", key=\"lists\",  type=\"table\",\n"
   "      parser_method= self.parseList\n"
   "    })\n"
   "  end\n"
   "  \n"
   "  if attr_present(self, data, \"phases\") then\n"
   "    self.ruleset.phases = self:parsePhaseTable(data.phases)\n"
   "  end\n"
   "  --convert debug metatable data to __dbg table whenever possible\n"
   "  local function move_dbg_data(tbl)\n"
   "    local meta = getmetatable(tbl)\n"
   "    if meta and meta.__jsonmeta then\n"
   "      setmetatable(tbl, {line=meta.__line, col=meta.__column})\n"
   "    end\n"
   "    for _, v in pairs(tbl) do\n"
   "      if type(v) == \"table\" then\n"
   "        move_dbg_data(v)\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "  move_dbg_data(self.ruleset)\n"
   "  \n"
   "  return self.ruleset\n"
   "end\n"
   "\n"
   "function Parser:parsePhaseTable(data)\n"
   "  self:assert(data ~= nil, \"missing phase table (\\\"phases\\\" attribute)\")\n"
   "  self:assert_jsontype(data, \"object\", \"phase table must be an object\")\n"
   "  self:pushContext(data, \"phase table\")\n"
   "  \n"
   "  self:assert(not data.external, \"forbidden attribute \\\"external\\\"\")\n"
   "  \n"
   "  for phase_name, phase_data in pairs(data) do\n"
   "    self:assert_type(phase_name, \"string\", \"phase table entries must be strings\")\n"
   "    if self:jsontype(phase_data) == \"array\" then\n"
   "      for i, list in ipairs(phase_data) do\n"
   "        if type(list)==\"string\" or self:jsontype(list) == \"array\" or self:jsontype(list) == \"object\" then\n"
   "          phase_data[i]=self:parseList(list)\n"
   "        else\n"
   "          self:error(\"invalid rule list type: %s\", self:jsontype(list))\n"
   "        end\n"
   "      end\n"
   "    elseif type(phase_data) == \"string\" then\n"
   "      --singe named list\n"
   "      data[phase_name]={ self:parseList(phase_data) }\n"
   "    elseif self:jsontype(phase_data)==\"object\" then\n"
   "      --single long-form list\n"
   "      data[phase_name]=self:parseList(phase_data)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  self:popContext()\n"
   "  \n"
   "  return data\n"
   "end\n"
   "\n"
   "function Parser:getList(name)\n"
   "  local list = self.ruleset.lists[name]\n"
   "  if not list and self.external then\n"
   "    list = self.external.lists[name]\n"
   "  end\n"
   "  return list\n"
   "end\n"
   "\n"
   "function Parser:parseList(data, name)\n"
   "  if type(data)==\"string\" then\n"
   "    return self:assert(self:getList(data), ([[named list \"%s\" not found]]):format(data))\n"
   "  end\n"
   "  self:pushContext(data, \"list\")\n"
   "  local list = {}\n"
   "  if self:jsontype(data) == \"object\" then\n"
   "    self:assert(not data.external, \"forbidden attribute \\\"external\\\"\")\n"
   "    if name then\n"
   "      self:assert(name == data.name, \"rule list 'name' attribute must match outside list name\")\n"
   "    else\n"
   "      name = tostring(data.name)\n"
   "    end\n"
   "    data = data.rules\n"
   "  end\n"
   "  \n"
   "  local rules\n"
   "  \n"
   "  if attr_present(self, data, nil, \"missing rule list\") then\n"
   "    self:assert_jsontype(data, \"array\", \"rule list must be an array\")\n"
   "    rules = {}\n"
   "    for _,v in ipairs(data) do\n"
   "      table.insert(rules, self:parseRule(v))\n"
   "    end\n"
   "  end\n"
   "  self:popContext()\n"
   "  list.name=name\n"
   "  list.rules=rules\n"
   "  inheritmetatable(list, data)\n"
   "  return list\n"
   "end\n"
   "\n"
   "function Parser:getRule(name)\n"
   "  local r = self.ruleset.rules[name]\n"
   "  if not r and self.external then\n"
   "    r = self.external.rules[name]\n"
   "  end\n"
   "  return r\n"
   "end\n"
   "\n"
   "function Parser:parseRule(data, name)\n"
   "  self:pushContext(data, \"rule\")\n"
   "  local rule\n"
   "  if type(data) == \"string\" then\n"
   "    rule = self:getRule(data)\n"
   "    self:assert(rule, ([[named rule \"%s\" not found]]):format(data))\n"
   "    self:popContext()\n"
   "    return rule\n"
   "  end\n"
   "  self:assert_type(data, \"table\", \"invalid rule data type: \" .. type(data))\n"
   "  self:assert_jsontype(data, \"object\", (\"invalid rule data type: %s\"):format(self:jsontype(data)))\n"
   "  \n"
   "  self:assert(not data.external, \"forbidden attribute \\\"external\\\"\")\n"
   "  \n"
   "  if ((data[\"if\"] or data[\"if-any\"] or data[\"if-all\"]) or data[\"then\"]) then\n"
   "    self:assert(not data[\"always\"], [[\"always\" clause can't be present in if/then rule]])\n"
   "    self:assert(not data[\"switch\"], [[\"switch\" clause can't be present in if/then rule]])\n"
   "  end\n"
   "  \n"
   "  if data[\"then\"] then\n"
   "    if (data[\"if\"] and (data[\"if-any\"] or data[\"if-all\"])) or (data[\"if-any\"] and data[\"if-all\"]) then\n"
   "      self:error(\"only one of \\\"if\\\", \\\"if-any\\\" or \\\"if-all\\\" allowed in if/then rule\")\n"
   "    end\n"
   "    \n"
   "    local condition\n"
   "    if data[\"if\"] then\n"
   "      self:pushContext(data, \"if\")\n"
   "      condition = self:parseCondition(data[\"if\"])\n"
   "      self:popContext()\n"
   "    elseif data[\"if-any\"] or data[\"if-all\"] then\n"
   "      local conditions = {}\n"
   "      self:pushContext(data, \"if\")\n"
   "      for _, v in ipairs(data[\"if-any\"] or data[\"if-all\"]) do\n"
   "        condition = self:assert(self:parseCondition(v))\n"
   "        table.insert(conditions, condition)\n"
   "      end\n"
   "      self:popContext()\n"
   "      condition = {[(data[\"if-any\"] and \"any\" or \"all\")]=conditions}\n"
   "      inheritmetatable(condition, data[\"if\"] or data[\"if-any\"] or data[\"if-all\"])\n"
   "      data[\"if-any\"]=nil\n"
   "      data[\"if-all\"]=nil\n"
   "    end\n"
   "    data[\"if\"]=condition\n"
   "  elseif data[\"always\"] then\n"
   "    data[\"if\"]={[\"true\"]={}}\n"
   "    data[\"then\"]=data[\"always\"]\n"
   "    data[\"always\"]=nil\n"
   "  elseif next(data) == nil then\n"
   "    self:error(\"empty rule not allowed\")\n"
   "  elseif self.allow_incomplete then\n"
   "    data.incomplete = true\n"
   "    self.incomplete = true\n"
   "  else\n"
   "    self:error(\"rule must have at least an \\\"if\\\", \\\"then\\\", or \\\"always\\\" attribute\")\n"
   "  end\n"
   "  \n"
   "  if not data.name then\n"
   "    data.name = name\n"
   "  end\n"
   "  \n"
   "  if data[\"if\"] then\n"
   "    if attr_present(self, data, \"then\") then\n"
   "      data[\"then\"] = self:parseActions(data[\"then\"], \"then\")\n"
   "    end\n"
   "    if data[\"else\"] or not self.allow_incomplete then\n"
   "      data[\"else\"] = self:parseActions(data[\"else\"], \"else\")\n"
   "    end\n"
   "  end\n"
   "  if data.key then\n"
   "    data.key = self:parseInterpolatedString(data.key)\n"
   "  end\n"
   "  \n"
   "  self:popContext()\n"
   "  --reuse metatable for debugging purposes\n"
   "  return data\n"
   "end\n"
   "\n"
   "function Parser:parseCondition(data)\n"
   "  self:pushContext(data, \"condition\")\n"
   "  local condition\n"
   "  if type(data) == \"string\" then\n"
   "    condition = {[data]={}}\n"
   "  elseif type(data) == \"table\" then\n"
   "    self:assert_jsontype(data, \"object\", \"condition cannot be an array, must be an object\")\n"
   "    self:assert_table_size(data, 1, \"condition object must have exactly one attribute (the condition name)\")\n"
   "    condition = data\n"
   "  else\n"
   "    self:error(\"wrong type (%s) for condition\", type(data))\n"
   "  end\n"
   "  self:popContext()\n"
   "  -- be more specific with condition name\n"
   "  self:pushContext(data, \"condition \" .. (next(condition)))\n"
   "  condition = RuleComponent.condition.parse(condition, self)\n"
   "  self:popContext()\n"
   "  inheritmetatable(condition, data)\n"
   "  return condition\n"
   "end\n"
   "  \n"
   "function Parser:parseAction(data)\n"
   "  self:pushContext(data, \"action\")\n"
   "  local action\n"
   "  if type(data) == \"string\" then\n"
   "    action = {[data]={}}\n"
   "  elseif self:jsontype(data) == \"object\" then\n"
   "    self:assert(next(data, next(data)) == nil, \"action object must have only 1 attribute -- the action name\")\n"
   "    action = data\n"
   "  else\n"
   "    self:error(\"action must be string on 1-attribute object, but instead was a %s\", self:jsontype(data))\n"
   "  end\n"
   "  self:popContext()\n"
   "  --we can be more specific about the action name now\n"
   "  self:pushContext(data, (\"\\\"%s\\\" action\"):format(next(action)))\n"
   "  inheritmetatable(action, data)\n"
   "  action = RuleComponent.action.parse(action, self)\n"
   "  self:popContext()\n"
   "  return action\n"
   "end\n"
   "\n"
   "function Parser:parseActions(data, name)\n"
   "  if data == nil then\n"
   "    return {}\n"
   "  end\n"
   "  self:pushContext(data, name and (\"\\\"%s\\\" actions\"):format(name) or nil)\n"
   "  local actions = {}\n"
   "  inheritmetatable(actions, data)\n"
   "  if self:jsontype(data) == \"object\" or type(data)==\"string\" or (#data == 0 and next(data) ~= nil) then\n"
   "    table.insert(actions, self:parseAction(data))\n"
   "  elseif type(data) == \"table\" then\n"
   "    for _, v in ipairs(data) do\n"
   "      table.insert(actions, self:parseAction(v))\n"
   "    end\n"
   "  end\n"
   "  self:popContext()\n"
   "  return actions\n"
   "end\n"
   "\n"
   "function Parser:parseTimeInterval(data, err)\n"
   "  if err then err = \" for \" .. err end\n"
   "  local typ = self:jsontype(data)\n"
   "  if typ == \"number\" then\n"
   "    return data\n"
   "  elseif typ == \"string\" then\n"
   "    local num, unit = data:match(\"^([%d.]+)([%w_]*)\")\n"
   "    local scale\n"
   "    num = tonumber(num)\n"
   "    self:assert(num and unit, (\"invalid time string \\\"%s\\\"%s\"):format(data, err))\n"
   "    if unit == \"ms\" or unit:match(\"^millisec(ond(s?))?\") then\n"
   "      scale = .01\n"
   "    elseif unit == \"\" or unit == \"s\" or unit:match(\"^sec(ond(s?))?\") then\n"
   "      scale = 1\n"
   "    elseif unit == \"m\" or unit:match(\"^min(ute(s)?)?\") then\n"
   "      scale = 60\n"
   "    elseif unit == \"h\" or unit:match(\"^hour(s?)\") then\n"
   "      scale = 3600\n"
   "    elseif unit == \"d\" or unit:match(\"^day(s)?\") then\n"
   "      scale = 86400\n"
   "    elseif unit == \"w\" or unit == \"wk\" or unit:match(\"^week(s)?\") then\n"
   "      scale = 604800\n"
   "    elseif unit == \"M\" or unit:match(\"^month(s)?\") then\n"
   "      scale = 2628001\n"
   "    else\n"
   "      self:error(\"unknown time unit \\\"%s\\\"%s\", unit, err)\n"
   "    end\n"
   "    return num * scale\n"
   "  else\n"
   "    self:error(\"invalid time inteval type \\\"%s\\\"%s\", self:jsontype(data), err)\n"
   "  end\n"
   "end\n"
   "\n"
   "function Parser:getLimiter(name)\n"
   "  local lim = self.ruleset.limiters[name]\n"
   "  if not lim and self.external then\n"
   "    lim = self.external.limiters[name]\n"
   "  end\n"
   "  return lim\n"
   "end\n"
   "\n"
   "function Parser:parseLimiter(data, name)\n"
   "  self:pushContext(data, \"limiter\")\n"
   "  \n"
   "  if not data.name then data.name = name end\n"
   "  \n"
   "  self:assert(not data.external, \"forbidden attribute \\\"external\\\"\")\n"
   "  \n"
   "  if attr_present(self, data, \"interval\") then\n"
   "    data.interval = self:parseTimeInterval(data.interval, \"interval value\")\n"
   "    self:assert(data.interval >= 60, \"\\\"interval\\\" value must be >= 60 seconds\")\n"
   "  end\n"
   "  \n"
   "  if attr_present(self, data, \"limit\") then\n"
   "    data.limit = self:assert(tonumber(data.limit), \"invalid \\\"limit\\\" value, must be a number\")\n"
   "    self:assert(data.limit >= 0, \"\\\"limit\\\" value must be >= 0\")\n"
   "  end\n"
   "  \n"
   "  if data.sync_steps then\n"
   "    data.sync_steps = self:assert(tonumber(data.sync_steps), \"invalid \\\"sync-steps\\\" value\")\n"
   "  end\n"
   "  if data.burst then\n"
   "    self:assert_type(data.burst, \"string\", \"invalid \\\"burst\\\" value type\")\n"
   "  end\n"
   "  if data[\"burst-expire\"] then\n"
   "    data.burst_expire = self:parseTimeInterval(data[\"burst-expire\"], \"burst_expire value\")\n"
   "    data[\"burst-expire\"] = nil\n"
   "  end\n"
   "  \n"
   "  self:assert_type(data.name, \"string\", \"invalid limiter name\")\n"
   "  self:popContext()\n"
   "  return data\n"
   "end\n"
   "function Parser:checkLimiters(data)\n"
   "  if not data then return true end\n"
   "  self:pushContext(data, \"limiters\")\n"
   "  for _, v in pairs(data) do\n"
   "    self:pushContext(v, (\"limiter \\\"%s\\\"\"):format(v.name))\n"
   "    if v.burst then\n"
   "      --make sure the burst value refers to a known limiter\n"
   "      self:assert(data[v.burst], (\"limiter references unknown burst limiter \\\"%s\\\"\"):format(v.burst))\n"
   "    end\n"
   "    self:popContext()\n"
   "  end\n"
   "  self:popContext()\n"
   "end\n"
   "\n"
   "local Parser_meta = {__index = Parser}\n"
   "\n"
   "local function newparser(opt)\n"
   "  local parser = {\n"
   "    name = \"<?>\",\n"
   "    ctx_stack = {},\n"
   "    ruleset = {\n"
   "      limiters = {},\n"
   "      rules = {},\n"
   "      lists = {},\n"
   "      phases ={},\n"
   "    }\n"
   "  }\n"
   "  \n"
   "  opt = opt or {}\n"
   "  if opt.external then\n"
   "    parser.external = {}\n"
   "    for k, n in pairs{lists=\"list\", rules=\"rule\", limiters=\"limiter\"} do\n"
   "      local fn = opt.external[n]\n"
   "      parser.external[k]=setmetatable({}, {__index = function(tbl, key)\n"
   "        local ret = fn(parser, key)\n"
   "        if ret then\n"
   "          if type(ret) ~= \"table\" then\n"
   "            ret = {name=key, external=true}\n"
   "          else\n"
   "            ret.external = true\n"
   "            if not ret.name then ret.name = key end\n"
   "          end\n"
   "        end\n"
   "        tbl[key]=ret\n"
   "        return ret\n"
   "      end})\n"
   "    end\n"
   "  end\n"
   "  if opt.allow_incomplete then\n"
   "    parser.allow_incomplete = true\n"
   "  end\n"
   "\n"
   "  setmetatable(parser, Parser_meta)\n"
   "  return parser\n"
   "end\n"
   "\n"
   "return {\n"
   "  new = newparser,\n"
   "  RuleComponent = RuleComponent\n"
   "}\n"},

  {"redis", 
   "local module = {c={}}\n"
   "local mm = require \"mm\"\n"
   "--luacheck: globals newRedis unpack\n"
   "\n"
   "local Redis = {}\n"
   "local rmeta = {__index = Redis}\n"
   "local scripts = {}\n"
   "local script_hash = {}\n"
   "\n"
   "--[[local table_rip = function(tbl)\n"
   "  local keys = {}\n"
   "  local vals = {}\n"
   "  for k, v in pairs(tbl) do\n"
   "    table.insert(keys, k)\n"
   "    table.insert(vals, v)\n"
   "  end\n"
   "  return keys, vals\n"
   "end\n"
   "]]\n"
   "\n"
   "local tunpack = table.unpack or unpack\n"
   "\n"
   "local function current_coroutine()\n"
   "  local co, main = coroutine.running()\n"
   "  if co and main == true then\n"
   "    co = nil\n"
   "  end\n"
   "  return co\n"
   "end\n"
   "\n"
   "local function error_catching_command_handler(res, err)\n"
   "  assert(res, err)\n"
   "end\n"
   "\n"
   "local function infer_command_callback_and_args(first, ...)\n"
   "  local t = type(first)\n"
   "  if t == \"function\" or t == \"thread\" then\n"
   "    return first, ...\n"
   "  else\n"
   "    --compatible with lua 5.1 and >=5.2, which have slightly different coroutine,running() return values\n"
   "    local co = current_coroutine()\n"
   "    \n"
   "    if co == nil then\n"
   "      --no callback, run it with default error-catcher\n"
   "      return error_catching_command_handler, first, ...\n"
   "    end\n"
   "    \n"
   "    --assert(co, \"no callback given to redis command, expected to be run in coroutine\")\n"
   "    return co, first, ...\n"
   "  end\n"
   "end\n"
   "\n"
   "local function raw_redis_command(ctx, ...)\n"
   "  return module.c.redis_command(ctx, infer_command_callback_and_args(...))\n"
   "end\n"
   "\n"
   "local function redis_initialize_connection(self, ctx)\n"
   "  local ret, err\n"
   "  if self.connection_params.pass then\n"
   "    ret, err = raw_redis_command(ctx, \"AUTH\", self.connection_params.pass)\n"
   "    if not ret then\n"
   "      --TODO: error, wrong password\n"
   "      return nil, err\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  if self.connection_params.db then\n"
   "    ret, err = raw_redis_command(ctx, \"SELECT\", self.connection_params.db)\n"
   "    if not ret then\n"
   "      --TODO: error, wrong password\n"
   "      return nil, err\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  return ctx\n"
   "end\n"
   "\n"
   "function Redis:connect()\n"
   "  assert(self:checkStatus(\"disconnected\"), \"should only try to connect when disconnected\")\n"
   "  assert(self.ctx == nil)\n"
   "  assert(self.sub_ctx == nil)\n"
   "  \n"
   "  self:setStatus(\"connecting\")\n"
   "  local err\n"
   "  self.ctx, err = module.c.redis_connect(self.connection_params.host, self.connection_params.port) --synchronous\n"
   "  if not self.ctx then\n"
   "    error(err)\n"
   "  end\n"
   "  self.connection_params.peername = module.c.get_hiredis_asyncContext_peername(self.ctx)\n"
   "  \n"
   "  self.sub_ctx, err = module.c.redis_connect(self.connection_params.peername, self.connection_params.port) --synchronous\n"
   "  if not self.sub_ctx then\n"
   "    error(err)\n"
   "  end\n"
   "  \n"
   "  local function fail(msg)\n"
   "    self:setStatus(\"disconnected\")\n"
   "    if self.ctx then\n"
   "      module.c.redis_close(self.ctx)\n"
   "      self.ctx = nil\n"
   "    end\n"
   "    if self.sub_ctx then\n"
   "      module.c.redis_close(self.sub_ctx)\n"
   "      self.sub_ctx = nil\n"
   "    end\n"
   "    \n"
   "    local my_url = (\"redis://%s:%i%s\"):format(self.connection_params.host, self.connection_params.port, self.connection_params.db and \"/\" .. self.connection_params.db or \"\")\n"
   "    \n"
   "    module.c.log_error(\"error\", (\"Failed to connect to %s: %s. Retry in 5 sec.\"):format(my_url, msg or \"unknown error\"))\n"
   "    \n"
   "    module.c.timeout(5000, coroutine.wrap(function()\n"
   "      self:connect()\n"
   "    end))\n"
   "    return nil\n"
   "  end\n"
   "  \n"
   "  local function get_info(info, what)\n"
   "    local m = \"^\"..what..\":(.*)\"\n"
   "    local ret\n"
   "    for line in info:gmatch('[^\\r\\n]+') do\n"
   "      ret = line:match(m)\n"
   "      if ret then return ret end\n"
   "    end\n"
   "    return nil\n"
   "  end\n"
   "  local function connector()\n"
   "    --luacheck: push ignore 431 --don't mind the shadowing\n"
   "    if not redis_initialize_connection(self, self.ctx) then\n"
   "      return fail(\"error connecting command client\")\n"
   "    end\n"
   "    if not redis_initialize_connection(self, self.sub_ctx) then\n"
   "      return fail(\"error connecting pubsub client\")\n"
   "    end\n"
   "    \n"
   "    local res, info, err\n"
   "    \n"
   "    info, err = raw_redis_command(self.ctx, \"INFO\")\n"
   "    if not info then return fail(err) end\n"
   "    local loading = get_info(info, \"loading\") == \"1\"\n"
   "    \n"
   "    while loading do\n"
   "      --wait until finished loading\n"
   "      module.c.timeout(1000)\n"
   "      info, err = raw_redis_command(self.ctx, \"INFO\")\n"
   "      if not info then return fail(err) end\n"
   "      loading = get_info(info, \"loading\") == \"1\"\n"
   "    end\n"
   "    \n"
   "    local cluster_enabled = get_info(info, \"cluster_enabled\") == \"1\"\n"
   "    if cluster_enabled then\n"
   "      return fail(\"can't handle clusters yet\")\n"
   "    end\n"
   "    \n"
   "    local role = get_info(info, \"role\")\n"
   "    if role ~= \"master\" then\n"
   "      return fail(\"useless to connect to a slave (for now)\")\n"
   "    end\n"
   "    \n"
   "    --load scripts\n"
   "    for name, hash, src in module.eachScript() do\n"
   "      res, err = raw_redis_command(self.ctx, \"SCRIPT\", \"EXISTS\", hash)\n"
   "      if res and res[1]~=1 then\n"
   "        res, err = raw_redis_command(self.ctx, \"SCRIPT\", \"LOAD\", src)\n"
   "        if not res then return fail((\"error in script %s\\n%s\"):format(name, err)) end\n"
   "        if hash ~= res then return fail(\"loaded script hash doesn't match\") end\n"
   "      elseif not res then\n"
   "        return fail(err)\n"
   "      end\n"
   "      raw_redis_command(self.ctx, \"HSET\", \"wafflex:scripts\", name, hash)\n"
   "    end\n"
   "    --loaded the scripts. I think that's everything...\n"
   "    \n"
   "    self:setStatus(\"ready\")\n"
   "    --luacheck: pop\n"
   "  end\n"
   "  \n"
   "  \n"
   "  if current_coroutine() then\n"
   "    return connector()\n"
   "  else\n"
   "    return (coroutine.wrap(connector))()\n"
   "  end\n"
   "end\n"
   "\n"
   "function Redis:subscribe(channel, callback)\n"
   "  \n"
   "  if not self.__subscribe_handler then\n"
   "    self.__subscribe_handler = function(data, err)\n"
   "      if not data then\n"
   "        error(err)\n"
   "      end\n"
   "      local kind = data[1]\n"
   "      if kind ==\"message\" then\n"
   "        local message_handler = self.pubsub_handlers[data[2]]\n"
   "        if message_handler then\n"
   "          message_handler(data[3], data[2])\n"
   "        end\n"
   "      elseif kind == \"unsubscribe\" then\n"
   "        self.pubsub_handlers[data[2]] = nil\n"
   "        if not next(self.pubsub_handlers) then\n"
   "          self.__subscribe_handler = nil\n"
   "        end\n"
   "      end\n"
   "      return self.__subscribe_handler\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  assert(self.pubsub_handlers[channel] == nil, (\"already subscribed to \\\"%s\\\"\"):format(channel))\n"
   "  self.pubsub_handlers[channel]=callback\n"
   "  assert(type(channel) == \"string\")\n"
   "  assert(type(callback) == \"function\")\n"
   "  \n"
   "  local co = current_coroutine()\n"
   "  if co then\n"
   "    local wrapped_callback = function(...)\n"
   "      local ret = self.__subscribe_handler(...)\n"
   "      coroutine.resume(co, ...)\n"
   "      return ret\n"
   "    end\n"
   "    \n"
   "    self:sub_command(wrapped_callback, \"SUBSCRIBE\", channel)\n"
   "    return coroutine.yield()\n"
   "  else\n"
   "    return self:sub_command(self.__subscribe_handler, \"SUBSCRIBE\", channel)\n"
   "  end\n"
   "end\n"
   "\n"
   "function Redis:unsubscribe(channel)\n"
   "  if not self.pubsub_handlers[channel] then\n"
   "    return nil, \"not subscribed to \" .. tostring(channel)\n"
   "  end\n"
   "  \n"
   "  local co = current_coroutine()\n"
   "  if co then\n"
   "    local wrapped_callback = function(...)\n"
   "      local ret = self.__subscribe_handler(...)\n"
   "      coroutine.resume(co, ...)\n"
   "      return ret\n"
   "    end\n"
   "    \n"
   "    self:sub_command(wrapped_callback, \"UNSUBSCRIBE\", channel)\n"
   "    return coroutine.yield()\n"
   "  else\n"
   "    return self:sub_command(self.__subscribe_handler, \"UNSUBSCRIBE\", channel)\n"
   "  end\n"
   "end\n"
   "\n"
   "local function redis_command(self, ctx_name, ...)\n"
   "  if self:checkStatus(\"ready\") then\n"
   "    return raw_redis_command(self[ctx_name], infer_command_callback_and_args(...))\n"
   "  else\n"
   "    local args = {infer_command_callback_and_args(...)}\n"
   "    if type(args[1]) == \"thread\" then\n"
   "      --we're in a coroutine\n"
   "      table.insert(self.pending_commands, {coroutine=args[1]})\n"
   "      assert(coroutine.yield() == \"ready now\") --wait until resumed when ready\n"
   "      return redis_command(self, ctx_name, ...)\n"
   "    else\n"
   "      table.insert(self.pending_commands, {ctx_name = ctx_name, args=args})\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "local legit_status = {\n"
   "  disconnected = 1,\n"
   "  connecting = 2,\n"
   "  authenticating = 3,\n"
   "  ready = 4\n"
   "}\n"
   "function Redis:getStatus()\n"
   "  return self.__status\n"
   "end\n"
   "function Redis:checkStatus(compare)\n"
   "  if not legit_status[compare] then\n"
   "    error(\"invalid status \" .. tostring(compare))\n"
   "  end\n"
   "  return (self.__status or \"disconnected\") == compare\n"
   "end\n"
   "function Redis:setStatus(status)\n"
   "  if not legit_status[status] then\n"
   "    error(\"invalid status \" .. tostring(status))\n"
   "  end\n"
   "  local prev_status = self.__status\n"
   "  self.__status = status\n"
   "  \n"
   "  if status == \"ready\" and prev_status ~= \"ready\" then\n"
   "    for _, cmd in ipairs(self.pending_commands) do\n"
   "      mm(cmd)\n"
   "      if cmd.coroutine then\n"
   "        coroutine.resume(cmd.coroutine, \"ready now\")\n"
   "      else\n"
   "        redis_command(self, cmd.ctx_name, tunpack(cmd.args))\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  return true\n"
   "end\n"
   "\n"
   "function Redis:ignore_next_status_check()\n"
   "  self.ignore_check_status = self.ignore_check_status + 1\n"
   "end\n"
   "\n"
   "function Redis:command(...)\n"
   "  return redis_command(self, \"ctx\", ...)\n"
   "end\n"
   "function Redis:sub_command(...)\n"
   "  return redis_command(self, \"sub_ctx\", ...)\n"
   "end\n"
   "\n"
   "function Redis:script(name, ...)\n"
   "  local myhash = script_hash[name]\n"
   "  local args = {infer_command_callback_and_args(...)}\n"
   "  assert(myhash, (\"unknown Redis lua script \\\"%s\\\"\"):format(name))\n"
   "\n"
   "  \n"
   "  if type(args[2]) == \"table\" then\n"
   "    local keys = args[2]\n"
   "    table.remove(args, 2)\n"
   "    table.insert(args, 2, #keys)\n"
   "    for i, v in ipairs(keys) do\n"
   "      table.insert(args, 2+i, v)\n"
   "    end\n"
   "  else\n"
   "    table.insert(args, 2, 0)\n"
   "  end\n"
   "  table.insert(args, 2, \"EVALSHA\")\n"
   "  table.insert(args, 3, myhash)\n"
   "  return self:command(tunpack(args))\n"
   "end\n"
   "\n"
   "function newRedis(host, port, pass, db)\n"
   "  local r = setmetatable({}, rmeta)\n"
   "  r.connection_params = {\n"
   "    host=host, port=port, pass=pass, db=db\n"
   "  }\n"
   "  \n"
   "  r.pubsub_handlers = {}\n"
   "  r.subscribed = false\n"
   "  \n"
   "  r.pending_commands = {}\n"
   "  \n"
   "  return r\n"
   "end\n"
   "\n"
   "module.new = newRedis\n"
   "\n"
   "function module.addScript(name, hash, src)\n"
   "  assert(scripts[name] == nil, (\"redis lua script \\\"%s\\\" already exists\"):format(name))\n"
   "  script_hash[name]=hash\n"
   "  scripts[name]=src\n"
   "end\n"
   "\n"
   "function module.eachScript()\n"
   "  local name, hash\n"
   "  return function()\n"
   "    name, hash = next(script_hash, name)\n"
   "    if name then\n"
   "      return name, hash, scripts[name]\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "for _,v in pairs {\"redis_connect\", \"redis_close\", \"redis_command\", \"loadscripts\", \"timeout\", \"log_error\"} do\n"
   "  module.c[v]=function()\n"
   "    error(\"c binding \" .. v .. \" not set\")\n"
   "  end\n"
   "end\n"
   "\n"
   "return module\n"},

  {"rulecomponent", 
   "local Binding = require \"binding\"\n"
   "local json = require \"dkjson\"\n"
   "--local mm = require \"mm\"\n"
   "\n"
   "local Component -- forward declaration\n"
   "\n"
   "local function ignore_leading_hash(str)\n"
   "  return str:sub(1,1)==\"#\" and str:sub(2) or str\n"
   "end\n"
   "\n"
   "local thingstorage_meta = {__index = function(self, key)\n"
   "  local unhashed = ignore_leading_hash(key)\n"
   "  if unhashed ~= key then\n"
   "    return self[ignore_leading_hash(key)]\n"
   "  end\n"
   "end}\n"
   "\n"
   "local function create_thing_storage(thing_name)\n"
   "  local self = {table = setmetatable({}, thingstorage_meta)}\n"
   "  \n"
   "  local function unpack_thing(data, parser)\n"
   "    local name, val = next(data)\n"
   "    if type(name) == \"number\" then\n"
   "      parser:error(\"invalid data value, expected {\\\"key\\\":value}, got {\\\"key\\\"}\")\n"
   "    elseif type(name) ~= \"string\" then\n"
   "      parser:error(\"unexpected data type %s\", type(name))\n"
   "    end\n"
   "    local thing = self.table[name]\n"
   "    if parser then\n"
   "      parser:assert(thing, (\"Unknown %s \\\"%s\\\"\"):format(thing_name, name))\n"
   "    else\n"
   "      assert(thing, (\"Unknown %s \\\"%s\\\"\"):format(thing_name, name))\n"
   "    end\n"
   "    return name, val\n"
   "  end\n"
   "  \n"
   "  function self.add(name, funcs)\n"
   "    if type(name) == \"table\" then\n"
   "      for _,v in pairs(name) do\n"
   "        self.add(v, funcs)\n"
   "      end\n"
   "      return true\n"
   "    end\n"
   "    assert(funcs.parse, (\"%s missing parse callback\"):format(thing_name))\n"
   "    assert(self.table[name] == nil, (\"%s %s already exists\"):format(thing_name, name))\n"
   "    local added = {\n"
   "      parse=funcs.parse,\n"
   "      init=funcs.init,\n"
   "      delete=funcs.delete,\n"
   "      meta = {\n"
   "        __jsonval = funcs.jsonval,\n"
   "        __jsonorder = funcs.jsonorder or {\"action\", \"condition\"},\n"
   "        __index = {\n"
   "          toJSON = function(tbl)\n"
   "            return json.encode(tbl, {indent = true})\n"
   "          end\n"
   "        }\n"
   "      }\n"
   "    }\n"
   "    self.table[name]=added\n"
   "    \n"
   "    return true\n"
   "  end\n"
   "  \n"
   "  function self.parse(data, parser)\n"
   "    local name, val = unpack_thing(data, parser)\n"
   "    val = self.table[name].parse(val, parser) or val\n"
   "    return {[name]=val}\n"
   "  end\n"
   "  \n"
   "  function self.new(data, ruleset)\n"
   "    local name, val = unpack_thing(data)\n"
   "    name = ignore_leading_hash(name)\n"
   "    local thing_preset = self.table[name]\n"
   "    local thing = setmetatable({[thing_name]=name, data=val}, thing_preset.meta)\n"
   "    if thing_preset.init then\n"
   "      local replacement_data = thing_preset.init(val, thing, ruleset)\n"
   "      if replacement_data then\n"
   "        thing.data = replacement_data\n"
   "      end\n"
   "    end\n"
   "    Binding.call((\"%s:%s\"):format(thing_name, name), \"create\", thing)\n"
   "    return thing\n"
   "  end\n"
   "  \n"
   "  function self.delete(thing, ruleset)\n"
   "    local name = thing[thing_name] or thing.name\n"
   "    local thing_preset = self.table[name]\n"
   "    print(thing_name .. \" DELETE THING \" .. name .. \" \" .. tostring(thing_preset.delete))\n"
   "    if thing_preset.delete then\n"
   "      thing_preset.delete(thing.data, ruleset)\n"
   "    end\n"
   "    Binding.call((\"%s:%s\"):format(thing_name, name), \"delete\", thing)\n"
   "  end\n"
   "  \n"
   "  return self\n"
   "end\n"
   "\n"
   "Component = {\n"
   "  condition = create_thing_storage(\"condition\"),\n"
   "  action = create_thing_storage(\"action\")\n"
   "}\n"
   "\n"
   "--now let's add some basic conditions and actions\n"
   "Component.condition.add(\"any\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"array\", \"\\\"any\\\" condition value must be an array of conditions\")\n"
   "    for i, v in ipairs(data) do\n"
   "      local condition = parser:parseCondition(v)\n"
   "      data[i]=condition\n"
   "    end\n"
   "  end,\n"
   "  init = function(data, thing, ruleset)\n"
   "    for i, v in ipairs(data) do\n"
   "      data[i] = Component.condition.new(v, ruleset)\n"
   "    end\n"
   "  end,\n"
   "  delete = function(data, ruleset)\n"
   "    for _, cond in ipairs(data) do\n"
   "      Component.condition.delete(cond, ruleset)\n"
   "    end\n"
   "  end,\n"
   "  jsonval = function(self)\n"
   "    return {any=self.data}\n"
   "  end\n"
   "})\n"
   "\n"
   "Component.condition.add(\"all\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"array\", \"\\\"all\\\" condition value must be an array of conditions\")\n"
   "    for i, v in ipairs(data) do\n"
   "      local condition = parser:parseCondition(v)\n"
   "      data[i]=condition\n"
   "    end\n"
   "  end,\n"
   "  init = function(data, ruleset)\n"
   "    for i, v in ipairs(data) do\n"
   "      data[i] = Component.condition.new(v, ruleset)\n"
   "    end\n"
   "  end,\n"
   "  delete = function(data, ruleset)\n"
   "    for _, cond in ipairs(data) do\n"
   "      Component.condition.delete(cond, ruleset)\n"
   "    end\n"
   "  end,\n"
   "  jsonval = function(self)\n"
   "    return {all=self.data}\n"
   "  end\n"
   "})\n"
   "\n"
   "Component.condition.add({\"true\", \"false\"}, {\n"
   "  parse = function(data, parser)\n"
   "  --parser:assert(next(data) == nil, \"\\\"true\\\" condition must have empty parameters\")\n"
   "  end,\n"
   "  jsonval = function(self)\n"
   "    return self.condition\n"
   "  end\n"
   "})\n"
   "\n"
   "Component.condition.add(\"tag-check\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_type(data, \"string\", \"\\\"tag-check\\\" value must be a string\")\n"
   "    return parser:parseInterpolatedString(data)\n"
   "  end,\n"
   "  init = function(data)\n"
   "    Binding.call(\"string\", \"create\", data)\n"
   "  end,\n"
   "  delete = function(data)\n"
   "    Binding.call(\"string\", \"delete\", data)\n"
   "  end,\n"
   "  jsonval=function(self)\n"
   "    return {[\"tag-check\"]=self.data.string}\n"
   "  end\n"
   "})\n"
   "\n"
   "Component.condition.add(\"match\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"array\", \"\\\"match\\\" value must be an array of strings\")\n"
   "    for i, v in ipairs(data) do\n"
   "      parser:assert_jsontype(v, \"string\", \"\\\"match\\\" value must be an array of strings\")\n"
   "      data[i]=parser:parseInterpolatedString(v)\n"
   "    end\n"
   "  end,\n"
   "  init = function(data)\n"
   "    local complexity = function(str)\n"
   "      local n = 0\n"
   "      for _ in str.string:gmatch(\"%$\") do\n"
   "        n=n+1\n"
   "      end\n"
   "      return n\n"
   "    end\n"
   "    local simplefirst = function(str1, str2)\n"
   "      return complexity(str1) < complexity(str2)\n"
   "    end\n"
   "    table.sort(data, simplefirst)\n"
   "    for _, str in ipairs(data) do\n"
   "      Binding.call(\"string\", \"create\", str)\n"
   "    end\n"
   "  end,\n"
   "  delete = function(data)\n"
   "    for _, str in ipairs(data) do\n"
   "      Binding.call(\"string\", \"delete\", str)\n"
   "    end\n"
   "  end,\n"
   "  jsonval = function(self)\n"
   "    local strings = {}\n"
   "    for _, str in ipairs(self.data) do\n"
   "      table.insert(strings, str.string)\n"
   "    end\n"
   "    return {match=strings}\n"
   "  end\n"
   "})\n"
   "\n"
   "local limit_thing_meta = {__jsonorder={\"name\", \"key\", \"increment\"}}\n"
   "\n"
   "--limiter conditions\n"
   "Component.condition.add({\"limit-break\", \"limit-check\"}, {\n"
   "  parse = function(data, parser)\n"
   "    if type(data) == \"string\" then\n"
   "      data = {name=data}\n"
   "    elseif type(data) ~= \"table\" then\n"
   "      parser:error(\"invalid value type %s\", type(data))\n"
   "    end\n"
   "    local condition_name = next(parser:getContext())\n"
   "    local rule = parser:getContext(\"rule\")\n"
   "    local rule_condition = parser:getContext(\"if\")\n"
   "    \n"
   "    if not data.key then\n"
   "      data.key = rule.key\n"
   "    end\n"
   "    parser:assert(data.key, \"limiter \\\"key\\\" missing, and no default \\\"key\\\" in rule\")\n"
   "    parser:assert_type(data.key, \"string\", \"invalid limiter \\\"key\\\" type\")\n"
   "    \n"
   "    data.key = parser:parseInterpolatedString(data.key)\n"
   "    \n"
   "    if not data.increment then\n"
   "      if condition_name == \"limit-break\" then\n"
   "        data.increment = 1\n"
   "      elseif condition_name == \"limit-check\" then\n"
   "        data.increment = 0\n"
   "      end\n"
   "    end\n"
   "    data.increment = parser:assert(tonumber(data.increment), \"invalid or empty \\\"increment\\\" value\")\n"
   "    parser:assert(data.increment >= 0, \"\\\"increment\\\" must be >= 0\")\n"
   "    \n"
   "    parser:assert(data.name, \"limiter name missing\")\n"
   "    parser:assert_type(data.name, \"string\", \"invalid \\\"name\\\" type\")\n"
   "    \n"
   "    if not parser:getLimiter(data.name) then\n"
   "      parser:error(\"unknown limiter \\\"%s\\\"\", data.name)\n"
   "    end\n"
   "    \n"
   "    if Component.generate_refs then\n"
   "      if not rule.refs then rule.refs = {} end\n"
   "      if not rule_condition.refs then rule_condition.refs = {} end\n"
   "      rule.refs[\"limiter:\"..data.name]=true\n"
   "      rule_condition.refs[\"limiter:\"..data.name]=true\n"
   "    end\n"
   "    \n"
   "    return data\n"
   "  end,\n"
   "  init = function(data, thing, ruleset)\n"
   "    local limiter = ruleset:findLimiter(data.name)\n"
   "    if not limiter then error(\"unknown limiter \" .. data.name) end\n"
   "    data.name = nil\n"
   "    data.limiter = limiter\n"
   "    if data.key then\n"
   "      Binding.call(\"string\", \"create\", data.key)\n"
   "    end\n"
   "  end,\n"
   "  delete = function(data)\n"
   "    if data.key then\n"
   "      Binding.call(\"string\", \"delete\", data.key)\n"
   "    end\n"
   "  end,\n"
   "  jsonval = function(self)\n"
   "    local cpy = {}\n"
   "    for k,v in pairs(self.data) do\n"
   "      cpy[k]=v\n"
   "    end\n"
   "    if cpy.derived_key then\n"
   "      cpy.derived_key = nil\n"
   "      cpy.key = nil\n"
   "    elseif cpy.key then\n"
   "      cpy.key = cpy.key.string\n"
   "    end\n"
   "    cpy.name = cpy.limiter.name\n"
   "    cpy.limiter = nil\n"
   "    setmetatable(cpy, limit_thing_meta)\n"
   "    local ret = {[self.condition]=cpy}\n"
   "    return ret\n"
   "  end\n"
   "})\n"
   "\n"
   "Component.condition.add(\".delay\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"number\", \"delay by <number> please\")\n"
   "  end\n"
   "})\n"
   "\n"
   "--some actions, too\n"
   "Component.action.add(\"tag\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"string\", \"\\\"tag\\\" value must be a string\")\n"
   "    return parser:parseInterpolatedString(data)\n"
   "  end,\n"
   "  init = function(data)\n"
   "    Binding.call(\"string\", \"create\", data)\n"
   "  end,\n"
   "  delete = function(data)\n"
   "    Binding.call(\"string\", \"delete\", data)\n"
   "  end,\n"
   "  jsonval = function(self)\n"
   "    return {tag=self.data.string}\n"
   "  end\n"
   "})\n"
   "\n"
   "Component.action.add(\"accept\", {parse = function(data, parser)\n"
   "  parser:assert_type(data, \"table\", \"\\\"accept\\\" value must be an object\")\n"
   "  parser:assert_table_size(data, 0, \"\\\"accept\\\" value must be empty\")\n"
   "end})\n"
   "Component.action.add(\"reject\", {parse = function(data, parser)\n"
   "  parser:assert_type(data, \"table\", \"\\\"reject\\\" value must be an object\")\n"
   "  --parser:assert_table_size(data, 0, \"\\\"reject\\\" value must be empty\")\n"
   "end})\n"
   "\n"
   "Component.action.add(\"wait\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"number\", \"\\\"wait\\\" value must be a number\")\n"
   "  end\n"
   "})\n"
   "\n"
   "return Component\n"},

  {"ruleset", 
   "local RuleComponent = require \"rulecomponent\"\n"
   "local Binding = require \"binding\"\n"
   "local json = require \"dkjson\"\n"
   "--local mm = require \"mm\"\n"
   "\n"
   "--local inspect = require \"inspect\"\n"
   "\n"
   "--luacheck: globals redis cjson ARGV unpack\n"
   "--[[local hmm = function(thing)\n"
   "  local out = inspect(thing)\n"
   "  for line in out:gmatch('[^\\r\\n]+') do\n"
   "    if redis then\n"
   "      redis.call(\"ECHO\", line)\n"
   "    end\n"
   "  end\n"
   "end]]\n"
   "\n"
   "local Module -- forward declaration\n"
   "\n"
   "local tcopy = function(tbl, skipmetatable)\n"
   "  local cpy = {}\n"
   "  for k,v in pairs(tbl) do\n"
   "    cpy[k]=v\n"
   "  end\n"
   "  if skipmetatable then\n"
   "    return cpy\n"
   "  else\n"
   "    return setmetatable(cpy, getmetatable(tbl))\n"
   "  end\n"
   "end\n"
   "\n"
   "local function assert_unique_name(what, tbl, data)\n"
   "  assert(data.name, (\"a %s must have a name\"):format(what))\n"
   "  assert(not tbl[data.name], (\"%s \\\"%s\\\" already exists\"):format(what, data.name))\n"
   "end\n"
   "\n"
   "local function thing_name(thing)\n"
   "  if type(thing)==\"string\" then\n"
   "    return thing\n"
   "  elseif type(thing) == \"table\" then\n"
   "    return thing.name\n"
   "  else\n"
   "    return thing\n"
   "  end\n"
   "end\n"
   "\n"
   "local function table_copy(tbl, exclude_keys)\n"
   "  local cpy = {}\n"
   "  setmetatable(cpy, getmetatable(tbl))\n"
   "  for k,v in pairs(tbl) do\n"
   "    if not exclude_keys[k] then\n"
   "      cpy[k]=v\n"
   "    end\n"
   "  end\n"
   "  return cpy\n"
   "end\n"
   "\n"
   "local function sorted_keys(tbl)\n"
   "  local keys = {}\n"
   "  for k in pairs(tbl) do\n"
   "    table.insert(keys, k)\n"
   "  end\n"
   "  table.sort(keys)\n"
   "  return keys\n"
   "end\n"
   "\n"
   "local Ruleset = {} --forward declaration\n"
   "\n"
   "local mt = {}\n"
   "\n"
   "mt.ruleset = {\n"
   "  __index = Ruleset,\n"
   "  __jsonorder = {\"name\", \"info\", \"phases\", \"limiters\", \"lists\", \"rules\"}\n"
   "}\n"
   "  \n"
   "mt.phase = {\n"
   "  new = function(name, data)\n"
   "    return setmetatable({name=name, lists=data}, mt.phase)\n"
   "  end,\n"
   "  __index = {\n"
   "    toJSON = function(self)\n"
   "      return json.encode(self, {indent=true})\n"
   "    end\n"
   "  },\n"
   "  __jsonval = function(self)\n"
   "    local lists = {}\n"
   "    for _, list in pairs(self.lists) do\n"
   "      table.insert(lists, list.name)\n"
   "    end\n"
   "    return lists\n"
   "  end\n"
   "}\n"
   "  \n"
   "mt.rules={__jsonorder=sorted_keys}\n"
   "mt.lists={__jsonorder=sorted_keys}\n"
   "mt.limiters={__jsonorder=sorted_keys}\n"
   "  \n"
   "mt.list = {\n"
   "  new = function(data)\n"
   "    return setmetatable(data, mt.list)\n"
   "  end,\n"
   "  __index = {\n"
   "    toJSON = function(self)\n"
   "      return json.encode(self, {indent=true})\n"
   "    end\n"
   "  },\n"
   "  __jsonorder = {\"name\", \"info\", \"rules\"},\n"
   "  __jsonval = function(self)\n"
   "    local rules = {}\n"
   "    for _, rule in pairs(self.rules) do\n"
   "      table.insert(rules, rule.name)\n"
   "    end\n"
   "    \n"
   "    if self.info then\n"
   "      return setmetatable({info=self.info, rules=rules}, getmetatable(self))\n"
   "    else\n"
   "      return setmetatable(rules, getmetatable(self))\n"
   "    end\n"
   "  end\n"
   "}\n"
   "\n"
   "local actions_array_meta = {__index = {toJSON=function(self) return json.encode(self, {indent = true}) end}}\n"
   "mt.rule = {\n"
   "  new = function(data, ruleset)\n"
   "    local rule =setmetatable(data, mt.rule)\n"
   "    if data[\"if\"] then\n"
   "      data[\"if\"] = RuleComponent.condition.new(rule[\"if\"], ruleset)\n"
   "    end\n"
   "    \n"
   "    for _,clause in pairs{\"then\", \"else\"} do\n"
   "      if data[clause] then\n"
   "        local actions = setmetatable({}, actions_array_meta)\n"
   "        for _,v in pairs(data[clause]) do\n"
   "          table.insert(actions, RuleComponent.action.new(v, ruleset))\n"
   "        end\n"
   "        data[clause]=actions\n"
   "      end\n"
   "    end\n"
   "    return data\n"
   "  end,\n"
   "  __index = {\n"
   "    toJSON = function(self)\n"
   "      return json.encode(self, {indent=true})\n"
   "    end\n"
   "  },\n"
   "  __jsonorder = {\"name\", \"info\", \"key\", \"if\", \"if-any\", \"if-all\", \"then\", \"else\"},\n"
   "  __jsonval = function(self)\n"
   "    if #self[\"else\"] <= 1 or #self[\"then\"] <= 1 or self.key or self[\"if\"].condition == \"any\" or self[\"if\"].condition == \"all\" or self[\"refs\"] then\n"
   "      local ret = tcopy(self)\n"
   "      if self[\"if\"].condition == \"any\" then ret[\"if-any\"] = ret[\"if\"].data; ret[\"if\"] = nil end\n"
   "      if self[\"if\"].condition == \"all\" then ret[\"if-all\"] = ret[\"if\"].data; ret[\"if\"] = nil end\n"
   "      if #self[\"then\"] == 0 then ret[\"then\"] = nil end\n"
   "      if #self[\"then\"] == 1 then ret[\"then\"] = self[\"then\"][1] end\n"
   "      if #self[\"else\"] == 0 then ret[\"else\"] = nil end\n"
   "      if #self[\"else\"] == 1 then ret[\"else\"] = self[\"else\"][1] end\n"
   "      if self.key then self.key = self.key.string end\n"
   "      if ret.refs then ret.refs = nil end\n"
   "      return ret\n"
   "    end\n"
   "    return self\n"
   "  end\n"
   "}\n"
   "  \n"
   "mt.limiter = {\n"
   "  new = function(data)\n"
   "    return setmetatable(data, mt.limiter)\n"
   "  end,\n"
   "  __index = {\n"
   "    toJSON = function(self)\n"
   "      return json.encode(self, {indent=true})\n"
   "    end\n"
   "  },\n"
   "  __jsonorder = {\"name\", \"info\", \"limit\", \"interval\", \"burst\", \"burst-expire\"},\n"
   "  __jsonval = function(self)\n"
   "    if self.burst then\n"
   "      local cpy = tcopy(self)\n"
   "      cpy.burst = cpy.burst[\"name\"]\n"
   "      return cpy\n"
   "    end\n"
   "    return self\n"
   "  end\n"
   "}\n"
   "\n"
   "local function updateThing(self, thing_type, findThing, name, data)\n"
   "  --assumes data is already valid\n"
   "  assert(type(thing_type)==\"string\", \"wrong thing_type type\")\n"
   "  assert(type(name)==\"string\", \"wrong name type\")\n"
   "  local thing = findThing(self, name)\n"
   "  if not thing then return nil, (\"%s \\\"%s\\\" not found.\"):format(thing_type, name) end\n"
   "  local delta = {}\n"
   "  for k, v in pairs(data) do\n"
   "    delta[k]={old=thing[k], new=v}\n"
   "    thing[k]=v\n"
   "  end\n"
   "  --hmm(delta)\n"
   "  if next(delta) then --at least one thing to update\n"
   "    Binding.call(thing_type, \"update\", thing, delta)\n"
   "  end\n"
   "  return thing\n"
   "end\n"
   "\n"
   "function Ruleset:findLimiter(name)\n"
   "  return self.limiters[thing_name(name)]\n"
   "end\n"
   "function Ruleset:addLimiter(data, limiters_in)\n"
   "  if data.__already_loaded_as_burst_limiter then\n"
   "    data.__already_loaded_as_burst_limiter = nil\n"
   "    return nil\n"
   "  end\n"
   "  if not data.external then\n"
   "    assert_unique_name(\"limiter\", self.limiters, data)\n"
   "  end\n"
   "  local limiter = mt.limiter.new(data)\n"
   "  self.limiters[data.name]=limiter\n"
   "  if limiter.burst then\n"
   "    local burst_limiter = self:findLimiter(limiter.burst)\n"
   "    if not burst_limiter then\n"
   "      burst_limiter = self:addLimiter(limiters_in[limiter.burst], limiters_in)\n"
   "      limiters_in[limiter.burst].__already_loaded_as_burst_limiter = true\n"
   "      limiter.burst = burst_limiter\n"
   "    end\n"
   "  end\n"
   "  Binding.call(\"limiter\", \"create\", limiter)\n"
   "  return limiter\n"
   "end\n"
   "function Ruleset:updateLimiter(name, data)\n"
   "  if data.burst then\n"
   "    local burst = self:findLimiter(data.burst)\n"
   "    assert(burst, (\"unknown burst limiter \\\"%s\\\"\"):format(thing_name(data.burst)))\n"
   "    data.burst = burst\n"
   "  end\n"
   "\n"
   "  return updateThing(self, \"limiter\", self.findLimiter, name, data)\n"
   "end\n"
   "function Ruleset:deleteLimiter(limiter)\n"
   "  assert(self.limiters[limiter.name] == limiter, \"tried deleting unexpected limiter of the same name\")\n"
   "  --TODO: check which rules use this limiter\n"
   "  self.limiters[limiter.name] = nil\n"
   "  \n"
   "  Binding.call(\"limiter\", \"delete\", limiter)\n"
   "end\n"
   "\n"
   "function Ruleset:findRule(name)\n"
   "  return self.rules[thing_name(name)]\n"
   "end\n"
   "\n"
   "function Ruleset:addRule(data)\n"
   "  if not data.name then\n"
   "    data.name = self:uniqueName(\"rule\")\n"
   "  elseif not data.external then\n"
   "    assert_unique_name(\"rule\", self.rules, data)\n"
   "  end\n"
   "  local rule = mt.rule.new(data, self)\n"
   "  self.rules[data.name]=rule\n"
   "  Binding.call(\"rule\", \"create\", rule)\n"
   "  return rule\n"
   "end\n"
   "function Ruleset:updateRule(name, data)\n"
   "  --hmm(\"updating... make new rule\")\n"
   "  local newRule = mt.rule.new(data, self)\n"
   "  --hmm(\"...ok\")\n"
   "  return updateThing(self, \"rule\", self.findRule, name, newRule)\n"
   "end\n"
   "function Ruleset:deleteRule(rule)\n"
   "  assert(self.rules[rule.name] == rule, \"tried deleting unexpected rule of the same name\")\n"
   "  for list_name, list in pairs(self.lists) do\n"
   "    for _, list_rule in ipairs(list) do\n"
   "      assert(list_rule ~= rule, (\"can't delete rule \\\"%s\\\", it's used in list \\\"%s\\\"\"):format(rule.name, list_name))\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  self.rules[rule.name] = nil\n"
   "  \n"
   "  if rule[\"if\"] then\n"
   "    RuleComponent.condition.delete(rule[\"if\"], self)\n"
   "  end\n"
   "  \n"
   "  for _,clause in pairs{\"then\", \"else\"} do\n"
   "    if rule[clause] then\n"
   "      local actions = rule[clause]\n"
   "      for _,action in pairs(actions) do\n"
   "        RuleComponent.action.delete(action, self)\n"
   "      end\n"
   "      rule[clause]={}\n"
   "    end\n"
   "  end\n"
   "  Binding.call(\"rule\", \"delete\", rule)\n"
   "end\n"
   "\n"
   "function Ruleset:findList(name)\n"
   "  return self.lists[thing_name(name)]\n"
   "end\n"
   "\n"
   "function Ruleset:addList(data)\n"
   "  assert(data.rules)\n"
   "  if not data.name then\n"
   "    data.name = self:uniqueName(\"list\")\n"
   "  elseif not data.external then\n"
   "    assert_unique_name(\"list\", self.lists, data)\n"
   "  end\n"
   "  \n"
   "  for i, rule_data in ipairs(data.rules) do\n"
   "    data.rules[i]= self:findRule(rule_data.name) or self:addRule(rule_data)\n"
   "  end\n"
   "  local list = mt.list.new(data)\n"
   "  self.lists[data.name] = list\n"
   "  Binding.call(\"list\", \"create\", list)\n"
   "  return list\n"
   "end\n"
   "function Ruleset:updateList(name, data)\n"
   "  if data.insertRule then\n"
   "    local list = assert(self:findList(name or data.name), \"List not found\")\n"
   "    local rule = assert(self:findRule(data.insertRule.name), \"Rule to insert not found\")\n"
   "    assert(data.insertRule.index, \"Rule index missing\")\n"
   "    if list.rules then\n"
   "      table.insert(list.rules, data.insertRule.index or #list.rules, rule)\n"
   "    end\n"
   "    Binding.call(\"list\", \"update\", list, {insertRule = data.insertRule})\n"
   "    data.insertRule = nil\n"
   "  end\n"
   "  if data.removeRule then\n"
   "    local list = assert(self:findList(name or data.name), \"List not found\")\n"
   "    assert(tonumber(data.removeRule.index), \"Rule index missing or not a number\")\n"
   "    if list.rules then\n"
   "      table.remove(list.rules, data.removeRule.index)\n"
   "    end\n"
   "    Binding.call(\"list\", \"update\", list, {removeRule=data.removeRule})\n"
   "    data.removeRule = nil\n"
   "  end\n"
   "  if data.rules then\n"
   "    data = data.rules\n"
   "    if data.name then assert(name == data.name) end\n"
   "  end\n"
   "  for i, rule_data in ipairs(data.rules) do\n"
   "    data.rules[i]= self:findRule(rule_data.name) or self:addRule(rule_data)\n"
   "  end\n"
   "  \n"
   "  return updateThing(self, \"list\", self.findList, name, data)\n"
   "end\n"
   "function Ruleset:deleteList(list)\n"
   "  assert(self.lists[list.name] == list, \"tried deleting unexpected list of the same name\")\n"
   "  for phase_name, phase in pairs(self.phases) do\n"
   "    for _, phase_list in ipairs(phase) do\n"
   "      assert(phase_list ~= list, (\"can't delete list \\\"%s\\\", it's used in phase \\\"%s\\\"\"):format(list.name, phase_name))\n"
   "    end\n"
   "  end\n"
   "  self.lists[list.name] = nil\n"
   "  Binding.call(\"list\", \"delete\", list)\n"
   "end\n"
   "\n"
   "local possible_phases = {request=true}\n"
   "function Ruleset:addPhase(data, name)\n"
   "  local lists\n"
   "  if data.name then -- {name: phaseName, lists: [...]}\n"
   "    if name then assert(name == data.name) end\n"
   "    lists = data.lists\n"
   "  else  -- [ lists ]\n"
   "    assert(name)\n"
   "    lists = data\n"
   "  end\n"
   "  \n"
   "  assert(possible_phases[name], (\"unknown phase \\\"%s\\\"\"):format(name))\n"
   "  assert(not self.phases[name], (\"phase \\\"%s\\\" already exists\"):format(name))\n"
   "  \n"
   "  local err\n"
   "  for i, list in ipairs(lists) do\n"
   "    if type(list) == \"string\" then\n"
   "      list, err = self:findList(list)\n"
   "    else\n"
   "      local found_list = self:findList(list)\n"
   "      if found_list then\n"
   "        list = found_list\n"
   "      else\n"
   "        list, err = self:addList(list)\n"
   "      end\n"
   "    end\n"
   "    if not list then return nil, err or (\"can't find list \\\"%s\\\" for phase \\\"%s\\\"\"):format(list, name) end\n"
   "    lists[i]=list\n"
   "  end\n"
   "  local phase = mt.phase.new(name, lists)\n"
   "  Binding.call(\"phase\", \"create\", phase)\n"
   "  return phase\n"
   "end\n"
   "function Ruleset:deletePhase(name)\n"
   "  local phase = assert(self.phases[name], (\"phase \\\"%s\\\" does not exist\"):format(name))\n"
   "  Binding.call(\"phase\", \"delete\", phase)\n"
   "  self.phases[name]=nil\n"
   "end\n"
   "\n"
   "function Ruleset:uniqueName(thing)\n"
   "  local uniqs = {\n"
   "    ruleset = {},\n"
   "    rule = self.rules,\n"
   "    list = self.lists,\n"
   "    limiter = self.limiters\n"
   "  }\n"
   "  local checktbl = uniqs[thing]\n"
   "  if checktbl == nil then\n"
   "    error(\"don't knoq how to generate unique name for \" .. tostring(thing))\n"
   "  end\n"
   "  \n"
   "  return assert(Module.uniqueName(thing, checktbl, self), \"unique name can't be nil\")\n"
   "end\n"
   "\n"
   "function Ruleset:toJSON()\n"
   "  local rs = {\n"
   "    name = self.name,\n"
   "    info = self.info,\n"
   "    rules = tcopy(self.rules),\n"
   "    lists = tcopy(self.lists),\n"
   "    limiters = tcopy(self.limiters),\n"
   "    phases = self.phases,\n"
   "  }\n"
   "  setmetatable(rs, mt.ruleset)\n"
   "  \n"
   "  --remove inlined names from rules, lists, and limiters\n"
   "  local excludes = {name=true}\n"
   "  for _, thingsname in ipairs({\"rules\", \"lists\", \"limiters\", \"phases\"}) do\n"
   "    local things = rs[thingsname] or {}\n"
   "    for k, thing in pairs(things) do\n"
   "      things[k]=table_copy(thing, excludes)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  return json.encode(rs, {indent=true})\n"
   "end\n"
   "\n"
   "function Ruleset:destroy()\n"
   "  --clear phases\n"
   "  for name, _ in pairs(self.phases) do\n"
   "    self:deletePhase(name)\n"
   "  end\n"
   "  \n"
   "  --clear lists\n"
   "  for _, list in pairs(self.lists) do\n"
   "    self:deleteList(list)\n"
   "  end\n"
   "  \n"
   "  --clear rules\n"
   "  for _, rule in pairs(self.rules) do\n"
   "    self:deleteRule(rule)\n"
   "  end\n"
   "  \n"
   "  --clear limiters\n"
   "  for _, limiter in pairs(self.limiters) do\n"
   "    self:deleteLimiter(limiter)\n"
   "  end\n"
   "  \n"
   "  Binding.call(\"ruleset\", \"delete\", self)\n"
   "  \n"
   "end\n"
   "\n"
   "Module = {\n"
   "  new = function(data)\n"
   "    local ruleset = setmetatable({\n"
   "      rules=setmetatable({}, mt.rules),\n"
   "      lists=setmetatable({}, mt.lists),\n"
   "      limiters=setmetatable({}, mt.limiters),\n"
   "      phases=setmetatable({}, mt.phases),\n"
   "      name = data and data.name or nil\n"
   "    }, mt.ruleset)\n"
   "\n"
   "    if not ruleset.name then ruleset.name = ruleset:uniqueName(\"ruleset\") end\n"
   "    \n"
   "    if data then\n"
   "      --load data\n"
   "      if data.external then ruleset.external = true end\n"
   "      \n"
   "      for _, v in pairs(data.limiters or {}) do\n"
   "        ruleset:addLimiter(v, data.limiters)\n"
   "      end\n"
   "      \n"
   "      for _, v in pairs(data.rules or {}) do\n"
   "        ruleset:addRule(v)\n"
   "      end\n"
   "      \n"
   "      for _, v in pairs(data.lists or {}) do\n"
   "        ruleset:addList(v)\n"
   "      end\n"
   "      \n"
   "      for n, v in pairs(data.phases or {}) do\n"
   "        ruleset:addPhase(v, n)\n"
   "      end\n"
   "      \n"
   "    end\n"
   "    Binding.call(\"ruleset\", \"create\", ruleset)\n"
   "    return ruleset\n"
   "  end,\n"
   "  newLimiter = mt.limiter.new,\n"
   "  newPhase = mt.phase.new,\n"
   "  newList = mt.list.new,\n"
   "  newRule = mt.rule.new,\n"
   "  \n"
   "  uniqueName = function(thingname, checktbl, ruleset)\n"
   "    error(\"uniqueName must be configured outside the Ruleset module\")\n"
   "  end,\n"
   "  \n"
   "  RuleComponent = RuleComponent\n"
   "}\n"
   "\n"
   "return Module\n"
   "\n"}
};
