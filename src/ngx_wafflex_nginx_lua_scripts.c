#include <ngx_wafflex_nginx_lua_scripts.h>

wfx_lua_scripts_t wfx_lua_scripts = {
  {"init", 
   "--lua environs initializer\n"
   "\n"
   "--luacheck: globals Parser Ruleset Binding\n"
   "--luacheck: globals parseRulesetFile deferRulesetCreation createDeferredRulesets\n"
   "--luacheck: globals deferRulesetRedisLoad loadDeferredRedisRulesets\n"
   "--luacheck: globals shutdown printFunctions\n"
   "\n"
   "--setup package loading\n"
   "local package_loader\n"
   "package.path = \"\"\n"
   "package.cpath= \"\"\n"
   "setmetatable(package.preload, {__index = function(self, name)\n"
   "  local pkg = package_loader(name)\n"
   "  local loader\n"
   "  if pkg then\n"
   "    loader = function()\n"
   "      return pkg\n"
   "    end\n"
   "    self[name]=loader\n"
   "  end\n"
   "  return loader\n"
   "end})\n"
   "\n"
   "\n"
   "return function(package_loader_cfunc, manager, init_bind_cfunc, ruleset_confset_cfunc, get_loc_conf_redis)\n"
   "  package_loader = package_loader_cfunc\n"
   "  \n"
   "  Parser = require \"parser\"\n"
   "  Ruleset = require \"ruleset\"\n"
   "  Binding = require \"binding\"\n"
   "  \n"
   "  Binding.require_create_userdata = true\n"
   "  Binding.require_binding = true\n"
   "  \n"
   "  --local mm = require \"mm\"\n"
   "  \n"
   "  if init_bind_cfunc then\n"
   "    init_bind_cfunc(Binding.set)\n"
   "  end\n"
   "  \n"
   "  local rulesets = {}\n"
   "  \n"
   "  if manager then\n"
   "    local parsed_ruleset_data = {}\n"
   "    \n"
   "    function parseRulesetFile(prefix, path, ruleset_name)\n"
   "      local p = Parser.new()\n"
   "      \n"
   "      local fullpath\n"
   "      if path:match(\"^/\") then\n"
   "        fullpath = path\n"
   "      elseif prefix then\n"
   "        fullpath = (prefix:match(\"/$\") and \"%s%s\" or \"%s/%s\"):format(prefix, path)\n"
   "      end\n"
   "      \n"
   "      local ok, res = pcall(p.parseFile, p, fullpath)\n"
   "      if not ok then\n"
   "        return nil, (res:match(\"[^:]*:%d+: (.*)\") or res)\n"
   "      end\n"
   "      \n"
   "      if ruleset_name then\n"
   "        res.name = ruleset_name\n"
   "      end\n"
   "      if not res.name then\n"
   "        local filename = path:match(\"[^/]+$\")\n"
   "        local sansext = filename:match(\"(.*)%.[^.]+$\")\n"
   "        filename = sansext or filename\n"
   "        res.name = filename\n"
   "      end\n"
   "      \n"
   "      if res.name and parsed_ruleset_data[res.name] then\n"
   "        return nil, (\"ruleset \\\"%s\\\" already exists\"):format(res.name)\n"
   "      end\n"
   "      parsed_ruleset_data[res.name] = res\n"
   "      \n"
   "      return res\n"
   "    end\n"
   "    \n"
   "    local deferred = setmetatable({}, {__index = function(t,k)\n"
   "      t[k]={}\n"
   "      return t[k]\n"
   "    end})\n"
   "  \n"
   "    function deferRulesetCreation(name, conf_ptr)\n"
   "      if not parsed_ruleset_data[name] then\n"
   "        return nil, (\"unknown ruleset \\\"%s\\\"\"):format(name)\n"
   "      end\n"
   "      table.insert(deferred[name], conf_ptr)\n"
   "      return true\n"
   "    end\n"
   "    \n"
   "    local function createRuleset(parsed_data)\n"
   "      local rs = Ruleset.new(parsed_data)\n"
   "      assert(rulesets[rs.name] == nil)\n"
   "      rulesets[rs.name] = rs\n"
   "      return rs\n"
   "    end\n"
   "    \n"
   "    function createDeferredRulesets()\n"
   "      for name, def in pairs(deferred) do\n"
   "        local ruleset = createRuleset(parsed_ruleset_data[name])\n"
   "        for _, conf_ptr in pairs(def) do\n"
   "          ruleset_confset_cfunc(ruleset, conf_ptr)\n"
   "        end\n"
   "      end\n"
   "      deferred = setmetatable({}, getmetatable(deferred)) -- clear 'deferred' table\n"
   "    end\n"
   "    \n"
   "    local deferred_redis_rulesets = setmetatable({}, {__index = function(t,k)\n"
   "      t[k]={}\n"
   "      return t[k]\n"
   "    end})\n"
   "    \n"
   "    function deferRulesetRedisLoad(name, loc_conf_ptr, conf_ptr)\n"
   "      table.insert(deferred_redis_rulesets[name], {lcf_ptr=loc_conf_ptr, rcf_ptr = conf_ptr})\n"
   "      return true\n"
   "    end\n"
   "  \n"
   "    function loadDeferredRedisRulesets()\n"
   "      local co = coroutine.wrap(function()\n"
   "        local redis, ruleset_json, parser, parsed, ruleset\n"
   "        for name, rs in pairs(deferred_redis_rulesets) do\n"
   "          for _, config in ipairs(rs) do\n"
   "            if rulesets[name] then\n"
   "              ruleset = rulesets[name]\n"
   "            else\n"
   "              redis = get_loc_conf_redis(config.lcf_ptr)\n"
   "              assert(redis, \"expected a redis here\")\n"
   "              ruleset_json = redis:script(\"get_ruleset\", name)\n"
   "              assert(type(ruleset_json) == \"string\")\n"
   "              parser = Parser.new()\n"
   "              parsed = parser:parseJSON(ruleset_json)\n"
   "              ruleset = createRuleset(parsed)\n"
   "            end\n"
   "            ruleset_confset_cfunc(ruleset, config.rcf_ptr)\n"
   "          end\n"
   "        end\n"
   "      end)\n"
   "      co()\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function shutdown(is_manager)\n"
   "    if is_manager then\n"
   "      for name, ruleset in pairs(rulesets) do\n"
   "        print(\"kill a ruleset named \" .. name)\n"
   "        ruleset:destroy()\n"
   "      end\n"
   "    end\n"
   "    rulesets = {}\n"
   "  end\n"
   "\n"
   "  function printFunctions(pattern)\n"
   "    for k,v in pairs(_G) do\n"
   "      if type(v) == \"function\" then\n"
   "        if not pattern or k:match(pattern) then\n"
   "          local info = debug.getinfo(v)\n"
   "          print((\"%s: function %s (%s %s %s:%i-%i)\"):format(tostring(k), tostring(v), info.what, info.namewhat, info.short_src, info.linedefined, info.lastlinedefined))\n"
   "        end\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "end\n"},

  {"ipc", 
   "local handlers = {}\n"
   "local rawget = rawget\n"
   "--luacheck: globals setAlertHandler getAlertHandler\n"
   "function setAlertHandler(name, callback)\n"
   "  rawset(handlers, name, callback)\n"
   "end\n"
   "function getAlertHandler(name, data_ptr)\n"
   "  return rawget(handlers, name)\n"
   "end\n"},

  {"limiter", 
   "\n"
   "--luacheck: globals findLimiterValue setLimiterValue unsetLimiterValue\n"
   "--local mm = require \"mm\"\n"
   "local setmetatable, rawset, rawget = setmetatable, rawset, rawget\n"
   "\n"
   "local function tabling_meta(depth, ephemeron)\n"
   "  return {__index = function(t,k)\n"
   "    local v = {}\n"
   "    if depth > 0 then\n"
   "      setmetatable(v, tabling_meta(depth-1, type(ephemeron) == \"number\" and ephemeron-1 or ephemeron))\n"
   "    end\n"
   "    t[k]=v\n"
   "    return v\n"
   "  end, __mode = (ephemeron == true or (ephemeron and ephemeron > 0)) and \"k\" or nil }\n"
   "end\n"
   "\n"
   "local limiters = setmetatable({}, tabling_meta(2))\n"
   "\n"
   "function findLimiterValue(limiter_ptr, key)\n"
   "  local limit = rawget(limiters, limiter_ptr)\n"
   "  if not limit then\n"
   "    return nil\n"
   "  end\n"
   "  local data = rawget(limit, key)\n"
   "  if not data then\n"
   "    return nil\n"
   "  end\n"
   "  return data\n"
   "end\n"
   "\n"
   "function setLimiterValue(limiter_ptr, key, limit_data_ptr)\n"
   "  limiters[limiter_ptr][key]=limit_data_ptr\n"
   "  \n"
   "  --check uniqueness\n"
   "  --[[\n"
   "  local uniq = {}\n"
   "  mm(limiters[limiter_ptr])\n"
   "  for k, v in pairs(limiters[limiter_ptr]) do\n"
   "    assert(not uniq[v], \"found two different keys mapping to same limiter value\")\n"
   "    uniq[v] = true\n"
   "  end\n"
   "  ]]\n"
   "  \n"
   "  return limit_data_ptr\n"
   "end\n"
   "  \n"
   "function unsetLimiterValue(limiter_ptr, key, limit_data_ptr)\n"
   "  --mm(limiters)\n"
   "  local limit = rawget(limiters, limiter_ptr)\n"
   "  local data = rawget(limit, key)\n"
   "  if data then\n"
   "    assert(type(data) == \"userdata\")\n"
   "    if limit_data_ptr then\n"
   "      assert(data == limit_data_ptr)\n"
   "    end\n"
   "    rawset(limit, key, nil)\n"
   "    if next(limit) == nil then\n"
   "      rawset(limiters, limiter_ptr, nil)\n"
   "    end\n"
   "    return true\n"
   "  else\n"
   "    return nil\n"
   "  end\n"
   "end\n"
   "\n"},

  {"redis", 
   "local mm = require \"mm\"\n"
   "local Redis = require \"redis\"\n"
   "\n"
   "--luacheck: globals registerRedis connectRedises\n"
   "\n"
   "local function parseRedisUrl(url)\n"
   "  local host, port, pass, db\n"
   "  local rest\n"
   "  \n"
   "  mm(url)\n"
   "  \n"
   "  url = url:match(\"^redis://(.*)\") or url\n"
   "  pass, rest = url:match(\"^:([^@]+)@(.*)\")\n"
   "  if pass then url = rest end\n"
   "  host, rest = url:match(\"^([^:/]+)(.*)\")\n"
   "  if host then url = rest end\n"
   "  port, rest = url:match(\"^:(%d+)(.*)\")\n"
   "  if port then port=tonumber(port); url = rest end\n"
   "  db = url:match(\"^/(%d+)\")\n"
   "  if db then db = tonumber(db) end\n"
   "  \n"
   "  local ret = {\n"
   "    url=(\"redis://%s%s:%i%s\"):format(pass and \":\"..pass..\"@\" or \"\", host, port, db and \"/\"..db or \"\"),\n"
   "    host = host,\n"
   "    port = port,\n"
   "    pass = pass,\n"
   "    db = db\n"
   "  }\n"
   "  mm(ret)\n"
   "  \n"
   "  return ret\n"
   "end\n"
   "\n"
   "local redises = {}\n"
   "  \n"
   "function registerRedis(url)\n"
   "  local exists = redises[url]\n"
   "  if exists then return exists end\n"
   "  \n"
   "  local parsedUrl = parseRedisUrl(url)\n"
   "  \n"
   "  local r = Redis.new(parsedUrl.host, parsedUrl.port, parsedUrl.pass, parsedUrl.db)\n"
   "  redises[parsedUrl.url]=r\n"
   "  mm(redises)\n"
   "  return parsedUrl.url\n"
   "end\n"
   "\n"
   "function connectRedises()\n"
   "  for _, r in pairs(redises) do\n"
   "    r:connect()\n"
   "  end\n"
   "end\n"
   "\n"
   "return function(redis_connect, redis_close, redis_command, loadscripts, timeout, get_hiredis_asyncContext_peername)\n"
   "  assert(type(redis_connect) == \"function\")\n"
   "  assert(type(redis_command) == \"function\")\n"
   "  assert(type(loadscripts) == \"function\")\n"
   "  assert(type(timeout) == \"function\")\n"
   "  Redis.c.redis_connect = redis_connect\n"
   "  Redis.c.redis_close = redis_close\n"
   "  Redis.c.redis_command = redis_command\n"
   "  Redis.c.loadscripts = loadscripts\n"
   "  Redis.c.timeout = timeout\n"
   "  Redis.c.get_hiredis_asyncContext_peername = get_hiredis_asyncContext_peername\n"
   "end\n"},

  {"tag", 
   "local tags = {}\n"
   "local rawset, rawget = rawset, rawget\n"
   "\n"
   "--luacheck: globals findTag setTag clearTags\n"
   "\n"
   "function findTag(ref, key)\n"
   "  local mytags = rawget(tags, ref)\n"
   "  return mytags and rawget(mytags, key) or nil\n"
   "end\n"
   "\n"
   "function setTag(ref, key)\n"
   "  local mytags = rawget(tags, ref)\n"
   "  if not mytags then\n"
   "    rawset(tags, ref, {[key]=true})\n"
   "    return true\n"
   "  else\n"
   "    rawset(mytags, key, true)\n"
   "    return nil\n"
   "  end\n"
   "end\n"
   "function clearTags(ref)\n"
   "  rawset(tags, ref, nil)\n"
   "end\n"},

  {"tracer", 
   "local mm = require \"mm\"\n"
   "--luacheck: globals newTracer getTracer\n"
   "local ngx = {}\n"
   "\n"
   "local tracers = {}\n"
   "  \n"
   "local Tracer = {}\n"
   "local tracer_mt = {__index = Tracer}\n"
   "\n"
   "local function tracerCleaner(ref)\n"
   "  print(\"CLEANED UP AFTER TRACER\")\n"
   "  tracers[ref] = nil\n"
   "end\n"
   "\n"
   "function newTracer(ref_type, req_ref)\n"
   "  local tracer = {\n"
   "    stack = {},\n"
   "    complete = {},\n"
   "    defer = 0,\n"
   "    cur = 0,\n"
   "    \n"
   "    profile = true\n"
   "  }\n"
   "  setmetatable(tracer, tracer_mt)\n"
   "  tracers[req_ref] = tracer\n"
   "  if ref_type == \"request\" then\n"
   "    ngx.add_request_cleanup_handler(req_ref, tracerCleaner)\n"
   "  else\n"
   "    error(\"don't know how to do this\")\n"
   "  end\n"
   "  \n"
   "  return tracer\n"
   "end\n"
   "\n"
   "function getTracer(ref_type, req_ref)\n"
   "  local tracer =  tracers[req_ref] or newTracer(ref_type, req_ref)\n"
   "  --mm(tracer)\n"
   "  return tracer\n"
   "end\n"
   "\n"
   "function Tracer:push(element, el_name, el_gen, el_ref)\n"
   "  print(\"pushing\", element, el_name, \"defer:\", self.defer)\n"
   "  self.cur = self.cur + 1\n"
   "  local el\n"
   "  if self.defer == 0 then\n"
   "    el = {\n"
   "      type = element,\n"
   "      name = el_name,\n"
   "      --gen = el_gen,\n"
   "      --ref = el_ref,\n"
   "      \n"
   "      time = { }\n"
   "    }\n"
   "    if self.profile then\n"
   "      el.time.start = ngx.time_msec()\n"
   "    end\n"
   "    table.insert(self.stack, self.cur, el)\n"
   "  else\n"
   "    el = self.stack[self.cur]\n"
   "    self.defer = self.defer - 1\n"
   "    assert(el.deferred)\n"
   "    --assert(el.ref == el_ref)\n"
   "    el.deferred = nil\n"
   "    if el.time.defer_start then\n"
   "      el.time.defer = (el.time.defer or 0) + (ngx.time_msec() - el.time.defer_start)\n"
   "      el.time.defer_start = nil\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "function Tracer:pop(element, rc, ...)\n"
   "  local el\n"
   "  print(\"popping\", element, rc)\n"
   "  if rc == \"defer\" then\n"
   "    self.defer = self.defer + 1\n"
   "    el = self.stack[self.cur]\n"
   "    assert(el.type == element)\n"
   "    el.deferred = true\n"
   "    if self.profile then\n"
   "      el.time.defer_start = ngx.time_msec()\n"
   "    end\n"
   "    if el.time.start then\n"
   "      el.time.run = el.time.run or 0 + (ngx.time_msec() - el.time.start)\n"
   "      el.time.start = nil\n"
   "    end\n"
   "  else\n"
   "    el = self.stack[self.cur]\n"
   "    assert(el.type == element)\n"
   "    el.result = rc\n"
   "    if rc == \"error\" then\n"
   "      el.error = ({...})[1]\n"
   "    end\n"
   "    if el.time.start then\n"
   "      el.time.run = el.time.run or 0 + (ngx.time_msec() - el.time.start)\n"
   "      el.time.total = el.time.run + (el.time.defer or 0)\n"
   "      el.time.start = nil\n"
   "    end\n"
   "    table.remove(self.stack, self.cur)\n"
   "    self:completeElement(el);\n"
   "  end\n"
   "  self.cur = self.cur - 1\n"
   "end\n"
   "\n"
   "function Tracer:log(data_name, data)\n"
   "  local el = self.stack[self.cur]\n"
   "  if not el.data then el.data = {} end\n"
   "  el.data[data_name]=data\n"
   "end\n"
   "\n"
   "function Tracer:log_array(data_name, data)\n"
   "  local el = self.stack[self.cur]\n"
   "  if not el.data then el.data = {} end\n"
   "  if not el.data[data_name] then\n"
   "    el.data[data_name] = {}\n"
   "  end\n"
   "  table.insert(el.data[data_name], data)\n"
   "end\n"
   "\n"
   "local parent_type = {\n"
   "  condition=  \"rule\",\n"
   "  action=     \"rule\",\n"
   "  rule=       \"list\",\n"
   "  list=       \"phase\",\n"
   "  phase=      \"ruleset\",\n"
   "  ruleset=    \"root\"\n"
   "}\n"
   "\n"
   "function Tracer:getTop(element)\n"
   "  mm(self.stack)\n"
   "  if element == \"root\" then\n"
   "    return self.complete\n"
   "  end\n"
   "  local cur\n"
   "  for i = #self.stack, 1, -1 do\n"
   "    cur = self.stack[i]\n"
   "    if cur.type == element then\n"
   "      return cur\n"
   "    end\n"
   "  end\n"
   "  error(\"element type \" .. element .. \" not found in stack\")\n"
   "end\n"
   "\n"
   "function Tracer:completeElement(el)\n"
   "  local parent = self:getTop(parent_type[el.type])\n"
   "  if not parent[el.type] then parent[el.type]={} end\n"
   "  table.insert(parent[el.type], el)\n"
   "end\n"
   "\n"
   "function Tracer:finish()\n"
   "  if self.defer >  0 then\n"
   "    return\n"
   "  end\n"
   "  mm(self)\n"
   "end\n"
   "\n"
   "return function(ngx_cached_msec_time, ngx_cached_time, ngx_add_request_cleanup_handler, ngx_error_log)\n"
   "  ngx.time_msec = function()\n"
   "    local sec, msec = ngx_cached_msec_time()\n"
   "    return sec + msec/1000\n"
   "  end\n"
   "  ngx.time_cached = ngx_cached_time\n"
   "  ngx.error_log = ngx_error_log\n"
   "  ngx.add_request_cleanup_handler = ngx_add_request_cleanup_handler\n"
   "end\n"},

  {"util", 
   "local reqs = {}\n"
   "--luacheck: globals trackPtr getTrackedPtr untrackPtr\n"
   "function trackPtr(request_ptr, data)\n"
   "  local first_time = reqs[request_ptr] == nil\n"
   "  reqs[request_ptr] = true\n"
   "  return first_time\n"
   "end\n"
   "\n"
   "function getTrackedPtr(request_ptr)\n"
   "  return reqs[request_ptr]\n"
   "end\n"
   "\n"
   "function untrackPtr(request_ptr)\n"
   "  reqs[request_ptr]=nil\n"
   "end\n"}
};
wfx_module_lua_scripts_t wfx_module_lua_scripts = {
  {"binding", 
   "local binds = {}\n"
   "local Binding = {\n"
   "  bindings = binds,\n"
   "  require_create_userdata = false,\n"
   "  require_binding = false\n"
   "}\n"
   "setmetatable(binds, {__index = function(t,k)\n"
   "  if Binding.require_binding then\n"
   "    error(\"missing binding for \" .. tostring(k))\n"
   "  end\n"
   "end})\n"
   "--local mm = require \"mm\"\n"
   "\n"
   "local calls = {\n"
   "  create = function(create_callback, self, ...)\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'self' to be table, got %s)\"):format(type(self))\n"
   "    end\n"
   "    local ref = create_callback(self, ...)\n"
   "    if (Binding.require_create_userdata or ref) and type(ref) ~= \"userdata\" then\n"
   "      return nil, (\"expected userdata, got %s\"):format(type(ref))\n"
   "    elseif type(ref) == \"userdata\" then\n"
   "      self.__binding = ref\n"
   "    end\n"
   "    return true\n"
   "  end,\n"
   "  update = function(update_callback, self, update_name, update_data)\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'self' to be table, got %s)\"):format(type(self))\n"
   "    end\n"
   "    if type(update_name) ~= \"string\" then\n"
   "      return nil, (\"expected 'update_name' to be string, got %s)\"):format(type(self))\n"
   "    end\n"
   "    local ref = update_callback(self, update_name, update_data, self.ruleset)\n"
   "    if type(ref) == \"userdata\" then\n"
   "      self.__binding = ref\n"
   "    end\n"
   "    return true\n"
   "  end,\n"
   "  replace = function(replace_callback, self, replacee)\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'self'(replacement) to be table, got %s)\"):format(type(self))\n"
   "    end\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'replacee' to be table, got %s)\"):format(type(replacee))\n"
   "    end\n"
   "    if self.ruleset ~= replacee.ruleset then\n"
   "      return nil, \"replacement ruleset differs from replacee ruleset\"\n"
   "    end\n"
   "    local ref = replace_callback(self, replacee, self.ruleset)\n"
   "    if type(ref) == \"userdata\" then\n"
   "      self.__binding = ref\n"
   "    end\n"
   "    return true\n"
   "  end,\n"
   "  delete = function(delete_callback, self)\n"
   "    if type(self) ~= \"table\" then\n"
   "      return nil, (\"expected 'self' to be table, got %s)\"):format(type(self))\n"
   "    end\n"
   "    assert(type(self.__binding) == \"userdata\", (\"expected seld.__binding userdata, got %s\"):format(type(self.__binding)))\n"
   "    delete_callback(self.__binding, self, self.ruleset)\n"
   "    return true\n"
   "  end\n"
   "}\n"
   "\n"
   "function Binding.set(name, create, replace, update, delete)\n"
   "  assert(not rawget(binds, name), (\"binding %s already set\"):format(name))\n"
   "  assert(type(name)==\"string\", \"binding name must be a string, got \" .. type(name))\n"
   "  if type(create) == \"table\" and replace == nil and update == nil and delete == nil then\n"
   "    local tbl = create\n"
   "    create = tbl.create\n"
   "    replace = tbl.replace\n"
   "    update = tbl.update\n"
   "    delete = tbl.delete\n"
   "  end\n"
   "  \n"
   "  local callbacks = {\n"
   "    create = create,\n"
   "    replace = replace,\n"
   "    update = update,\n"
   "    delete = delete\n"
   "  }\n"
   "  \n"
   "  for n,f in pairs(callbacks) do\n"
   "    assert(type(f) == \"function\" or type(f) == nil, (\"\\\"%s\\\" binding \\\"%s\\\" callback must be function or nil, was %s\"):format(name, n, type(f)))\n"
   "  end\n"
   "  \n"
   "  binds[name]=callbacks\n"
   "end\n"
   "function Binding.call(binding_name, call_name, ...)\n"
   "  local callbacks = binds[binding_name]\n"
   "  if not callbacks then return end\n"
   "  local binding_call = calls[call_name]\n"
   "  if not binding_call then\n"
   "    error((\"unknown binding call \\\"%s\\\" for \\\"%s\\\"\"):format(call_name, binding_name))\n"
   "  end\n"
   "  if not callbacks[call_name] then\n"
   "    error((\"no callback for binding call \\\"%s\\\" for \\\"%s\\\"\"):format(call_name, binding_name))\n"
   "  end\n"
   "  local ok, err = binding_call(callbacks[call_name], ...)\n"
   "  if not ok then\n"
   "    error((\"Binding \\\"%s\\\" call \\\"%s\\\" error: %s\"):format(binding_name, call_name, err))\n"
   "  end\n"
   "  return ok\n"
   "end\n"
   "\n"
   "return Binding\n"},

  {"dkjson", 
   "--David Kolf's JSON module for Lua 5.1/5.2\n"
   "--small hack to generate object and array metatables by slact\n"
   "\n"
   "local always_try_using_lpeg = false\n"
   "local register_global_module_table = false\n"
   "local global_module_name = 'json'\n"
   "\n"
   "--luacheck: ignore\n"
   "\n"
   "--[==[\n"
   "\n"
   "David Kolf's JSON module for Lua 5.1/5.2\n"
   "\n"
   "Version 2.5\n"
   "\n"
   "\n"
   "For the documentation see the corresponding readme.txt or visit\n"
   "<http://dkolf.de/src/dkjson-lua.fsl/>.\n"
   "\n"
   "You can contact the author by sending an e-mail to 'david' at the\n"
   "domain 'dkolf.de'.\n"
   "\n"
   "\n"
   "Copyright (C) 2010-2013 David Heiko Kolf\n"
   "\n"
   "Permission is hereby granted, free of charge, to any person obtaining\n"
   "a copy of this software and associated documentation files (the\n"
   "\"Software\"), to deal in the Software without restriction, including\n"
   "without limitation the rights to use, copy, modify, merge, publish,\n"
   "distribute, sublicense, and/or sell copies of the Software, and to\n"
   "permit persons to whom the Software is furnished to do so, subject to\n"
   "the following conditions:\n"
   "\n"
   "The above copyright notice and this permission notice shall be\n"
   "included in all copies or substantial portions of the Software.\n"
   "\n"
   "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n"
   "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
   "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
   "NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n"
   "BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n"
   "ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n"
   "CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
   "SOFTWARE.\n"
   "\n"
   "--]==]\n"
   "\n"
   "-- global dependencies:\n"
   "local pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset =\n"
   "      pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset\n"
   "local error, require, pcall, select = error, require, pcall, select\n"
   "local floor, huge = math.floor, math.huge\n"
   "local strrep, gsub, strsub, strbyte, strchar, strfind, strlen, strformat =\n"
   "      string.rep, string.gsub, string.sub, string.byte, string.char,\n"
   "      string.find, string.len, string.format\n"
   "local strmatch = string.match\n"
   "local concat = table.concat\n"
   "\n"
   "local json = { version = \"dkjson 2.5\" }\n"
   "\n"
   "if register_global_module_table then\n"
   "  _G[global_module_name] = json\n"
   "end\n"
   "\n"
   "local _ENV = nil -- blocking globals in Lua 5.2\n"
   "\n"
   "pcall (function()\n"
   "  -- Enable access to blocked metatables.\n"
   "  -- Don't worry, this module doesn't change anything in them.\n"
   "  local debmeta = require \"debug\".getmetatable\n"
   "  if debmeta then getmetatable = debmeta end\n"
   "end)\n"
   "\n"
   "json.null = setmetatable ({}, {\n"
   "  __tojson = function () return \"null\" end\n"
   "})\n"
   "\n"
   "local function isarray (tbl)\n"
   "  local max, n, arraylen = 0, 0, 0\n"
   "  for k,v in pairs (tbl) do\n"
   "    if k == 'n' and type(v) == 'number' then\n"
   "      arraylen = v\n"
   "      if v > max then\n"
   "        max = v\n"
   "      end\n"
   "    else\n"
   "      if type(k) ~= 'number' or k < 1 or floor(k) ~= k then\n"
   "        return false\n"
   "      end\n"
   "      if k > max then\n"
   "        max = k\n"
   "      end\n"
   "      n = n + 1\n"
   "    end\n"
   "  end\n"
   "  if max > 10 and max > arraylen and max > n * 2 then\n"
   "    return false -- don't create an array with too many holes\n"
   "  end\n"
   "  return true, max\n"
   "end\n"
   "\n"
   "local escapecodes = {\n"
   "  [\"\\\"\"] = \"\\\\\\\"\", [\"\\\\\"] = \"\\\\\\\\\", [\"\\b\"] = \"\\\\b\", [\"\\f\"] = \"\\\\f\",\n"
   "  [\"\\n\"] = \"\\\\n\",  [\"\\r\"] = \"\\\\r\",  [\"\\t\"] = \"\\\\t\"\n"
   "}\n"
   "\n"
   "local function escapeutf8 (uchar)\n"
   "  local value = escapecodes[uchar]\n"
   "  if value then\n"
   "    return value\n"
   "  end\n"
   "  local a, b, c, d = strbyte (uchar, 1, 4)\n"
   "  a, b, c, d = a or 0, b or 0, c or 0, d or 0\n"
   "  if a <= 0x7f then\n"
   "    value = a\n"
   "  elseif 0xc0 <= a and a <= 0xdf and b >= 0x80 then\n"
   "    value = (a - 0xc0) * 0x40 + b - 0x80\n"
   "  elseif 0xe0 <= a and a <= 0xef and b >= 0x80 and c >= 0x80 then\n"
   "    value = ((a - 0xe0) * 0x40 + b - 0x80) * 0x40 + c - 0x80\n"
   "  elseif 0xf0 <= a and a <= 0xf7 and b >= 0x80 and c >= 0x80 and d >= 0x80 then\n"
   "    value = (((a - 0xf0) * 0x40 + b - 0x80) * 0x40 + c - 0x80) * 0x40 + d - 0x80\n"
   "  else\n"
   "    return \"\"\n"
   "  end\n"
   "  if value <= 0xffff then\n"
   "    return strformat (\"\\\\u%.4x\", value)\n"
   "  elseif value <= 0x10ffff then\n"
   "    -- encode as UTF-16 surrogate pair\n"
   "    value = value - 0x10000\n"
   "    local highsur, lowsur = 0xD800 + floor (value/0x400), 0xDC00 + (value % 0x400)\n"
   "    return strformat (\"\\\\u%.4x\\\\u%.4x\", highsur, lowsur)\n"
   "  else\n"
   "    return \"\"\n"
   "  end\n"
   "end\n"
   "\n"
   "local function fsub (str, pattern, repl)\n"
   "  -- gsub always builds a new string in a buffer, even when no match\n"
   "  -- exists. First using find should be more efficient when most strings\n"
   "  -- don't contain the pattern.\n"
   "  if strfind (str, pattern) then\n"
   "    return gsub (str, pattern, repl)\n"
   "  else\n"
   "    return str\n"
   "  end\n"
   "end\n"
   "\n"
   "local function quotestring (value)\n"
   "  -- based on the regexp \"escapable\" in https://github.com/douglascrockford/JSON-js\n"
   "  value = fsub (value, \"[%z\\1-\\31\\\"\\\\\\127]\", escapeutf8)\n"
   "  if strfind (value, \"[\\194\\216\\220\\225\\226\\239]\") then\n"
   "    value = fsub (value, \"\\194[\\128-\\159\\173]\", escapeutf8)\n"
   "    value = fsub (value, \"\\216[\\128-\\132]\", escapeutf8)\n"
   "    value = fsub (value, \"\\220\\143\", escapeutf8)\n"
   "    value = fsub (value, \"\\225\\158[\\180\\181]\", escapeutf8)\n"
   "    value = fsub (value, \"\\226\\128[\\140-\\143\\168-\\175]\", escapeutf8)\n"
   "    value = fsub (value, \"\\226\\129[\\160-\\175]\", escapeutf8)\n"
   "    value = fsub (value, \"\\239\\187\\191\", escapeutf8)\n"
   "    value = fsub (value, \"\\239\\191[\\176-\\191]\", escapeutf8)\n"
   "  end\n"
   "  return \"\\\"\" .. value .. \"\\\"\"\n"
   "end\n"
   "json.quotestring = quotestring\n"
   "\n"
   "local function replace(str, o, n)\n"
   "  local i, j = strfind (str, o, 1, true)\n"
   "  if i then\n"
   "    return strsub(str, 1, i-1) .. n .. strsub(str, j+1, -1)\n"
   "  else\n"
   "    return str\n"
   "  end\n"
   "end\n"
   "\n"
   "-- locale independent num2str and str2num functions\n"
   "local decpoint, numfilter\n"
   "\n"
   "local function updatedecpoint ()\n"
   "  decpoint = strmatch(tostring(0.5), \"([^05+])\")\n"
   "  -- build a filter that can be used to remove group separators\n"
   "  numfilter = \"[^0-9%-%+eE\" .. gsub(decpoint, \"[%^%$%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\") .. \"]+\"\n"
   "end\n"
   "\n"
   "updatedecpoint()\n"
   "\n"
   "local function num2str (num)\n"
   "  return replace(fsub(tostring(num), numfilter, \"\"), decpoint, \".\")\n"
   "end\n"
   "\n"
   "local function str2num (str)\n"
   "  local num = tonumber(replace(str, \".\", decpoint))\n"
   "  if not num then\n"
   "    updatedecpoint()\n"
   "    num = tonumber(replace(str, \".\", decpoint))\n"
   "  end\n"
   "  return num\n"
   "end\n"
   "\n"
   "local function addnewline2 (level, buffer, buflen)\n"
   "  buffer[buflen+1] = \"\\n\"\n"
   "  buffer[buflen+2] = strrep (\"  \", level)\n"
   "  buflen = buflen + 2\n"
   "  return buflen\n"
   "end\n"
   "\n"
   "function json.addnewline (state)\n"
   "  if state.indent then\n"
   "    state.bufferlen = addnewline2 (state.level or 0,\n"
   "                           state.buffer, state.bufferlen or #(state.buffer))\n"
   "  end\n"
   "end\n"
   "\n"
   "local encode2 -- forward declaration\n"
   "\n"
   "local function addpair (key, value, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "  local kt = type (key)\n"
   "  if kt ~= 'string' and kt ~= 'number' then\n"
   "    return nil, \"type '\" .. kt .. \"' is not supported as a key by JSON.\"\n"
   "  end\n"
   "  if prev then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = \",\"\n"
   "  end\n"
   "  if indent then\n"
   "    buflen = addnewline2 (level, buffer, buflen)\n"
   "  end\n"
   "  buffer[buflen+1] = quotestring (key)\n"
   "  buffer[buflen+2] = \":\"\n"
   "  return encode2 (value, indent, level, buffer, buflen + 2, tables, globalorder, state)\n"
   "end\n"
   "\n"
   "local function appendcustom(res, buffer, state)\n"
   "  local buflen = state.bufferlen\n"
   "  if type (res) == 'string' then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = res\n"
   "  end\n"
   "  return buflen\n"
   "end\n"
   "\n"
   "local function exception(reason, value, state, buffer, buflen, defaultmessage)\n"
   "  defaultmessage = defaultmessage or reason\n"
   "  local handler = state.exception\n"
   "  if not handler then\n"
   "    return nil, defaultmessage\n"
   "  else\n"
   "    state.bufferlen = buflen\n"
   "    local ret, msg = handler (reason, value, state, defaultmessage)\n"
   "    if not ret then return nil, msg or defaultmessage end\n"
   "    return appendcustom(ret, buffer, state)\n"
   "  end\n"
   "end\n"
   "\n"
   "function json.encodeexception(reason, value, state, defaultmessage)\n"
   "  return quotestring(\"<\" .. defaultmessage .. \">\")\n"
   "end\n"
   "\n"
   "encode2 = function (value, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "  local valtype = type (value)\n"
   "  local valmeta = getmetatable (value)\n"
   "  valmeta = type (valmeta) == 'table' and valmeta -- only tables\n"
   "  local replacementjsonval = valmeta and valmeta.__jsonval\n"
   "  if replacementjsonval then\n"
   "    if type(replacementjsonval) == \"function\" then\n"
   "      value = replacementjsonval(value)\n"
   "    else\n"
   "      value = replacementjsonval\n"
   "    end\n"
   "    valtype = type (value)\n"
   "  end\n"
   "  \n"
   "  local valtojson = valmeta and valmeta.__tojson\n"
   "  if valtojson then\n"
   "    if tables[value] then\n"
   "      return exception('reference cycle', value, state, buffer, buflen)\n"
   "    end\n"
   "    tables[value] = true\n"
   "    state.bufferlen = buflen\n"
   "    local ret, msg = valtojson (value, state)\n"
   "    if not ret then return exception('custom encoder failed', value, state, buffer, buflen, msg) end\n"
   "    tables[value] = nil\n"
   "    buflen = appendcustom(ret, buffer, state)\n"
   "  elseif value == nil then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = \"null\"\n"
   "  elseif valtype == 'number' then\n"
   "    local s\n"
   "    if value ~= value or value >= huge or -value >= huge then\n"
   "      -- This is the behaviour of the original JSON implementation.\n"
   "      s = \"null\"\n"
   "    else\n"
   "      s = num2str (value)\n"
   "    end\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = s\n"
   "  elseif valtype == 'boolean' then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = value and \"true\" or \"false\"\n"
   "  elseif valtype == 'string' then\n"
   "    buflen = buflen + 1\n"
   "    buffer[buflen] = quotestring (value)\n"
   "  elseif valtype == 'table' then\n"
   "    if tables[value] then\n"
   "      return exception('reference cycle', value, state, buffer, buflen)\n"
   "    end\n"
   "    tables[value] = true\n"
   "    level = level + 1\n"
   "    local isa, n = isarray (value)\n"
   "    if n == 0 and valmeta and valmeta.__jsontype == 'object' then\n"
   "      isa = false\n"
   "    end\n"
   "    local msg\n"
   "    if isa then -- JSON array\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"[\"\n"
   "      for i = 1, n do\n"
   "        buflen, msg = encode2 (value[i], indent, level, buffer, buflen, tables, globalorder, state)\n"
   "        if not buflen then return nil, msg end\n"
   "        if i < n then\n"
   "          buflen = buflen + 1\n"
   "          buffer[buflen] = \",\"\n"
   "        end\n"
   "      end\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"]\"\n"
   "    else -- JSON object\n"
   "      local prev = false\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"{\"\n"
   "      local order = valmeta and valmeta.__jsonorder or globalorder\n"
   "      if order then\n"
   "        if type(order) == \"function\" then order = order(value) end\n"
   "        local used = {}\n"
   "        n = #order\n"
   "        for i = 1, n do\n"
   "          local k = order[i]\n"
   "          local v = value[k]\n"
   "          if v then\n"
   "            used[k] = true\n"
   "            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "            prev = true -- add a seperator before the next element\n"
   "          end\n"
   "        end\n"
   "        for k,v in pairs (value) do\n"
   "          if not used[k] then\n"
   "            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "            if not buflen then return nil, msg end\n"
   "            prev = true -- add a seperator before the next element\n"
   "          end\n"
   "        end\n"
   "      else -- unordered\n"
   "        for k,v in pairs (value) do\n"
   "          buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "          if not buflen then return nil, msg end\n"
   "          prev = true -- add a seperator before the next element\n"
   "        end\n"
   "      end\n"
   "      if indent then\n"
   "        buflen = addnewline2 (level - 1, buffer, buflen)\n"
   "      end\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"}\"\n"
   "    end\n"
   "    tables[value] = nil\n"
   "  else\n"
   "    return exception ('unsupported type', value, state, buffer, buflen,\n"
   "      \"type '\" .. valtype .. \"' is not supported by JSON.\")\n"
   "  end\n"
   "  return buflen\n"
   "end\n"
   "\n"
   "function json.encode (value, state)\n"
   "  state = state or {}\n"
   "  local oldbuffer = state.buffer\n"
   "  local buffer = oldbuffer or {}\n"
   "  state.buffer = buffer\n"
   "  updatedecpoint()\n"
   "  local ret, msg = encode2 (value, state.indent, state.level or 0,\n"
   "                   buffer, state.bufferlen or 0, state.tables or {}, state.keyorder, state)\n"
   "  if not ret then\n"
   "    error (msg, 2)\n"
   "  elseif oldbuffer == buffer then\n"
   "    state.bufferlen = ret\n"
   "    return true\n"
   "  else\n"
   "    state.bufferlen = nil\n"
   "    state.buffer = nil\n"
   "    return concat (buffer)\n"
   "  end\n"
   "end\n"
   "\n"
   "local function loc(str, where)\n"
   "  local line, pos, linepos = 1, 1, 0\n"
   "  while true do\n"
   "    pos = strfind (str, \"\\n\", pos, true)\n"
   "    if pos and pos < where then\n"
   "      line = line + 1\n"
   "      linepos = pos\n"
   "      pos = pos + 1\n"
   "    else\n"
   "      break\n"
   "    end\n"
   "  end\n"
   "  return \"line \" .. line .. \", column \" .. (where - linepos)\n"
   "end\n"
   "\n"
   "local function unterminated (str, what, where)\n"
   "  return nil, strlen (str) + 1, \"unterminated \" .. what .. \" at \" .. loc (str, where)\n"
   "end\n"
   "\n"
   "local function scanwhite (str, pos)\n"
   "  while true do\n"
   "    pos = strfind (str, \"%S\", pos)\n"
   "    if not pos then return nil end\n"
   "    local sub2 = strsub (str, pos, pos + 1)\n"
   "    if sub2 == \"\\239\\187\" and strsub (str, pos + 2, pos + 2) == \"\\191\" then\n"
   "      -- UTF-8 Byte Order Mark\n"
   "      pos = pos + 3\n"
   "    elseif sub2 == \"//\" then\n"
   "      pos = strfind (str, \"[\\n\\r]\", pos + 2)\n"
   "      if not pos then return nil end\n"
   "    elseif sub2 == \"/*\" then\n"
   "      pos = strfind (str, \"*/\", pos + 2)\n"
   "      if not pos then return nil end\n"
   "      pos = pos + 2\n"
   "    else\n"
   "      return pos\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "local escapechars = {\n"
   "  [\"\\\"\"] = \"\\\"\", [\"\\\\\"] = \"\\\\\", [\"/\"] = \"/\", [\"b\"] = \"\\b\", [\"f\"] = \"\\f\",\n"
   "  [\"n\"] = \"\\n\", [\"r\"] = \"\\r\", [\"t\"] = \"\\t\"\n"
   "}\n"
   "\n"
   "local function unichar (value)\n"
   "  if value < 0 then\n"
   "    return nil\n"
   "  elseif value <= 0x007f then\n"
   "    return strchar (value)\n"
   "  elseif value <= 0x07ff then\n"
   "    return strchar (0xc0 + floor(value/0x40),\n"
   "                    0x80 + (floor(value) % 0x40))\n"
   "  elseif value <= 0xffff then\n"
   "    return strchar (0xe0 + floor(value/0x1000),\n"
   "                    0x80 + (floor(value/0x40) % 0x40),\n"
   "                    0x80 + (floor(value) % 0x40))\n"
   "  elseif value <= 0x10ffff then\n"
   "    return strchar (0xf0 + floor(value/0x40000),\n"
   "                    0x80 + (floor(value/0x1000) % 0x40),\n"
   "                    0x80 + (floor(value/0x40) % 0x40),\n"
   "                    0x80 + (floor(value) % 0x40))\n"
   "  else\n"
   "    return nil\n"
   "  end\n"
   "end\n"
   "\n"
   "local function scanstring (str, pos)\n"
   "  local lastpos = pos + 1\n"
   "  local buffer, n = {}, 0\n"
   "  while true do\n"
   "    local nextpos = strfind (str, \"[\\\"\\\\]\", lastpos)\n"
   "    if not nextpos then\n"
   "      return unterminated (str, \"string\", pos)\n"
   "    end\n"
   "    if nextpos > lastpos then\n"
   "      n = n + 1\n"
   "      buffer[n] = strsub (str, lastpos, nextpos - 1)\n"
   "    end\n"
   "    if strsub (str, nextpos, nextpos) == \"\\\"\" then\n"
   "      lastpos = nextpos + 1\n"
   "      break\n"
   "    else\n"
   "      local escchar = strsub (str, nextpos + 1, nextpos + 1)\n"
   "      local value\n"
   "      if escchar == \"u\" then\n"
   "        value = tonumber (strsub (str, nextpos + 2, nextpos + 5), 16)\n"
   "        if value then\n"
   "          local value2\n"
   "          if 0xD800 <= value and value <= 0xDBff then\n"
   "            -- we have the high surrogate of UTF-16. Check if there is a\n"
   "            -- low surrogate escaped nearby to combine them.\n"
   "            if strsub (str, nextpos + 6, nextpos + 7) == \"\\\\u\" then\n"
   "              value2 = tonumber (strsub (str, nextpos + 8, nextpos + 11), 16)\n"
   "              if value2 and 0xDC00 <= value2 and value2 <= 0xDFFF then\n"
   "                value = (value - 0xD800)  * 0x400 + (value2 - 0xDC00) + 0x10000\n"
   "              else\n"
   "                value2 = nil -- in case it was out of range for a low surrogate\n"
   "              end\n"
   "            end\n"
   "          end\n"
   "          value = value and unichar (value)\n"
   "          if value then\n"
   "            if value2 then\n"
   "              lastpos = nextpos + 12\n"
   "            else\n"
   "              lastpos = nextpos + 6\n"
   "            end\n"
   "          end\n"
   "        end\n"
   "      end\n"
   "      if not value then\n"
   "        value = escapechars[escchar] or escchar\n"
   "        lastpos = nextpos + 2\n"
   "      end\n"
   "      n = n + 1\n"
   "      buffer[n] = value\n"
   "    end\n"
   "  end\n"
   "  if n == 1 then\n"
   "    return buffer[1], lastpos\n"
   "  elseif n > 1 then\n"
   "    return concat (buffer), lastpos\n"
   "  else\n"
   "    return \"\", lastpos\n"
   "  end\n"
   "end\n"
   "\n"
   "local scanvalue -- forward declaration\n"
   "\n"
   "local function set_scantable_metatable (tbl, meta, str, pos)\n"
   "  if type(meta)==\"function\" then\n"
   "    meta = meta(str, pos)\n"
   "    if type(meta) ~= \"table\" then\n"
   "      return tbl\n"
   "    end\n"
   "  end\n"
   "  return setmetatable(tbl, meta)\n"
   "end\n"
   "\n"
   "local function scantable (what, closechar, str, startpos, nullval, objectmeta, arraymeta)\n"
   "  local len = strlen (str)\n"
   "  local tbl, n = {}, 0\n"
   "  local pos = startpos + 1\n"
   "  if what == 'object' then\n"
   "    set_scantable_metatable(tbl, objectmeta, str, startpos)\n"
   "  else\n"
   "    set_scantable_metatable(tbl, arraymeta, str, startpos)\n"
   "  end\n"
   "  while true do\n"
   "    pos = scanwhite (str, pos)\n"
   "    if not pos then return unterminated (str, what, startpos) end\n"
   "    local char = strsub (str, pos, pos)\n"
   "    if char == closechar then\n"
   "      return tbl, pos + 1\n"
   "    end\n"
   "    local val1, err\n"
   "    val1, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "    if err then return nil, pos, err end\n"
   "    pos = scanwhite (str, pos)\n"
   "    if not pos then return unterminated (str, what, startpos) end\n"
   "    char = strsub (str, pos, pos)\n"
   "    if char == \":\" then\n"
   "      if val1 == nil then\n"
   "        return nil, pos, \"cannot use nil as table index (at \" .. loc (str, pos) .. \")\"\n"
   "      end\n"
   "      pos = scanwhite (str, pos + 1)\n"
   "      if not pos then return unterminated (str, what, startpos) end\n"
   "      local val2\n"
   "      val2, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "      if err then return nil, pos, err end\n"
   "      tbl[val1] = val2\n"
   "      pos = scanwhite (str, pos)\n"
   "      if not pos then return unterminated (str, what, startpos) end\n"
   "      char = strsub (str, pos, pos)\n"
   "    else\n"
   "      n = n + 1\n"
   "      tbl[n] = val1\n"
   "    end\n"
   "    if char == \",\" then\n"
   "      pos = pos + 1\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "scanvalue = function (str, pos, nullval, objectmeta, arraymeta)\n"
   "  pos = pos or 1\n"
   "  pos = scanwhite (str, pos)\n"
   "  if not pos then\n"
   "    return nil, strlen (str) + 1, \"no valid JSON value (reached the end)\"\n"
   "  end\n"
   "  local char = strsub (str, pos, pos)\n"
   "  if char == \"{\" then\n"
   "    return scantable ('object', \"}\", str, pos, nullval, objectmeta, arraymeta)\n"
   "  elseif char == \"[\" then\n"
   "    return scantable ('array', \"]\", str, pos, nullval, objectmeta, arraymeta)\n"
   "  elseif char == \"\\\"\" then\n"
   "    return scanstring (str, pos)\n"
   "  else\n"
   "    local pstart, pend = strfind (str, \"^%-?[%d%.]+[eE]?[%+%-]?%d*\", pos)\n"
   "    if pstart then\n"
   "      local number = str2num (strsub (str, pstart, pend))\n"
   "      if number then\n"
   "        return number, pend + 1\n"
   "      end\n"
   "    end\n"
   "    pstart, pend = strfind (str, \"^%a%w*\", pos)\n"
   "    if pstart then\n"
   "      local name = strsub (str, pstart, pend)\n"
   "      if name == \"true\" then\n"
   "        return true, pend + 1\n"
   "      elseif name == \"false\" then\n"
   "        return false, pend + 1\n"
   "      elseif name == \"null\" then\n"
   "        return nullval, pend + 1\n"
   "      end\n"
   "    end\n"
   "    return nil, pos, \"no valid JSON value at \" .. loc (str, pos)\n"
   "  end\n"
   "end\n"
   "\n"
   "local function optionalmetatables(...)\n"
   "  if select(\"#\", ...) > 0 then\n"
   "    return ...\n"
   "  else\n"
   "    return {__jsontype = 'object'}, {__jsontype = 'array'}\n"
   "  end\n"
   "end\n"
   "\n"
   "function json.decode (str, pos, nullval, ...)\n"
   "  local objectmeta, arraymeta = optionalmetatables(...)\n"
   "  return scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "end\n"
   "\n"
   "function json.use_lpeg ()\n"
   "  local g = require (\"lpeg\")\n"
   "\n"
   "  if g.version() == \"0.11\" then\n"
   "    error \"due to a bug in LPeg 0.11, it cannot be used for JSON matching\"\n"
   "  end\n"
   "\n"
   "  local pegmatch = g.match\n"
   "  local P, S, R = g.P, g.S, g.R\n"
   "\n"
   "  local function ErrorCall (str, pos, msg, state)\n"
   "    if not state.msg then\n"
   "      state.msg = msg .. \" at \" .. loc (str, pos)\n"
   "      state.pos = pos\n"
   "    end\n"
   "    return false\n"
   "  end\n"
   "\n"
   "  local function Err (msg)\n"
   "    return g.Cmt (g.Cc (msg) * g.Carg (2), ErrorCall)\n"
   "  end\n"
   "\n"
   "  local SingleLineComment = P\"//\" * (1 - S\"\\n\\r\")^0\n"
   "  local MultiLineComment = P\"/*\" * (1 - P\"*/\")^0 * P\"*/\"\n"
   "  local Space = (S\" \\n\\r\\t\" + P\"\\239\\187\\191\" + SingleLineComment + MultiLineComment)^0\n"
   "\n"
   "  local PlainChar = 1 - S\"\\\"\\\\\\n\\r\"\n"
   "  local EscapeSequence = (P\"\\\\\" * g.C (S\"\\\"\\\\/bfnrt\" + Err \"unsupported escape sequence\")) / escapechars\n"
   "  local HexDigit = R(\"09\", \"af\", \"AF\")\n"
   "  local function UTF16Surrogate (match, pos, high, low)\n"
   "    high, low = tonumber (high, 16), tonumber (low, 16)\n"
   "    if 0xD800 <= high and high <= 0xDBff and 0xDC00 <= low and low <= 0xDFFF then\n"
   "      return true, unichar ((high - 0xD800)  * 0x400 + (low - 0xDC00) + 0x10000)\n"
   "    else\n"
   "      return false\n"
   "    end\n"
   "  end\n"
   "  local function UTF16BMP (hex)\n"
   "    return unichar (tonumber (hex, 16))\n"
   "  end\n"
   "  local U16Sequence = (P\"\\\\u\" * g.C (HexDigit * HexDigit * HexDigit * HexDigit))\n"
   "  local UnicodeEscape = g.Cmt (U16Sequence * U16Sequence, UTF16Surrogate) + U16Sequence/UTF16BMP\n"
   "  local Char = UnicodeEscape + EscapeSequence + PlainChar\n"
   "  local String = P\"\\\"\" * g.Cs (Char ^ 0) * (P\"\\\"\" + Err \"unterminated string\")\n"
   "  local Integer = P\"-\"^(-1) * (P\"0\" + (R\"19\" * R\"09\"^0))\n"
   "  local Fractal = P\".\" * R\"09\"^0\n"
   "  local Exponent = (S\"eE\") * (S\"+-\")^(-1) * R\"09\"^1\n"
   "  local Number = (Integer * Fractal^(-1) * Exponent^(-1))/str2num\n"
   "  local Constant = P\"true\" * g.Cc (true) + P\"false\" * g.Cc (false) + P\"null\" * g.Carg (1)\n"
   "  local SimpleValue = Number + String + Constant\n"
   "  local ArrayContent, ObjectContent\n"
   "\n"
   "  -- The functions parsearray and parseobject parse only a single value/pair\n"
   "  -- at a time and store them directly to avoid hitting the LPeg limits.\n"
   "  local function parsearray (str, pos, nullval, state)\n"
   "    local obj, cont\n"
   "    local npos\n"
   "    local t, nt = {}, 0\n"
   "    repeat\n"
   "      obj, cont, npos = pegmatch (ArrayContent, str, pos, nullval, state)\n"
   "      if not npos then break end\n"
   "      pos = npos\n"
   "      nt = nt + 1\n"
   "      t[nt] = obj\n"
   "    until cont == 'last'\n"
   "    return pos, setmetatable (t, state.arraymeta)\n"
   "  end\n"
   "\n"
   "  local function parseobject (str, pos, nullval, state)\n"
   "    local obj, key, cont\n"
   "    local npos\n"
   "    local t = {}\n"
   "    repeat\n"
   "      key, obj, cont, npos = pegmatch (ObjectContent, str, pos, nullval, state)\n"
   "      if not npos then break end\n"
   "      pos = npos\n"
   "      t[key] = obj\n"
   "    until cont == 'last'\n"
   "    return pos, setmetatable (t, state.objectmeta)\n"
   "  end\n"
   "\n"
   "  local Array = P\"[\" * g.Cmt (g.Carg(1) * g.Carg(2), parsearray) * Space * (P\"]\" + Err \"']' expected\")\n"
   "  local Object = P\"{\" * g.Cmt (g.Carg(1) * g.Carg(2), parseobject) * Space * (P\"}\" + Err \"'}' expected\")\n"
   "  local Value = Space * (Array + Object + SimpleValue)\n"
   "  local ExpectedValue = Value + Space * Err \"value expected\"\n"
   "  ArrayContent = Value * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
   "  local Pair = g.Cg (Space * String * Space * (P\":\" + Err \"colon expected\") * ExpectedValue)\n"
   "  ObjectContent = Pair * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
   "  local DecodeValue = ExpectedValue * g.Cp ()\n"
   "\n"
   "  function json.decode (str, pos, nullval, ...)\n"
   "    local state = {}\n"
   "    state.objectmeta, state.arraymeta = optionalmetatables(...)\n"
   "    local obj, retpos = pegmatch (DecodeValue, str, pos, nullval, state)\n"
   "    if state.msg then\n"
   "      return nil, state.pos, state.msg\n"
   "    else\n"
   "      return obj, retpos\n"
   "    end\n"
   "  end\n"
   "\n"
   "  -- use this function only once:\n"
   "  json.use_lpeg = function () return json end\n"
   "\n"
   "  json.using_lpeg = true\n"
   "\n"
   "  return json -- so you can get the module using json = require \"dkjson\".use_lpeg()\n"
   "end\n"
   "\n"
   "if always_try_using_lpeg then\n"
   "  pcall (json.use_lpeg)\n"
   "end\n"
   "\n"
   "return json\n"
   "\n"},

  {"mm", 
   "--mm, a pretty printer\n"
   "\n"
   "-- Terminal color (and formatting) codes.\n"
   "local C = {\n"
   "  e = '\\27[0m', -- reset\n"
   "\n"
   "  -- Text attributes.\n"
   "  br = '\\27[1m', -- bright\n"
   "  di = '\\27[2m', -- dim\n"
   "  it = '\\27[3m', -- italics\n"
   "  un = '\\27[4m', -- underscore\n"
   "  bl = '\\27[5m', -- blink\n"
   "  re = '\\27[7m', -- reverse\n"
   "  hi = '\\27[8m', -- hidden\n"
   "\n"
   "  -- Text colors.\n"
   "  k = '\\27[30m', -- black\n"
   "  r = '\\27[31m', -- red\n"
   "  g = '\\27[32m', -- green\n"
   "  y = '\\27[33m', -- yellow\n"
   "  b = '\\27[34m', -- blue\n"
   "  m = '\\27[35m', -- magenta\n"
   "  c = '\\27[36m', -- cyan\n"
   "  w = '\\27[37m', -- white\n"
   "\n"
   "  -- Background colors.\n"
   "  _k = '\\27[40m', -- black\n"
   "  _r = '\\27[41m', -- red\n"
   "  _g = '\\27[42m', -- green\n"
   "  _y = '\\27[43m', -- yellow\n"
   "  _b = '\\27[44m', -- blue\n"
   "  _m = '\\27[45m', -- magenta\n"
   "  _c = '\\27[46m', -- cyan\n"
   "  _w = '\\27[47m'  -- white\n"
   "}\n"
   "\n"
   "--luacheck: ignore\n"
   "local METATABLE = { \"<metatable>\", colors = C.it .. C.y }\n"
   "local INDENT = \"   \"\n"
   "\n"
   "-- The default sequence separator.\n"
   "local SEP = \" \"\n"
   "\n"
   "-- The open and close brackets can be any piece (notably, a sequence with \n"
   "-- colors). The separator must be a plain string.\n"
   "local BOPEN, BSEP, BCLOSE = 1, 2, 3\n"
   "\n"
   "-- The default frame brackets and separator.\n"
   "local BRACKETS = {\n"
   "  { \"{\", colors = C.br },\n"
   "  \",\",\n"
   "  { \"}\", colors = C.br }\n"
   "}\n"
   "\n"
   "local STR_HALF = 30\n"
   "local MAX_STR_LEN = STR_HALF * 2\n"
   "\n"
   "-- Names to use for named references. The order is important; these are aligned \n"
   "-- with the colors in `NAME_COLORS`.\n"
   "local NAMES = {\n"
   "  \"Cherry\",\n"
   "  \"Apple\",\n"
   "  \"Lemon\",\n"
   "  \"Blueberry\",\n"
   "  \"Jam\",\n"
   "  \"Cream\",\n"
   "  \"Rhubarb\",\n"
   "  \"Lime\",\n"
   "  \"Butter\",\n"
   "  \"Grape\",\n"
   "  \"Pomegranate\",\n"
   "  \"Sugar\",\n"
   "  \"Cinnamon\",\n"
   "  \"Avocado\",\n"
   "  \"Honey\",\n"
   "}\n"
   "\n"
   "-- Colors to use for named references. Don't use black nor white.\n"
   "local NAME_COLORS = { C.r, C.g, C.y, C.b, C.m, C.c }\n"
   "\n"
   "-- Reserved Lua keywords as a convenient look-up table.\n"
   "local RESERVED = {\n"
   "  ['and'] = true,\n"
   "  ['break'] = true,\n"
   "  ['do'] = true,\n"
   "  ['else'] = true,\n"
   "  ['elseif'] = true,\n"
   "  ['end'] = true,\n"
   "  ['false'] = true,\n"
   "  ['for'] = true,\n"
   "  ['function'] = true,\n"
   "  ['goto'] = true,\n"
   "  ['if'] = true,\n"
   "  ['in'] = true,\n"
   "  ['local'] = true,\n"
   "  ['nil'] = true,\n"
   "  ['not'] = true,\n"
   "  ['or'] = true,\n"
   "  ['repeat'] = true,\n"
   "  ['return'] = true,\n"
   "  ['then'] = true,\n"
   "  ['true'] = true,\n"
   "  ['until'] = true,\n"
   "  ['while'] = true\n"
   "}\n"
   "\n"
   "\n"
   "--\n"
   "-- Namers\n"
   "--\n"
   "\n"
   "local function new_namer ()\n"
   "  local index = 1\n"
   "  local suffix = 1\n"
   "  local color_index = 1\n"
   "\n"
   "  return function ()\n"
   "    -- Pick the name.\n"
   "    local result = NAMES [index]\n"
   "    if suffix > 1 then\n"
   "      result = result .. \" \" .. tostring (suffix)\n"
   "    end\n"
   "\n"
   "    index = index + 1\n"
   "    if index > #NAMES then\n"
   "      index = 1\n"
   "      suffix = suffix + 1\n"
   "    end\n"
   "\n"
   "    -- Pick the color.\n"
   "    local color = NAME_COLORS [color_index]\n"
   "\n"
   "    color_index = color_index + 1\n"
   "    if color_index > #NAME_COLORS then\n"
   "      color_index = 1\n"
   "    end\n"
   "\n"
   "    return { result, colors = C.un .. color }\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "--\n"
   "-- Context\n"
   "--\n"
   "\n"
   "\n"
   "local function new_context ()\n"
   "  return {\n"
   "    occur = {},\n"
   "    named = {},\n"
   "    next_name = new_namer (),\n"
   "\n"
   "    prev_indent = '',\n"
   "    next_indent = INDENT,\n"
   "    line_len = 0,\n"
   "    max_width = 78,\n"
   "\n"
   "    result = ''\n"
   "  }\n"
   "end\n"
   "\n"
   "\n"
   "--\n"
   "-- Translating into pieces\n"
   "--\n"
   "\n"
   "-- Translaters take any Lua value and create pieces to represent them.\n"
   "--\n"
   "-- Some values should only be serialized once, both to prevent cycles and to \n"
   "-- prevent redundancy. Or in other cases, these values cannot be serialized \n"
   "-- (such as functions) but if they appear multiple times we want to express \n"
   "-- that they are the same.\n"
   "--\n"
   "-- When a translater encounters such a value for the first time, it is \n"
   "-- registered in the context in `occur`. The value is wrapped in a plain table \n"
   "-- with the `id` field pointing to the original value. If the value is \n"
   "-- serializable, such as a table, then the the `def` field contains the piece \n"
   "-- to display. If it is unserializable or it is not the first time this value \n"
   "-- has occurred, the `def` field is nil.\n"
   "--\n"
   "-- In the cleaning stage, these `id` fields are replaced with their names. If a \n"
   "-- `def` field is present, then a sequence is generated to define the name with \n"
   "-- the piece.\n"
   "\n"
   "local translaters = {}\n"
   "local translate, ident_friendly\n"
   "\n"
   "\n"
   "function translate (val, ctx)\n"
   "  -- Try to find a type-specific translater.\n"
   "  local by_type = translaters [type (val)]\n"
   "\n"
   "  if by_type then\n"
   "    -- If there is a type-specific translater, call it.\n"
   "    return by_type (val, ctx)\n"
   "  end\n"
   "\n"
   "  -- Otherwise perform the default translation.\n"
   "\n"
   "  -- Check whether we've already encountered this value.\n"
   "  if ctx.occur [val] then\n"
   "    -- We have; give it a name if we haven't already.\n"
   "    if not ctx.named [val] then\n"
   "      ctx.named [val] = ctx.next_name ()\n"
   "    end\n"
   "\n"
   "    -- Return the value as a reference.\n"
   "    return { id = val }\n"
   "  else\n"
   "    -- We haven't; mark it as encountered.\n"
   "    ctx.occur [val] = true\n"
   "\n"
   "    -- Return the value as a definition.\n"
   "    return { id = val, def = tostring (val) }\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "translaters ['function'] = function (val, ctx)\n"
   "  -- Check whether we've already encountered this function.\n"
   "  if ctx.occur [val] then\n"
   "    -- We have; give it a name if we haven't already.\n"
   "    if not ctx.named [val] then\n"
   "      ctx.named [val] = ctx.next_name ()\n"
   "    end\n"
   "  else\n"
   "    -- We haven't; mark it as encountered.\n"
   "    ctx.occur [val] = true\n"
   "  end\n"
   "\n"
   "  -- Return the unserialized function.\n"
   "  return { id = val }\n"
   "end\n"
   "\n"
   "\n"
   "function translaters.table (val, ctx)\n"
   "  -- Check whether we've already encountered this table.\n"
   "  if ctx.occur [val] then\n"
   "    -- We have; give it a name if we haven't already.\n"
   "    if not ctx.named [val] then\n"
   "      ctx.named [val] = ctx.next_name ()\n"
   "    end\n"
   "\n"
   "    -- Return the unserialized table.\n"
   "    return { id = val }\n"
   "  else\n"
   "    -- We haven't; mark it as encountered.\n"
   "    ctx.occur [val] = true\n"
   "\n"
   "    -- Construct the frame for this table.\n"
   "    local result = {\n"
   "      bracket = BRACKETS\n"
   "    }\n"
   "\n"
   "    -- The equals-sign between key and value.\n"
   "    local eq = { \"=\", colors = C.di }\n"
   "\n"
   "    -- Represent the metatable, if present.\n"
   "    local mt = getmetatable (val)\n"
   "    if mt then\n"
   "      -- Translate the metatable.\n"
   "      mt = translate (mt, ctx)\n"
   "      table.insert (result, { METATABLE, eq, mt })\n"
   "    end\n"
   "\n"
   "    -- Represent the contents.\n"
   "    for k, v in pairs (val) do\n"
   "      -- If it is a string key which can be represented without quotes, leave \n"
   "      -- it plain.\n"
   "      if ident_friendly (k) then\n"
   "        -- Leave the key as it is.\n"
   "        k = { k, colors = C.m }\n"
   "      else\n"
   "        -- Otherwise translate the key.\n"
   "        k = translate (k, ctx)\n"
   "      end\n"
   "\n"
   "      -- Translate the value.\n"
   "      v = translate (v, ctx)\n"
   "\n"
   "      table.insert (result, { k, eq, v })\n"
   "    end\n"
   "\n"
   "    -- Wrap the result with its id.\n"
   "    return { id = val, def = result }\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "function translaters.string (val, ctx)\n"
   "  if #val <= MAX_STR_LEN then\n"
   "    -- The string is short enough; display it all.\n"
   "    local a = string.format ('%q', val)\n"
   "    a = string.gsub (a, '\\n', 'n')\n"
   "\n"
   "    return { a, colors = C.g }\n"
   "  else\n"
   "    -- The string is too long. Only show the start and end.\n"
   "    local a = string.format ('%q', string.sub (val, 1, STR_HALF))\n"
   "    a = string.gsub (a, '\\n', 'n')\n"
   "    local b = string.format ('%q', string.sub (val, -STR_HALF))\n"
   "    b = string.gsub (b, '\\n', 'n')\n"
   "\n"
   "    return { a, { \"...\", colors = C.di }, b, colors = C.g, sep = '', tight = true }\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "function translaters.number (val, ctx)\n"
   "  return { tostring (val), colors = C.m .. C.br }\n"
   "end\n"
   "\n"
   "\n"
   "-- Check whether a value can be represented as a Lua identifier, without the \n"
   "-- need for quotes or translation.\n"
   "--\n"
   "-- If the value is not a string, this immediately returns false. Otherwise, the \n"
   "-- string must be a valid Lua name: a sequence of letters, digits, and \n"
   "-- underscores that doesn't start with a digit and isn't a reserved keyword.\n"
   "--\n"
   "-- See http://www.lua.org/manual/5.3/manual.html#3.1\n"
   "function ident_friendly (val)\n"
   "  -- The value must be a string.\n"
   "  if type (val) ~= 'string' then\n"
   "    return false\n"
   "  end\n"
   "\n"
   "  if string.find (val, '^[_%a][_%a%d]*$') then\n"
   "    -- The value is a Lua name; check if it is reserved.\n"
   "    if RESERVED [val] then\n"
   "      -- The value is a resreved keyword.\n"
   "      return false\n"
   "    else\n"
   "      -- The value is a valid name.\n"
   "      return true\n"
   "    end\n"
   "  else\n"
   "    -- The value is not a Lua name.\n"
   "    return false\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "--\n"
   "-- Cleaning pieces\n"
   "--\n"
   "\n"
   "\n"
   "local function clean (piece, ctx)\n"
   "  if type (piece) == 'table' then\n"
   "    -- Check if it's an id reference.\n"
   "    if piece.id then\n"
   "      local name = ctx.named [piece.id]\n"
   "      local def = piece.def\n"
   "\n"
   "      -- Check whether it has been given a name.\n"
   "      if name then\n"
   "        local header = {\n"
   "          \"<\", type (piece.id), \" \", name, \">\",\n"
   "          colors = C.it,\n"
   "          sep = '',\n"
   "          tight = true\n"
   "        }\n"
   "        -- Named. Check whether the reference has a definition.\n"
   "        if def then\n"
   "          -- Create a sequence defining the name to the definition.\n"
   "          return { header, { \"is\", colors = C.di }, clean (piece.def, ctx) }\n"
   "        else\n"
   "          -- Show just the name.\n"
   "          return header\n"
   "        end\n"
   "      else\n"
   "        -- No name. Check whether the reference has a definition.\n"
   "        if def then\n"
   "          -- Display the definition without any header.\n"
   "          return clean (piece.def, ctx)\n"
   "        else\n"
   "          -- Display just the type.\n"
   "          return {\n"
   "            \"<\", type (piece.id), \">\",\n"
   "            colors = C.it,\n"
   "            sep = '',\n"
   "            tight = true\n"
   "          }\n"
   "        end\n"
   "      end\n"
   "\n"
   "    -- Check if it's a frame.\n"
   "    elseif piece.bracket then\n"
   "      -- Clean each child.\n"
   "      for i, child in ipairs (piece) do\n"
   "        piece [i] = clean (child, ctx)\n"
   "      end\n"
   "      return piece\n"
   "\n"
   "    -- Otherwise it's a sequence.\n"
   "    else\n"
   "      -- Clean each child.\n"
   "      for i, child in ipairs (piece) do\n"
   "        piece [i] = clean (child, ctx)\n"
   "      end\n"
   "      return piece\n"
   "    end\n"
   "  else\n"
   "    -- It's a plain value, not a table; no cleaning is needed.\n"
   "    return piece\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "--\n"
   "-- Displaying pieces\n"
   "--\n"
   "\n"
   "\n"
   "-- Pieces are either frames (with brackets), sequences (no brackets), or \n"
   "-- strings.\n"
   "\n"
   "-- Frames are displayed either short-form as { a = 1 } or long-form as\n"
   "-- {\n"
   "--   a = 1\n"
   "-- }.\n"
   "\n"
   "\n"
   "-- Declare all the local functions first, so they can refer to each other.\n"
   "local min_len, display, display_frame, display_sequence, display_string,\n"
   "      display_frame_short, display_frame_long, newline, newline_no_indent, \n"
   "      write, write_nolength, space_here, space_newline\n"
   "\n"
   "\n"
   "-- Dispatch based on the piece's type.\n"
   "function display (piece, ctx)\n"
   "  if type (piece) == 'string' then\n"
   "    -- String.\n"
   "    return display_string (piece, ctx)\n"
   "  elseif piece.bracket then\n"
   "    -- Frame.\n"
   "    return display_frame (piece, ctx)\n"
   "  else\n"
   "    -- Sequence.\n"
   "    return display_sequence (piece, ctx)\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "-- Display a frame.\n"
   "function display_frame (frame, ctx)\n"
   "  if #frame == 0 then\n"
   "    -- If the frame is empty, just display the brackets.\n"
   "    local str = {\n"
   "      frame.bracket [BOPEN], frame.bracket [BCLOSE],\n"
   "      sep = '',\n"
   "      tight = true\n"
   "    }\n"
   "    return display (str, ctx)\n"
   "  end\n"
   "\n"
   "  local ml = min_len (frame)\n"
   "\n"
   "  -- Try to fit the frame short-form on this line.\n"
   "  if ml <= space_here (ctx) then\n"
   "    return display_frame_short (frame, ctx)\n"
   "\n"
   "  -- Otherwise try to fit it short-form on the next line.\n"
   "  elseif ml <= space_newline (ctx) then\n"
   "    newline (ctx)\n"
   "    return display_frame_short (frame, ctx)\n"
   "\n"
   "  -- Otherwise display it long-form.\n"
   "  else\n"
   "    return display_frame_long (frame, ctx)\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "function display_frame_short (frame, ctx)\n"
   "  -- Short-form frames never wrap onto new lines, so we don't need to do any \n"
   "  -- length checking (it's already been done for us).\n"
   "\n"
   "  -- Write the open bracket.\n"
   "  display (frame.bracket [BOPEN], ctx)\n"
   "  write (\" \", ctx)\n"
   "\n"
   "  -- Display the first child.\n"
   "  display (frame [1], ctx)\n"
   "\n"
   "  -- Display the remaining children.\n"
   "  for i = 2, #frame do\n"
   "    local child = frame [i]\n"
   "\n"
   "    -- Write the separator.\n"
   "    write (frame.bracket [BSEP], ctx)\n"
   "    write (\" \", ctx)\n"
   "\n"
   "    -- Display the child.\n"
   "    display (child, ctx)\n"
   "  end\n"
   "\n"
   "  -- Write the close bracket.\n"
   "  write (\" \", ctx)\n"
   "  display (frame.bracket [BCLOSE], ctx)\n"
   "end\n"
   "\n"
   "\n"
   "function display_frame_long (frame, ctx)\n"
   "  -- Remember the original value of next_indent.\n"
   "  local old_old_indent = ctx.prev_indent\n"
   "  local old_indent = ctx.next_indent\n"
   "\n"
   "  -- Display the open bracket.\n"
   "  display (frame.bracket [BOPEN], ctx)\n"
   "\n"
   "  -- Increase the indentation.\n"
   "  ctx.prev_indent = old_indent\n"
   "  ctx.next_indent = old_indent .. INDENT\n"
   "\n"
   "  -- For all but the last child...\n"
   "  for i = 1, #frame - 1 do\n"
   "    local child = frame [i]\n"
   "\n"
   "    -- Start a new line with old indentation.\n"
   "    newline_no_indent (ctx)\n"
   "    write (old_indent, ctx)\n"
   "\n"
   "    -- Display the child.\n"
   "    display (child, ctx)\n"
   "\n"
   "    -- Write the separator.\n"
   "    write (frame.bracket [BSEP], ctx)\n"
   "  end\n"
   "\n"
   "  -- For the last child...\n"
   "  do\n"
   "    local child = frame [#frame]\n"
   "\n"
   "    -- Start a new line with old indentation.\n"
   "    newline_no_indent (ctx)\n"
   "    write (old_indent, ctx)\n"
   "\n"
   "    -- Display the child.\n"
   "    display (child, ctx)\n"
   "    -- No separator.\n"
   "  end\n"
   "\n"
   "  -- Write the close bracket.\n"
   "  newline_no_indent (ctx)\n"
   "  write (old_old_indent, ctx)\n"
   "  display (frame.bracket [BCLOSE], ctx)\n"
   "\n"
   "  -- Return to the old indentation.\n"
   "  ctx.prev_indent = old_old_indent\n"
   "  ctx.next_indent = old_indent\n"
   "end\n"
   "\n"
   "\n"
   "function display_sequence (piece, ctx)\n"
   "  if #piece > 0 then\n"
   "    -- Check if this is a tight sequence.\n"
   "    if piece.tight then\n"
   "      -- Try to fit the entire sequence on one line.\n"
   "      local ml = min_len (piece, ctx)\n"
   "\n"
   "      -- If it won't fit here, but it would fit on the next line, then write it \n"
   "      -- on the next line; otherwise, write it here.\n"
   "      if ml > space_here (ctx) and ml <= space_newline (ctx) then\n"
   "        newline (ctx)\n"
   "      end\n"
   "    end\n"
   "\n"
   "    -- Apply the colors, if given.\n"
   "    if piece.colors then\n"
   "      write_nolength (piece.colors, ctx)\n"
   "    end\n"
   "\n"
   "    -- Display the first child.\n"
   "    display (piece [1], ctx)\n"
   "\n"
   "    -- For each following children:\n"
   "    for i = 2, #piece do\n"
   "      local child = piece [i]\n"
   "\n"
   "      -- Apply the colors, if given.\n"
   "      if piece.colors then\n"
   "        write_nolength (piece.colors, ctx)\n"
   "      end\n"
   "\n"
   "      -- Write a separator.\n"
   "      write (piece.sep or SEP, ctx)\n"
   "\n"
   "      -- Then display the child.\n"
   "      display (child, ctx)\n"
   "    end\n"
   "\n"
   "    -- Reset the colors.\n"
   "    if piece.colors then\n"
   "      write_nolength (C.e, ctx)\n"
   "    end\n"
   "  end\n"
   "end\n"
   "\n"
   "\n"
   "function display_string (piece, ctx)\n"
   "  local ml = min_len (piece)\n"
   "\n"
   "  -- If it won't fit here, but it would fit on the next line, then write it on \n"
   "  -- the next line; otherwise, write it here.\n"
   "  if ml > space_here (ctx) and ml <= space_newline (ctx) then\n"
   "    newline (ctx)\n"
   "  end\n"
   "\n"
   "  write (piece, ctx)\n"
   "end\n"
   "\n"
   "\n"
   "-- The minimum length to display this piece, if it is placed all on one line.\n"
   "function min_len (piece, ctx)\n"
   "  -- For strings, simply return their length.\n"
   "  if type (piece) == 'string' then\n"
   "    return #piece\n"
   "  end\n"
   "\n"
   "  -- Otherwise, we have some calculations to do.\n"
   "  local result = 0\n"
   "\n"
   "  if piece.bracket then\n"
   "    -- This is a frame.\n"
   "\n"
   "    -- If it's an empty frame, just the open and close brackets.\n"
   "    if #piece == 0 then\n"
   "      return min_len (piece.bracket [BOPEN]) + min_len (piece.bracket [BCLOSE])\n"
   "    end\n"
   "\n"
   "    -- Open and close brackets, plus a space for each.\n"
   "    result = result + min_len (piece.bracket [BOPEN]) +\n"
   "      min_len (piece.bracket [BCLOSE]) + 2\n"
   "\n"
   "    -- A separator between each item, plus a space for each.\n"
   "    result = result + (#piece - 1) * (#piece.bracket[BSEP] + 1)\n"
   "  else\n"
   "    -- This is a sequence.\n"
   "\n"
   "    -- If it's an empty sequence, then nothing.\n"
   "    if #piece == 0 then\n"
   "      return 0\n"
   "    end\n"
   "\n"
   "    -- A single separator between each item.\n"
   "    result = result + (#piece - 1) * #(piece.sep or SEP)\n"
   "  end\n"
   "\n"
   "  -- For both frames and sequences:\n"
   "  -- Find the minimum length of each child.\n"
   "  for _, child in ipairs (piece) do\n"
   "    result = result + min_len (child, ctx)\n"
   "  end\n"
   "\n"
   "  return result\n"
   "end\n"
   "\n"
   "\n"
   "function newline (ctx)\n"
   "  ctx.result = ctx.result .. \"\\n\"\n"
   "  ctx.line_len = 0\n"
   "  write (ctx.next_indent, ctx)\n"
   "end\n"
   "\n"
   "\n"
   "function newline_no_indent (ctx)\n"
   "  ctx.result = ctx.result .. \"\\n\"\n"
   "  ctx.line_len = 0\n"
   "end\n"
   "\n"
   "\n"
   "function write (str, ctx)\n"
   "  ctx.result = ctx.result .. str\n"
   "  ctx.line_len = ctx.line_len + #str\n"
   "end\n"
   "\n"
   "\n"
   "function write_nolength (str, ctx)\n"
   "  ctx.result = ctx.result .. str\n"
   "end\n"
   "\n"
   "\n"
   "function space_here (ctx)\n"
   "  return math.max (0, ctx.max_width - ctx.line_len)\n"
   "end\n"
   "\n"
   "\n"
   "function space_newline (ctx)\n"
   "  return math.max (0, ctx.max_width - #ctx.next_indent)\n"
   "end\n"
   "\n"
   "\n"
   "--\n"
   "-- Main function\n"
   "--\n"
   "\n"
   "\n"
   "return function (val)\n"
   "  if val == nil then\n"
   "    print (nil)\n"
   "  else\n"
   "    local ctx = new_context ()\n"
   "    local piece = translate (val, ctx)\n"
   "    piece = clean (piece, ctx)\n"
   "    display (piece, ctx)\n"
   "    print (C.e .. ctx.result .. C.e)\n"
   "  end\n"
   "end\n"},

  {"parser", 
   "local mm = require \"mm\"\n"
   "local Rule = require \"rule\"\n"
   "local json = require \"dkjson\"\n"
   "\n"
   "local function parseRulesetThing(parser, data_in, opt)\n"
   "  local data = data_in[opt.key]\n"
   "  parser:pushContext(data, opt.key)\n"
   "  local ruleset = parser.ruleset\n"
   "  \n"
   "  if data then\n"
   "    parser:assert_type(data, opt.type, \"wrong type for ruleset %s, expected %s, got %s\", opt.key, opt.type, parser:jsontype(data))\n"
   "    local ret, err\n"
   "    for k,v in pairs(data) do\n"
   "      parser:assert_type(k, \"string\", \"wrong key type for %s, expected string, got %s %s\", opt.thing, parser:jsontype(k), tostring(k))\n"
   "      ret, err = opt.parser_method(parser, v, k)\n"
   "      parser:assert(ret, err)\n"
   "      parser:assert(ruleset[opt.key][ret.name] == nil, \"%s %s already exists\", opt.thing, ret.name)\n"
   "      ruleset[opt.key][ret.name]=ret\n"
   "    end\n"
   "  end\n"
   "  parser:popContext()\n"
   "  return true\n"
   "end\n"
   "\n"
   "local function inheritmetatable(dst, src)\n"
   "  if type(dst) == type(src) then\n"
   "    setmetatable(dst, getmetatable(src))\n"
   "  end\n"
   "end\n"
   "\n"
   "local getloc; do --location caching\n"
   "  local lc = setmetatable({}, {__mode=\"k\"}) -- weak keys\n"
   "  getloc = function(str, where)\n"
   "    local line, pos, linepos = 1, 1, 0\n"
   "    local prev = lc[str]\n"
   "    if prev and prev.pos < where then\n"
   "      line = prev.line\n"
   "      pos = prev.pos\n"
   "    end\n"
   "    while true do\n"
   "      pos = str:find(\"\\n\", pos, true)\n"
   "      if pos and pos < where then\n"
   "        line = line + 1\n"
   "        linepos = pos\n"
   "        pos = pos + 1\n"
   "      else\n"
   "        break\n"
   "      end\n"
   "    end\n"
   "    return line, (where - linepos) -- line, column\n"
   "  end\n"
   "end\n"
   "\n"
   "local function jsonmeta(what)\n"
   "  return function(str, where)\n"
   "    local line, column = getloc(str, where)\n"
   "    return {__pos=where,__line=line, __column=column,  __jsontype = what, __jsonmeta = true}\n"
   "  end\n"
   "end\n"
   "\n"
   "local Parser = {}\n"
   "\n"
   "function Parser:jsontype(var)\n"
   "  if type(var) == \"table\" then\n"
   "    local m = getmetatable(var)\n"
   "    return m and m.__jsontype or nil\n"
   "  else\n"
   "    return type(var)\n"
   "  end\n"
   "end\n"
   "function Parser:assert(cond, err, ...)\n"
   "  if not cond then self:error(err, ...) end\n"
   "  return cond\n"
   "end\n"
   "function Parser:assert_type(var, expected_type, err, ...)\n"
   "  if err then\n"
   "    return self:assert(type(var) == expected_type, err, ...)\n"
   "  else\n"
   "    return self:assert(type(var) == expected_type, \"expected type '%s', got '%s'\", expected_type, type(var))\n"
   "  end\n"
   "end\n"
   "function Parser:assert_jsontype(var, expected_type, err, ...)\n"
   "  if err then\n"
   "    return self:assert(self:jsontype(var) == expected_type, err, ...)\n"
   "  else\n"
   "    return self:assert(self:jsontype(var) == expected_type,\"expected JSON type '%s', got '%s'\", expected_type, self:jsontype(var))\n"
   "  end\n"
   "end\n"
   "function Parser:assert_table_size(var, expected_size, err, ...)\n"
   "  self:assert_type(var, \"table\")\n"
   "  local n = 0\n"
   "  for _, _ in pairs(var) do\n"
   "    n = n + 1\n"
   "  end\n"
   "  if n ~= expected_size then\n"
   "    if err then\n"
   "      self:error(err, ...)\n"
   "    else\n"
   "      self:error(\"wrong table size, expected %i, got %i\", expected_size, n)\n"
   "    end\n"
   "  end\n"
   "  return var\n"
   "end\n"
   "\n"
   "local function getlc(tbl)\n"
   "  local mt = getmetatable(tbl)\n"
   "  if mt.__line and mt.__column then\n"
   "    return mt.__line, mt.__column\n"
   "  end\n"
   "end\n"
   "\n"
   "local function getlc_str(tbl)\n"
   "  local line, col = getlc(tbl)\n"
   "  if line and col then\n"
   "    return (\"line %s column %i\"):format(line, col)\n"
   "  else\n"
   "    return nil\n"
   "  end\n"
   "end\n"
   "\n"
   "function Parser:error(err, ...)\n"
   "  \n"
   "  if not err then err = \"unknown error\" end\n"
   "  if select(\"#\", ...) > 0 then\n"
   "    err = err:format(...)\n"
   "  end\n"
   "  \n"
   "  local nested_names = {}\n"
   "  \n"
   "  for i=#self.ctx_stack,1,-1 do\n"
   "    local cur = self.ctx_stack[i]\n"
   "    if cur.name then table.insert(nested_names, cur.name) end\n"
   "    local lc_str = getlc_str(cur.ctx)\n"
   "    if lc_str then\n"
   "      if self.name then table.insert(nested_names, self.name) end\n"
   "      error((\"%s at %s: %s\"):format(table.concat(nested_names, \" in \"), lc_str, err))\n"
   "    end\n"
   "  end\n"
   "  if self.name then table.insert(nested_names, self.name) end\n"
   "  if #nested_names > 0 then\n"
   "    error((\"%s: %s\"):format(table.concat(nested_names, \" in \"), err))\n"
   "  else\n"
   "    error(err)\n"
   "  end\n"
   "end\n"
   "\n"
   "function Parser:setInterpolationChecker(func)\n"
   "  self.interpolation_checker = func\n"
   "end\n"
   "function Parser:checkInterpolatedString(str)\n"
   "  if self.interpolation_checker then\n"
   "    self.interpolation_checker(str, self)\n"
   "  end\n"
   "  return true\n"
   "end\n"
   "\n"
   "function Parser:pushContext(ctx, name)\n"
   "  table.insert(self.ctx_stack, {ctx=ctx, name=name})\n"
   "  self.context = self.ctx_stack[#self.ctx_stack]\n"
   "  return self\n"
   "end\n"
   "function Parser:popContext()\n"
   "  table.remove(self.ctx_stack, #self.ctx_stack)\n"
   "  self.context = self.ctx_stack[#self.ctx_stack]\n"
   "end\n"
   "function Parser:getContext(name)\n"
   "  if not name then return self.context and self.context.ctx end\n"
   "  for i=#self.ctx_stack, 1, -1 do\n"
   "    local cur = self.ctx_stack[i]\n"
   "    if cur.name==name then\n"
   "      return cur.ctx\n"
   "    end\n"
   "  end\n"
   "  return nil\n"
   "end\n"
   "function Parser:printContext()\n"
   "  for i=#self.ctx_stack, 1, -1 do\n"
   "    local cur = self.ctx_stack[i]\n"
   "    print(cur.name or \"<?>\", self:jsontype(cur.ctx) or \"<?>\", getlc_str(cur.ctx) or \"\")\n"
   "  end\n"
   "end\n"
   "\n"
   "function Parser:parseFile(path)\n"
   "  local file = assert(io.open(path, \"rb\")) -- r read mode and b binary mode\n"
   "  local content = file:read(\"*a\") -- *a or *all reads the whole file\n"
   "  file:close()\n"
   "  self.name = path\n"
   "  return self:parseJSON(content, \"file \" .. path)\n"
   "end\n"
   "\n"
   "function Parser:parseJSON(json_str, json_name)\n"
   "  self:assert_type(json_str, \"string\", \"expected a JSON string\")\n"
   "  local data, _, err = json.decode(json_str, 1, json.null, jsonmeta(\"object\"), jsonmeta(\"array\"))\n"
   "  self.name = json_name or self.context_name\n"
   "  self.source = json_str\n"
   "  if not data then\n"
   "    self:error(err)\n"
   "  end\n"
   "  return self:parseRuleSet(data)\n"
   "end\n"
   "\n"
   "function Parser:parseInterpolatedString(str)\n"
   "  --validate the string\n"
   "  for sub in str:gmatch(\"%$%b{}\") do\n"
   "    if not sub:match(\"^%${[%w_]+}\") then\n"
   "      self:error(\"invalid variable \\\"%s\\\" in interpolated string\", sub)\n"
   "    end\n"
   "  end\n"
   "  for sub in str:gmatch(\"%${?[%w_]*}?\") do\n"
   "    if sub:sub(2,2) == \"{\" then\n"
   "      if sub:sub(-1) ~=\"}\" then --unterminated bracket\n"
   "        mm(sub)\n"
   "        self:error(\"missing '}' in interpolated string\")\n"
   "      end\n"
   "      sub=sub:sub(3, -2)\n"
   "      if sub == \"\" then\n"
   "        self:error(\"invalid variable ${} in interpolated string\")\n"
   "      elseif sub:match(\"^%d%d+\") then\n"
   "        self:error(\"invalid regex capture \\\"%s\\\" in interpolated string. 1-9 only (nginx quirk)\", sub)\n"
   "      elseif sub:match(\"^%d.+\") then\n"
   "        self:error(\"invalid variable \\\"%s\\\" in interpolated string. can't sart with a number (nginx quirk)\", sub)\n"
   "      end\n"
   "    else\n"
   "      sub=sub:sub(2, -1)\n"
   "    end\n"
   "    if sub == \"\" then\n"
   "      self:error(\"invalid empty variable in interpolated string\")\n"
   "    end\n"
   "    \n"
   "  end\n"
   "  \n"
   "  return {string = str}\n"
   "end\n"
   "\n"
   "function Parser:parseRuleSet(data, name)\n"
   "  self.ruleset = {\n"
   "    limiters= {},\n"
   "    rules= {},\n"
   "    lists= {},\n"
   "    phases={},\n"
   "    name = name\n"
   "  }\n"
   "  self:pushContext(data, \"ruleset\")\n"
   "  \n"
   "  self:assert_type(data, \"table\", \"wrong type for ruleset\")\n"
   "  parseRulesetThing(self, data, {\n"
   "    thing=\"limiter\", key=\"limiters\", type=\"table\",\n"
   "    parser_method= self.parseLimiter\n"
   "  })\n"
   "  self:checkLimiters(data.limiters)\n"
   "  \n"
   "  --luacheck: push ignore 432 --don't mind the shadowing\n"
   "  parseRulesetThing(self, data, {\n"
   "    thing=\"rule\", key=\"rules\",  type=\"table\",\n"
   "    parser_method=function(self, data, name)\n"
   "      self:pushContext(data, \"rule\")\n"
   "      self:assert(type(data) ~= \"string\", (\"named rule \\\"%s\\\" cannot be a string referring to another named rule \\\"%s\\\"\"):format(name, tostring(data)))\n"
   "      self:popContext()\n"
   "      return self:parseRule(data, name)\n"
   "    end\n"
   "  })\n"
   "  --luacheck: pop\n"
   "  \n"
   "  parseRulesetThing(self, data, {\n"
   "    thing=\"list\", key=\"lists\",  type=\"table\",\n"
   "    parser_method= self.parseRuleList\n"
   "  })\n"
   "  \n"
   "  self.ruleset.phases = self:parsePhaseTable(data.phases)\n"
   "  --convert debug metatable data to __dbg table whenever possible\n"
   "  local function move_dbg_data(tbl)\n"
   "    local meta = getmetatable(tbl)\n"
   "    if meta and meta.__jsonmeta then\n"
   "      if not meta.__line then\n"
   "        mm(tbl)\n"
   "      end\n"
   "      setmetatable(tbl, {line=meta.__line, col=meta.__column})\n"
   "    end\n"
   "    for _, v in pairs(tbl) do\n"
   "      if type(v) == \"table\" then\n"
   "        move_dbg_data(v)\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "  move_dbg_data(self.ruleset)\n"
   "  \n"
   "  return self.ruleset\n"
   "end\n"
   "\n"
   "function Parser:parsePhaseTable(data)\n"
   "  self:assert(data ~= nil, \"missing phase table (\\\"phases\\\" attribute)\")\n"
   "  self:assert_jsontype(data, \"object\", \"phase table must be an object\")\n"
   "  self:pushContext(data, \"phase table\")\n"
   "  \n"
   "  for phase_name, phase_data in pairs(data) do\n"
   "    self:assert_type(phase_name, \"string\", \"phase table entries must be strings\")\n"
   "    if self:jsontype(phase_data) == \"array\" then\n"
   "      for i, list in ipairs(phase_data) do\n"
   "        if type(list)==\"string\" or self:jsontype(list) == \"array\" or self:jsontype(list) == \"object\" then\n"
   "          phase_data[i]=self:parseRuleList(list)\n"
   "        else\n"
   "          self:error(\"invalid rule list type: %s\", self:jsontype(list))\n"
   "        end\n"
   "      end\n"
   "    elseif type(phase_data) == \"string\" then\n"
   "      --singe named list\n"
   "      data[phase_name]={ self:parseRuleList(phase_data) }\n"
   "    elseif self:jsontype(phase_data)==\"object\" then\n"
   "      --single long-form list\n"
   "      data[phase_name]=self:parseRuleList(phase_data)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  self:popContext()\n"
   "  \n"
   "  return data\n"
   "end\n"
   "\n"
   "function Parser:parseRuleList(data, name)\n"
   "  if type(data)==\"string\" then\n"
   "    self:assert(self.ruleset.lists[data], ([[named list \"%s\" not found]]):format(data))\n"
   "    return self.ruleset.lists[data]\n"
   "  end\n"
   "  self:pushContext(data, \"list\")\n"
   "  local list\n"
   "  if self:jsontype(data) == \"object\" then\n"
   "    if name then\n"
   "      self:assert(name == data.name, \"rule list 'name' attribute must match outside list name\")\n"
   "    else\n"
   "      name = tostring(data.name)\n"
   "    end\n"
   "    data = data.rules\n"
   "  end\n"
   "  self:assert_jsontype(data, \"array\", \"rule list must be an array\")\n"
   "  local rules = {}\n"
   "  for _,v in ipairs(data) do\n"
   "    table.insert(rules, self:parseRule(v))\n"
   "  end\n"
   "  self:popContext()\n"
   "  list = {name=name, rules=rules}\n"
   "  inheritmetatable(list, data)\n"
   "  return list\n"
   "end\n"
   "\n"
   "function Parser:parseRule(data, name)\n"
   "  self:pushContext(data, \"rule\")\n"
   "  local rule\n"
   "  if type(data) == \"string\" then\n"
   "    rule = self.ruleset.rules[data]\n"
   "    self:assert(rule, ([[named rule \"%s\" not found]]):format(data))\n"
   "    self:popContext()\n"
   "    return rule\n"
   "  end\n"
   "  self:assert_type(data, \"table\", \"invalid rule data type: \" .. type(data))\n"
   "  self:assert_jsontype(data, \"object\", (\"invalid rule data type: %s\"):format(self:jsontype(data)))\n"
   "  \n"
   "  if ((data[\"if\"] or data[\"if-any\"] or data[\"if-all\"]) or data[\"then\"]) then\n"
   "    self:assert(not data[\"always\"], [[\"always\" clause can't be present in if/then rule]])\n"
   "    self:assert(not data[\"switch\"], [[\"switch\" clause can't be present in if/then rule]])\n"
   "  end\n"
   "  \n"
   "  if data[\"then\"] then\n"
   "    if (data[\"if\"] and (data[\"if-any\"] or data[\"if-all\"])) or (data[\"if-any\"] and data[\"if-all\"]) then\n"
   "      self:error(\"only one of \\\"if\\\", \\\"if-any\\\" or \\\"if-all\\\" allowed in if/then rule\")\n"
   "    end\n"
   "    \n"
   "    local condition\n"
   "    if data[\"if\"] then\n"
   "      condition = self:parseCondition(data[\"if\"])\n"
   "    elseif data[\"if-any\"] or data[\"if-all\"] then\n"
   "      local conditions = {}\n"
   "      for _, v in ipairs(data[\"if-any\"] or data[\"if-all\"]) do\n"
   "        condition = self:assert(self:parseCondition(v))\n"
   "        table.insert(conditions, condition)\n"
   "      end\n"
   "      condition = {[(data[\"if-any\"] and \"any\" or \"all\")]=conditions}\n"
   "      inheritmetatable(condition, data[\"if\"] or data[\"if-any\"] or data[\"if-all\"])\n"
   "    end\n"
   "    rule = {[\"if\"]=condition, [\"then\"]=data[\"then\"], [\"else\"]=data[\"else\"], name=data[\"name\"] or name, info=data[\"info\"], key=data[\"key\"]}\n"
   "  elseif data[\"always\"] then\n"
   "    rule = {[\"if\"]={[\"true\"]={}}, [\"then\"]=data[\"always\"], name=data[\"name\"] or name, info=data[\"info\"], key=data[\"key\"]}\n"
   "  elseif next(data) == nil then\n"
   "    self:error(\"empty rule not allowed\")\n"
   "  else\n"
   "    self:error(\"rule must have at least an \\\"if\\\", \\\"then\\\", or \\\"always\\\" attribute\")\n"
   "  end\n"
   "  if rule[\"if\"] then\n"
   "    rule[\"then\"] = self:parseActions(rule[\"then\"], \"then\")\n"
   "    rule[\"else\"] = self:parseActions(rule[\"else\"], \"else\")\n"
   "  end\n"
   "  if rule.key then\n"
   "    rule.key = self:parseInterpolatedString(rule.key)\n"
   "  end\n"
   "  \n"
   "  self:popContext()\n"
   "  --reuse metatable for debugging purposes\n"
   "  inheritmetatable(rule, data)\n"
   "  return rule\n"
   "end\n"
   "\n"
   "function Parser:parseCondition(data)\n"
   "  self:pushContext(data, \"condition\")\n"
   "  local condition\n"
   "  if type(data) == \"string\" then\n"
   "    condition = {[data]={}}\n"
   "  elseif type(data) == \"table\" then\n"
   "    self:assert_jsontype(data, \"object\", \"condition cannot be an array, must be an object\")\n"
   "    self:assert_table_size(data, 1, \"condition object must have exactly one attribute (the condition name)\")\n"
   "    condition = data\n"
   "  else\n"
   "    self:error(\"wrong type (%s) for condition\", type(data))\n"
   "  end\n"
   "  self:popContext()\n"
   "  -- be more specific with condition name\n"
   "  self:pushContext(data, \"condition \" .. (next(condition)))\n"
   "  condition = Rule.condition.parse(condition, self)\n"
   "  self:popContext()\n"
   "  inheritmetatable(condition, data)\n"
   "  return condition\n"
   "end\n"
   "  \n"
   "function Parser:parseAction(data)\n"
   "  self:pushContext(data, \"action\")\n"
   "  local action\n"
   "  if type(data) == \"string\" then\n"
   "    action = {[data]={}}\n"
   "  elseif self:jsontype(data) == \"object\" then\n"
   "    self:assert(next(data, next(data)) == nil, \"action object must have only 1 attribute -- the action name\")\n"
   "    action = data\n"
   "  else\n"
   "    self:error(\"action must be string on 1-attribute object, but instead was a %s\", self:jsontype(data))\n"
   "  end\n"
   "  self:popContext()\n"
   "  --we can be more specific about the action name now\n"
   "  self:pushContext(data, (\"\\\"%s\\\" action\"):format(next(action)))\n"
   "  inheritmetatable(action, data)\n"
   "  action = Rule.action.parse(action, self)\n"
   "  self:popContext()\n"
   "  return action\n"
   "end\n"
   "\n"
   "function Parser:parseActions(data, name)\n"
   "  if data == nil then\n"
   "    return {}\n"
   "  end\n"
   "  self:pushContext(data, name and (\"\\\"%s\\\" actions\"):format(name) or nil)\n"
   "  local actions = {}\n"
   "  inheritmetatable(actions, data)\n"
   "  if self:jsontype(data) == \"object\" or type(data)==\"string\" or (#data == 0 and next(data) ~= nil) then\n"
   "    table.insert(actions, self:parseAction(data))\n"
   "  elseif type(data) == \"table\" then\n"
   "    for _, v in ipairs(data) do\n"
   "      table.insert(actions, self:parseAction(v))\n"
   "    end\n"
   "  end\n"
   "  self:popContext()\n"
   "  return actions\n"
   "end\n"
   "\n"
   "function Parser:parseTimeInterval(data, err)\n"
   "  if err then err = \" for \" .. err end\n"
   "  local typ = self:jsontype(data)\n"
   "  if typ == \"number\" then\n"
   "    return data\n"
   "  elseif typ == \"string\" then\n"
   "    local num, unit = data:match(\"^([%d.]+)([%w_]*)\")\n"
   "    local scale\n"
   "    num = tonumber(num)\n"
   "    self:assert(num and unit, (\"invalid time string \\\"%s\\\"%s\"):format(data, err))\n"
   "    if unit == \"ms\" or unit:match(\"^millisec(ond(s?))?\") then\n"
   "      scale = .01\n"
   "    elseif unit == \"\" or unit == \"s\" or unit:match(\"^sec(ond(s?))?\") then\n"
   "      scale = 1\n"
   "    elseif unit == \"m\" or unit:match(\"^min(ute(s)?)?\") then\n"
   "      scale = 60\n"
   "    elseif unit == \"h\" or unit:match(\"^hour(s?)\") then\n"
   "      scale = 3600\n"
   "    elseif unit == \"d\" or unit:match(\"^day(s)?\") then\n"
   "      scale = 86400\n"
   "    elseif unit == \"w\" or unit == \"wk\" or unit:match(\"^week(s)?\") then\n"
   "      scale = 604800\n"
   "    elseif unit == \"M\" or unit:match(\"^month(s)?\") then\n"
   "      scale = 2628001\n"
   "    else\n"
   "      self:error(\"unknown time unit \\\"%s\\\"%s\", unit, err)\n"
   "    end\n"
   "    return num * scale\n"
   "  else\n"
   "    self:error(\"invalid time inteval type \\\"%s\\\"%s\", self:jsontype(data), err)\n"
   "  end\n"
   "end\n"
   "\n"
   "function Parser:parseLimiter(data, name)\n"
   "  self:pushContext(data, \"limiter\")\n"
   "  \n"
   "  if not data.name then data.name = name end\n"
   "  data.interval = self:parseTimeInterval(data.interval, \"interval value\")\n"
   "  self:assert(data.interval >= 60, \"\\\"interval\\\" value must be >= 60 seconds\")\n"
   "  self:assert(data.limit, \"missing \\\"limit\\\" value\")\n"
   "  data.limit = self:assert(tonumber(data.limit), \"invalid \\\"limit\\\" value, must be a number\")\n"
   "  self:assert(data.limit >= 0, \"\\\"limit\\\" value must be >= 0\")\n"
   "  \n"
   "  if data.sync_steps then\n"
   "    data.sync_steps = self:assert(tonumber(data.sync_steps), \"invalid \\\"sync-steps\\\" value\")\n"
   "  end\n"
   "  if data.burst then\n"
   "    self:assert_type(data.burst, \"string\", \"invalid \\\"burst\\\" value type\")\n"
   "  end\n"
   "  if data[\"burst-expire\"] then\n"
   "    data.burst_expire = self:parseTimeInterval(data[\"burst-expire\"], \"burst_expire value\")\n"
   "    data[\"burst-expire\"] = nil\n"
   "  end\n"
   "  \n"
   "  self:assert_type(data.name, \"string\", \"invalid limiter name\")\n"
   "  self:popContext()\n"
   "  return data\n"
   "end\n"
   "function Parser:checkLimiters(data)\n"
   "  if not data then return true end\n"
   "  self:pushContext(data, \"limiters\")\n"
   "  for _, v in pairs(data) do\n"
   "    self:pushContext(v, (\"limiter \\\"%s\\\"\"):format(v.name))\n"
   "    if v.burst then\n"
   "      --make sure the burst value refers to a known limiter\n"
   "      self:assert(data[v.burst], (\"limiter references unknown burst limiter \\\"%s\\\"\"):format(v.burst))\n"
   "    end\n"
   "    self:popContext()\n"
   "  end\n"
   "  self:popContext()\n"
   "end\n"
   "\n"
   "local Parser_meta = {__index = Parser}\n"
   "\n"
   "local function newparser()\n"
   "  local parser = {\n"
   "    name = \"<?>\",\n"
   "    ctx_stack = {}\n"
   "  }\n"
   "  \n"
   "  setmetatable(parser, Parser_meta)\n"
   "  return parser\n"
   "end\n"
   "\n"
   "return {new = newparser}\n"},

  {"redis", 
   "local module = {c={}}\n"
   "local mm = require \"mm\"\n"
   "\n"
   "--luacheck: globals newRedis\n"
   "\n"
   "local Redis = {}\n"
   "local rmeta = {__index = Redis}\n"
   "local script = {}\n"
   "local script_hash = {}\n"
   "\n"
   "function Redis:connect()\n"
   "  mm(self)\n"
   "  assert(self.status == \"disconnected\", \"should only try to connect when disconnected\")\n"
   "  \n"
   "  local function connector()\n"
   "    local ret, err = module.c.redis_connect(self.connection_params.host, self.connection_params.port)\n"
   "    if not ret then\n"
   "      print(\"OH NO THAT DIDN'T WORK: \" .. tostring(err))\n"
   "      --TODO: errorstuff\n"
   "      return self:reconnect(10)\n"
   "    end\n"
   "    assert(type(ret) == \"userdata\")\n"
   "    self.ctx = ret\n"
   "    \n"
   "    self.connection_params.peername = module.c.get_hiredis_asyncContext_peername(self.ctx)\n"
   "    ret, err = module.c.redis_connect(self.connection_params.peername, self.connection_params.port)\n"
   "    if not ret then\n"
   "      print(\"OH NO THAT DIDN'T WORK: \" .. tostring(err))\n"
   "      --TODO: errorstuff\n"
   "      return self:reconnect(10)\n"
   "    end\n"
   "    assert(type(ret) == \"userdata\")\n"
   "    self.sub_ctx = ret\n"
   "\n"
   "    if self.connection_params.pass then\n"
   "      self:ignore_next_status_check()\n"
   "      ret, err = self:command(\"AUTH\", self.connection_params.pass)\n"
   "      if not ret then\n"
   "        --TODO: error, wrong password\n"
   "        print(\"OH NO THAT DIDN'T WORK: \" .. tostring(err))\n"
   "        return self:reconnect(10)\n"
   "      end\n"
   "      \n"
   "      self:ignore_next_status_check()\n"
   "      ret, err = self:sub_command(\"AUTH\", self.connection_params.pass)\n"
   "      if not ret then\n"
   "        --TODO: error, wrong password\n"
   "        print(\"OH NO THAT DIDN'T WORK: \" .. tostring(err))\n"
   "        return self:reconnect(10)\n"
   "      end\n"
   "    end\n"
   "    \n"
   "    if self.connection_params.db then\n"
   "      self:ignore_next_status_check()\n"
   "      ret, err = self:command(\"SELECT\", self.connection_params.db)\n"
   "      if not ret then\n"
   "        --TODO: error, wrong password\n"
   "        print(\"OH NO THAT DIDN'T WORK: \" .. tostring(err))\n"
   "        return self:reconnect(10)\n"
   "      end\n"
   "      \n"
   "      self:ignore_next_status_check()\n"
   "      ret, err = self:sub_command(\"SELECT\", self.connection_params.db)\n"
   "      if not ret then\n"
   "        --TODO: error, wrong password\n"
   "        print(\"OH NO THAT DIDN'T WORK: \" .. tostring(err))\n"
   "        return self:reconnect(10)\n"
   "      end\n"
   "    end\n"
   "    \n"
   "    return self\n"
   "  end\n"
   "  \n"
   "  if coroutine.running() then\n"
   "    --use current coroutine\n"
   "    return connector()\n"
   "  else\n"
   "    --new coroutine plz\n"
   "    return (coroutine.wrap(connector))()\n"
   "  end\n"
   "end\n"
   "\n"
   "local function subscribe_handler(data)\n"
   "  print(\"GOT SUBSCRIBE THINGY\")\n"
   "  mm(data)\n"
   "end\n"
   "\n"
   "function Redis:subscribe(channel, callback)\n"
   "  assert(self.pubsub_handlers[channel] == nil, (\"already subscribed to \\\"%s\\\"\"):format(channel))\n"
   "  assert(type(callback) == \"function\")\n"
   "  assert(type(channel) == \"string\")\n"
   "  self.pubsub_handlers[channel]=callback\n"
   "  self:sub_command(subscribe_handler, \"SUBSCRIBE\", channel)\n"
   "end\n"
   "\n"
   "function Redis:unsubscribe(channel)\n"
   "  self.pubsub_handlers[channel]=nil\n"
   "end\n"
   "\n"
   "function Redis:script(name, keys, ...)\n"
   "  return self:command(\"evalsha\", #keys, table.unpack(keys), ...)\n"
   "end\n"
   "\n"
   "local function infer_command_callback_and_args(first, ...)\n"
   "  if type(first) == \"function\" then\n"
   "    return first, ...\n"
   "  else\n"
   "    local co = coroutine.running()\n"
   "    assert(co, \"no callback given to redis command, expected to be run in coroutine\")\n"
   "    local coroutine_resumer = function(...)\n"
   "      coroutine.resume(co, ...)\n"
   "    end\n"
   "    return coroutine_resumer, first, ...\n"
   "  end\n"
   "end\n"
   "\n"
   "local function redis_command(self, ctx_name, ...)\n"
   "  if not self:check_status_ready() then\n"
   "    table.insert(self.pending_commands[ctx_name], {infer_command_callback_and_args(...)})\n"
   "    return true\n"
   "  else\n"
   "    return module.c.redis_command(self[ctx_name], infer_command_callback_and_args(...))\n"
   "  end\n"
   "end\n"
   "\n"
   "function Redis:check_status_ready()\n"
   "  if self.ignore_check_status > 0 then\n"
   "    self.ignore_check_status = self.ignore_check_status - 1\n"
   "    return true\n"
   "  else\n"
   "    return self.status == \"ready\"\n"
   "  end\n"
   "end\n"
   "\n"
   "function Redis:ignore_next_status_check()\n"
   "  self.ignore_check_status = self.ignore_check_status + 1\n"
   "end\n"
   "\n"
   "function Redis:command(...)\n"
   "  return redis_command(self, \"ctx\", ...)\n"
   "end\n"
   "function Redis:sub_command(...)\n"
   "  return redis_command(self, \"sub_ctx\", ...)\n"
   "end\n"
   "\n"
   "function Redis:script(name, first, ...)\n"
   "  local myhash = script_hash[name]\n"
   "  assert(myhash, (\"unknown Redis lua script \\\"%s\\\"\"):format(name))\n"
   "  if type(first) == \"table\" then\n"
   "    return self:command(\"EVALSHA\", myhash, #first, table.unpack(first), ...)\n"
   "  else\n"
   "    return self:command(\"EVALSHA\", myhash, 0, first, ...)\n"
   "  end\n"
   "end\n"
   "\n"
   "function newRedis(host, port, pass, db)\n"
   "  local r = setmetatable({}, rmeta)\n"
   "  r.connection_params = {\n"
   "    host=host, port=port, pass=pass, db=db\n"
   "  }\n"
   "  \n"
   "  r.pubsub_handlers = {}\n"
   "  r.subscribed = false\n"
   "  \n"
   "  r.ignore_check_status = 0\n"
   "  r.status = \"disconnected\"\n"
   "  r.pending_commands={ctx={}, sub_ctx={}}\n"
   "  \n"
   "  return r\n"
   "end\n"
   "\n"
   "module.new = newRedis\n"
   "\n"
   "function module.addScript(name, hash, src)\n"
   "  assert(script[name] == nil, (\"redis lua script \\\"%s\\\" already exists\"):format(name))\n"
   "  script_hash[name]=hash\n"
   "  script[name]=src\n"
   "end\n"
   "\n"
   "for _,v in pairs {\"redis_connect\", \"redis_close\", \"redis_command\", \"loadscripts\", \"timeout\"} do\n"
   "  module.c[v]=function()\n"
   "    error(\"c binding \" .. v .. \" not set\")\n"
   "  end\n"
   "end\n"
   "\n"
   "return module\n"},

  {"rule", 
   "local Binding = require \"binding\"\n"
   "--local mm = require \"mm\"\n"
   "\n"
   "local function ignore_leading_hash(str)\n"
   "  return str:sub(1,1)==\"#\" and str:sub(2) or str\n"
   "end\n"
   "\n"
   "local thingstorage_meta = {__index = function(self, key)\n"
   "  local unhashed = ignore_leading_hash(key)\n"
   "  if unhashed ~= key then\n"
   "    return self[ignore_leading_hash(key)]\n"
   "  end\n"
   "end}\n"
   "\n"
   "local function create_thing_storage(thing_name)\n"
   "  local self = {table = setmetatable({}, thingstorage_meta)}\n"
   "  \n"
   "  local function unpack_thing(data, parser)\n"
   "    local name, val = next(data)\n"
   "    if type(name) == \"number\" then\n"
   "      parser:error(\"invalid data value, expected {\\\"key\\\":value}, got {\\\"key\\\"}\")\n"
   "    elseif type(name) ~= \"string\" then\n"
   "      parser:error(\"unexpected data type %s\", type(name))\n"
   "    end\n"
   "    local thing = self.table[name]\n"
   "    if parser then\n"
   "      parser:assert(thing, (\"Unknown %s \\\"%s\\\"\"):format(thing_name, name))\n"
   "    else\n"
   "      assert(thing, (\"Unknown %s \\\"%s\\\"\"):format(thing_name, name))\n"
   "    end\n"
   "    return name, val\n"
   "  end\n"
   "  \n"
   "  function self.add(name, funcs, meta)\n"
   "    if type(name) == \"table\" then\n"
   "      for _,v in pairs(name) do\n"
   "        self.add(v, funcs, meta)\n"
   "      end\n"
   "      return true\n"
   "    end\n"
   "    assert(funcs.parse, (\"%s missing parse callback\"):format(thing_name))\n"
   "    assert(self.table[name] == nil, (\"%s %s already exists\"):format(thing_name, name))\n"
   "    local added = {\n"
   "      parse=funcs.parse,\n"
   "      init=funcs.init,\n"
   "      delete=funcs.delete\n"
   "    }\n"
   "    if meta then\n"
   "      added.meta=meta\n"
   "    end\n"
   "    self.table[name]=added\n"
   "    \n"
   "    return true\n"
   "  end\n"
   "  \n"
   "  function self.parse(data, parser)\n"
   "    local name, val = unpack_thing(data, parser)\n"
   "    val = self.table[name].parse(val, parser) or val\n"
   "    return {[name]=val}\n"
   "  end\n"
   "  \n"
   "  function self.new(data, ruleset)\n"
   "    local name, val = unpack_thing(data)\n"
   "    name = ignore_leading_hash(name)\n"
   "    local thing_preset = self.table[name]\n"
   "    local thing = setmetatable({[thing_name]=name, data=val}, thing_preset.meta)\n"
   "    if thing_preset.init then\n"
   "      local replacement_data = thing_preset.init(val, thing, ruleset)\n"
   "      if replacement_data then\n"
   "        thing.data = replacement_data\n"
   "      end\n"
   "    end\n"
   "    Binding.call((\"%s:%s\"):format(thing_name, name), \"create\", thing)\n"
   "    return thing\n"
   "  end\n"
   "  \n"
   "  function self.delete(thing, ruleset)\n"
   "    local name = thing[thing_name] or thing.name\n"
   "    local thing_preset = self.table[name]\n"
   "    print(thing_name .. \" DELETE THING \" .. name .. \" \" .. tostring(thing_preset.delete))\n"
   "    if thing_preset.delete then\n"
   "      thing_preset.delete(thing.data, ruleset)\n"
   "    end\n"
   "    Binding.call((\"%s:%s\"):format(thing_name, name), \"delete\", thing)\n"
   "  end\n"
   "  \n"
   "  return self\n"
   "end\n"
   "\n"
   "local Rule = {\n"
   "  condition = create_thing_storage(\"condition\"),\n"
   "  action = create_thing_storage(\"action\")\n"
   "}\n"
   "\n"
   "--now let's add some basic conditions and actions\n"
   "Rule.condition.add(\"any\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"array\", \"\\\"any\\\" condition value must be an array of conditions\")\n"
   "    for i, v in ipairs(data) do\n"
   "      local condition = parser:parseCondition(v)\n"
   "      data[i]=condition\n"
   "    end\n"
   "  end,\n"
   "  init = function(data, thing, ruleset)\n"
   "    for i, v in ipairs(data) do\n"
   "      data[i] = Rule.condition.new(v, ruleset)\n"
   "    end\n"
   "  end,\n"
   "  delete = function(data, ruleset)\n"
   "    for _, cond in ipairs(data) do\n"
   "      Rule.condition.delete(cond, ruleset)\n"
   "    end\n"
   "  end\n"
   "}, {__jsonval = function(self)\n"
   "  return {any=self.data}\n"
   "end})\n"
   "\n"
   "Rule.condition.add(\"all\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"array\", \"\\\"all\\\" condition value must be an array of conditions\")\n"
   "    for i, v in ipairs(data) do\n"
   "      local condition = parser:parseCondition(v)\n"
   "      data[i]=condition\n"
   "    end\n"
   "  end,\n"
   "  init = function(data, ruleset)\n"
   "    for i, v in ipairs(data) do\n"
   "      data[i] = Rule.condition.new(v, ruleset)\n"
   "    end\n"
   "  end,\n"
   "  delete = function(data, ruleset)\n"
   "    for _, cond in ipairs(data) do\n"
   "      Rule.condition.delete(cond, ruleset)\n"
   "    end\n"
   "  end\n"
   "}, {__jsonval = function(self)\n"
   "  return {all=self.data}\n"
   "end})\n"
   "\n"
   "Rule.condition.add({\"true\", \"false\"}, {parse = function(data, parser)\n"
   "  --parser:assert(next(data) == nil, \"\\\"true\\\" condition must have empty parameters\")\n"
   "end}, {__jsonval=function(self) return self.condition end})\n"
   "\n"
   "Rule.condition.add(\"tag-check\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_type(data, \"string\", \"\\\"tag-check\\\" value must be a string\")\n"
   "    return parser:parseInterpolatedString(data)\n"
   "  end,\n"
   "  init = function(data)\n"
   "    Binding.call(\"string\", \"create\", data)\n"
   "  end,\n"
   "  delete = function(data)\n"
   "    Binding.call(\"string\", \"delete\", data)\n"
   "  end\n"
   "},{__jsonval=function(self)\n"
   "    return {[\"tag-check\"]=self.data.string}\n"
   "  end\n"
   "})\n"
   "\n"
   "Rule.condition.add(\"match\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"array\", \"\\\"match\\\" value must be an array of strings\")\n"
   "    for i, v in ipairs(data) do\n"
   "      parser:assert_jsontype(v, \"string\", \"\\\"match\\\" value must be an array of strings\")\n"
   "      data[i]=parser:parseInterpolatedString(v)\n"
   "    end\n"
   "  end,\n"
   "  init = function(data)\n"
   "    local complexity = function(str)\n"
   "      local n = 0\n"
   "      for _ in str.string:gmatch(\"%$\") do\n"
   "        n=n+1\n"
   "      end\n"
   "      return n\n"
   "    end\n"
   "    local simplefirst = function(str1, str2)\n"
   "      return complexity(str1) < complexity(str2)\n"
   "    end\n"
   "    table.sort(data, simplefirst)\n"
   "    for _, str in ipairs(data) do\n"
   "      Binding.call(\"string\", \"create\", str)\n"
   "    end\n"
   "  end,\n"
   "  delete = function(data)\n"
   "    for _, str in ipairs(data) do\n"
   "      Binding.call(\"string\", \"delete\", str)\n"
   "    end\n"
   "  end\n"
   "}, {\n"
   "  __jsonval=function(self)\n"
   "    local strings = {}\n"
   "    for _, str in ipairs(self.data) do\n"
   "      table.insert(strings, str.string)\n"
   "    end\n"
   "    return {match=strings}\n"
   "  end\n"
   "})\n"
   "\n"
   "local limit_thing_meta = {__jsonorder={\"name\", \"key\", \"increment\"}}\n"
   "\n"
   "--limiter conditions\n"
   "Rule.condition.add({\"limit-break\", \"limit-check\"}, {\n"
   "  parse = function(data, parser)\n"
   "    if type(data) == \"string\" then\n"
   "      data = {name=data}\n"
   "    elseif type(data) ~= \"table\" then\n"
   "      parser:error(\"invalid value type %s\", type(data))\n"
   "    end\n"
   "    local condition_name = next(parser:getContext())\n"
   "    local rule = parser:getContext(\"rule\")\n"
   "    \n"
   "    if not data.key then\n"
   "      data.key = rule.key\n"
   "    end\n"
   "    parser:assert(data.key, \"limiter \\\"key\\\" missing, and no default \\\"key\\\" in rule\")\n"
   "    parser:assert_type(data.key, \"string\", \"invalid limiter \\\"key\\\" type\")\n"
   "    \n"
   "    data.key = parser:parseInterpolatedString(data.key)\n"
   "    \n"
   "    if not data.increment then\n"
   "      if condition_name == \"limit-break\" then\n"
   "        data.increment = 1\n"
   "      elseif condition_name == \"limit-check\" then\n"
   "        data.increment = 0\n"
   "      end\n"
   "    end\n"
   "    data.increment = parser:assert(tonumber(data.increment), \"invalid or empty \\\"increment\\\" value\")\n"
   "    parser:assert(data.increment >= 0, \"\\\"increment\\\" must be >= 0\")\n"
   "    \n"
   "    parser:assert(data.name, \"name missing\")\n"
   "    parser:assert_type(data.name, \"string\", \"invalid \\\"name\\\" type\")\n"
   "    return data\n"
   "  end,\n"
   "  init = function(data, thing, ruleset)\n"
   "    local limiter = assert(ruleset:findLimiter(data.name), \"unknown limiter\")\n"
   "    data.name = nil\n"
   "    data.limiter = limiter\n"
   "    if data.key then\n"
   "      Binding.call(\"string\", \"create\", data.key)\n"
   "    end\n"
   "  end,\n"
   "  delete = function(data)\n"
   "    if data.key then\n"
   "      Binding.call(\"string\", \"delete\", data.key)\n"
   "    end\n"
   "  end\n"
   "}, {__jsonval=function(self)\n"
   "  local cpy = {}\n"
   "  for k,v in pairs(self.data) do\n"
   "    cpy[k]=v\n"
   "  end\n"
   "  if cpy.derived_key then\n"
   "    cpy.derived_key = nil\n"
   "    cpy.key = nil\n"
   "  elseif cpy.key then\n"
   "    cpy.key = cpy.key.string\n"
   "  end\n"
   "  cpy.name = cpy.limiter.name\n"
   "  cpy.limiter = nil\n"
   "  setmetatable(cpy, limit_thing_meta)\n"
   "  local ret = {[self.condition]=cpy}\n"
   "  return ret\n"
   "end})\n"
   "\n"
   "Rule.condition.add(\".delay\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"number\", \"delay by <number> please\")\n"
   "  end\n"
   "})\n"
   "\n"
   "--some actions, too\n"
   "Rule.action.add(\"tag\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"string\", \"\\\"tag\\\" value must be a string\")\n"
   "    return parser:parseInterpolatedString(data)\n"
   "  end,\n"
   "  init = function(data)\n"
   "    Binding.call(\"string\", \"create\", data)\n"
   "  end,\n"
   "  delete = function(data)\n"
   "    Binding.call(\"string\", \"delete\", data)\n"
   "  end\n"
   "}, {__jsonval = function(self)\n"
   "  return {tag=self.data.string}\n"
   "end})\n"
   "\n"
   "Rule.action.add(\"accept\", {parse = function(data, parser)\n"
   "  parser:assert_type(data, \"table\", \"\\\"accept\\\" value must be an object\")\n"
   "  parser:assert_table_size(data, 0, \"\\\"accept\\\" value must be empty\")\n"
   "end})\n"
   "Rule.action.add(\"reject\", {parse = function(data, parser)\n"
   "  parser:assert_type(data, \"table\", \"\\\"reject\\\" value must be an object\")\n"
   "  --parser:assert_table_size(data, 0, \"\\\"reject\\\" value must be empty\")\n"
   "end})\n"
   "\n"
   "Rule.action.add(\"wait\", {\n"
   "  parse = function(data, parser)\n"
   "    parser:assert_jsontype(data, \"number\", \"\\\"wait\\\" value must be a number\")\n"
   "  end\n"
   "})\n"
   "\n"
   "return Rule\n"},

  {"ruleset", 
   "local Rule = require \"rule\"\n"
   "local Binding = require \"binding\"\n"
   "local json = require \"dkjson\"\n"
   "\n"
   "local tcopy = function(tbl)\n"
   "  local cpy = {}\n"
   "  for k,v in pairs(tbl) do\n"
   "    cpy[k]=v\n"
   "  end\n"
   "  return setmetatable(cpy, getmetatable(tbl))\n"
   "end\n"
   "\n"
   "local function assert_unique_name(what, tbl, data)\n"
   "  assert(data.name, (\"a %s must have a name\"):format(what))\n"
   "  assert(not tbl[data.name], (\"%s \\\"%s\\\" already exists\"):format(what, data.name))\n"
   "end\n"
   "\n"
   "local function thing_name(thing)\n"
   "  if type(thing)==\"string\" then\n"
   "    return thing\n"
   "  elseif type(thing) == \"table\" then\n"
   "    return thing.name\n"
   "  else\n"
   "    return thing\n"
   "  end\n"
   "end\n"
   "\n"
   "local function table_copy(tbl, exclude_keys)\n"
   "  local cpy = {}\n"
   "  setmetatable(cpy, getmetatable(tbl))\n"
   "  for k,v in pairs(tbl) do\n"
   "    if not exclude_keys[k] then\n"
   "      cpy[k]=v\n"
   "    end\n"
   "  end\n"
   "  return cpy\n"
   "end\n"
   "\n"
   "local ruleset_meta = { __index = {\n"
   "  type=\"ruleset\",\n"
   "  \n"
   "  findLimiter = function(self, name)\n"
   "    return self.limiters[thing_name(name)]\n"
   "  end,\n"
   "  \n"
   "  addLimiter = function(self, data, limiters_in)\n"
   "    if data.__already_loaded_as_burst_limiter then\n"
   "      data.__already_loaded_as_burst_limiter = nil\n"
   "      return nil\n"
   "    end\n"
   "    assert_unique_name(\"limiter\", self.limiters, data)\n"
   "    local limiter = setmetatable(data, self.__submeta.limiter)\n"
   "    self.limiters[data.name]=limiter\n"
   "    if limiter.burst then\n"
   "      local burst_limiter = self:findLimiter(limiter.burst)\n"
   "      if not burst_limiter then\n"
   "        burst_limiter = self:addLimiter(limiters_in[limiter.burst], limiters_in)\n"
   "        limiters_in[limiter.burst].__already_loaded_as_burst_limiter = true\n"
   "        limiter.burst = burst_limiter\n"
   "      end\n"
   "    end\n"
   "    Binding.call(\"limiter\", \"create\", limiter)\n"
   "    return limiter\n"
   "  end,\n"
   "  deleteLimiter = function(self, limiter)\n"
   "    assert(self.limiters[limiter.name] == limiter, \"tried deleting unexpected list of the same name\")\n"
   "    --TODO: check which rules use this limiter\n"
   "    self.limiters[limiter.name] = nil\n"
   "    \n"
   "    Binding.call(\"limiter\", \"delete\", limiter)\n"
   "  end,\n"
   "  \n"
   "  findRule = function(self, name)\n"
   "    return self.rules[thing_name(name)]\n"
   "  end,\n"
   "  addRule = function(self, data)\n"
   "    if not data.name then\n"
   "      data.name = self:uniqueName(self.rules, \"rule\")\n"
   "    else\n"
   "      assert_unique_name(\"rule\", self.rules, data)\n"
   "    end\n"
   "    \n"
   "    local rule =setmetatable(data, self.__submeta.rule)\n"
   "    rule.ruleset = nil\n"
   "    if data[\"if\"] then\n"
   "      data[\"if\"] = Rule.condition.new(rule[\"if\"], self)\n"
   "    end\n"
   "    for _,clause in pairs{\"then\", \"else\"} do\n"
   "      if data[clause] then\n"
   "        local actions = {}\n"
   "        for _,v in pairs(data[clause]) do\n"
   "          table.insert(actions, Rule.action.new(v, self))\n"
   "        end\n"
   "        data[clause]=actions\n"
   "      end\n"
   "    end\n"
   "    \n"
   "    self.rules[data.name]=rule\n"
   "    Binding.call(\"rule\", \"create\", rule)\n"
   "    return rule\n"
   "  end,\n"
   "  deleteRule = function(self, rule)\n"
   "    assert(self.rules[rule.name] == rule, \"tried deleting unexpected list of the same name\")\n"
   "    for list_name, list in pairs(self.lists) do\n"
   "      for _, list_rule in ipairs(list) do\n"
   "        assert(list_rule ~= rule, (\"can't delete rule \\\"%s\\\", it's used in list \\\"%s\\\"\"):format(rule.name, list_name))\n"
   "      end\n"
   "    end\n"
   "    \n"
   "    self.rules[rule.name] = nil\n"
   "    \n"
   "    if rule[\"if\"] then\n"
   "      Rule.condition.delete(rule[\"if\"], self)\n"
   "    end\n"
   "    \n"
   "    for _,clause in pairs{\"then\", \"else\"} do\n"
   "      if rule[clause] then\n"
   "        local actions = rule[clause]\n"
   "        for _,action in pairs(actions) do\n"
   "          Rule.action.delete(action, self)\n"
   "        end\n"
   "        rule[clause]={}\n"
   "      end\n"
   "    end\n"
   "    Binding.call(\"rule\", \"delete\", rule)\n"
   "  end,\n"
   "  \n"
   "  findList = function(self, name)\n"
   "    return self.lists[thing_name(name)]\n"
   "  end,\n"
   "  addList = function(self, data)\n"
   "    if not data.name then\n"
   "      data.name = self:uniqueName(self.lists, \"list\")\n"
   "    else\n"
   "      assert_unique_name(\"list\", self.lists, data)\n"
   "    end\n"
   "    \n"
   "    for i, rule_data in ipairs(data.rules) do\n"
   "      data.rules[i]= self:findRule(rule_data.name) or self:addRule(rule_data)\n"
   "    end\n"
   "    local list = setmetatable(data, self.__submeta.list)\n"
   "    self.lists[data.name] = list\n"
   "    Binding.call(\"list\", \"create\", list)\n"
   "    return list\n"
   "  end,\n"
   "  deleteList = function(self, list)\n"
   "    assert(self.lists[list.name] == list, \"tried deleting unexpected list of the same name\")\n"
   "    for phase_name, phase in pairs(self.phases) do\n"
   "      for _, phase_list in ipairs(phase) do\n"
   "        assert(phase_list ~= list, (\"can't delete list \\\"%s\\\", it's used in phase \\\"%s\\\"\"):format(list.name, phase_name))\n"
   "      end\n"
   "    end\n"
   "    self.lists[list.name] = nil\n"
   "    Binding.call(\"list\", \"delete\", list)\n"
   "  end,\n"
   "  \n"
   "  setPhaseTable = function(self, data)\n"
   "    if self.phases then\n"
   "      for _, phase in pairs(self.phases) do\n"
   "        Binding.call(\"phase\", \"delete\", phase)\n"
   "      end\n"
   "    end\n"
   "    self.phases = {}\n"
   "    for k,v in pairs(data) do\n"
   "      local phase = setmetatable({name=k, lists={}}, self.__submeta.phase)\n"
   "      for i, list in pairs(v) do\n"
   "        phase.lists[i]=self:findList(list) or self:addList(list)\n"
   "      end\n"
   "      self.phases[k]=phase\n"
   "      Binding.call(\"phase\", \"create\", phase)\n"
   "    end\n"
   "    return self.phases\n"
   "  end,\n"
   "  \n"
   "  uniqueName = function(self, names_tbl, prefix)\n"
   "    if not self.__n then\n"
   "      self.__n = 0\n"
   "    else\n"
   "      self.__n = self.__n + 1\n"
   "    end\n"
   "    local name = (\"%s%i\"):format(prefix, self.__n)\n"
   "    if names_tbl[name] then --oh no it's not unique. try again\n"
   "      return self:uniqueName(names_tbl, prefix)\n"
   "    else\n"
   "      return name\n"
   "    end\n"
   "  end,\n"
   "  \n"
   "  toJSON = function(self)\n"
   "    local rs = {\n"
   "      name = self.name,\n"
   "      info = self.info,\n"
   "      rules = tcopy(self.rules),\n"
   "      lists = tcopy(self.lists),\n"
   "      limiters = tcopy(self.limiters),\n"
   "      phases = self.phases,\n"
   "    }\n"
   "    setmetatable(rs, self.__submeta.ruleset)\n"
   "    \n"
   "    --remove inlined names from rules, lists, and limiters\n"
   "    local excludes = {name=true}\n"
   "    for _, thingsname in ipairs({\"rules\", \"lists\", \"limiters\", \"phases\"}) do\n"
   "      local things = rs[thingsname] or {}\n"
   "      for k, thing in pairs(things) do\n"
   "        things[k]=table_copy(thing, excludes)\n"
   "      end\n"
   "    end\n"
   "    \n"
   "    return json.encode(rs, {indent=true})\n"
   "  end,\n"
   "  \n"
   "  destroy = function(self)\n"
   "    --clear phases\n"
   "    self:setPhaseTable({})\n"
   "    \n"
   "    --clear lists\n"
   "    for _, list in pairs(self.lists) do\n"
   "      self:deleteList(list)\n"
   "    end\n"
   "    \n"
   "    --clear rules\n"
   "    for _, rule in pairs(self.rules) do\n"
   "      self:deleteRule(rule)\n"
   "    end\n"
   "    \n"
   "    --clear limiters\n"
   "    for _, limiter in pairs(self.limiters) do\n"
   "      self:deleteLimiter(limiter)\n"
   "    end\n"
   "    \n"
   "    Binding.call(\"ruleset\", \"delete\", self)\n"
   "    \n"
   "  end\n"
   "}}\n"
   "\n"
   "local function sorted_keys(tbl)\n"
   "  local keys = {}\n"
   "  for k in pairs(tbl) do\n"
   "    table.insert(keys, k)\n"
   "  end\n"
   "  table.sort(keys)\n"
   "  return keys\n"
   "end\n"
   "\n"
   "local function newRuleset(data)\n"
   "  local ruleset = setmetatable({\n"
   "    rules=setmetatable({}, {__jsonorder=sorted_keys}),\n"
   "    lists=setmetatable({}, {__jsonorder=sorted_keys}),\n"
   "    limiters=setmetatable({}, {__jsonorder=sorted_keys}),\n"
   "    phases={},\n"
   "    name = data and data.name or nil\n"
   "  }, ruleset_meta)\n"
   "  \n"
   "  ruleset.__submeta = {\n"
   "    ruleset = {\n"
   "      __jsonorder = {\"name\", \"info\", \"phases\", \"limiters\", \"lists\", \"rules\"}\n"
   "    },\n"
   "    phase = {\n"
   "      __jsonval = function(self)\n"
   "        local lists = {}\n"
   "        for _, list in pairs(self.lists) do\n"
   "          table.insert(lists, list.name)\n"
   "        end\n"
   "        return lists\n"
   "      end\n"
   "    },\n"
   "    list = {\n"
   "      __jsonorder = {\"name\", \"info\", \"rules\"},\n"
   "      __jsonval = function(self)\n"
   "        local rules = {}\n"
   "        for _, rule in pairs(self.rules) do\n"
   "          table.insert(rules, rule.name)\n"
   "        end\n"
   "        \n"
   "        if self.info then\n"
   "          return setmetatable({info=self.info, rules=rules}, getmetatable(self))\n"
   "        else\n"
   "          return setmetatable(rules, getmetatable(self))\n"
   "        end\n"
   "      end\n"
   "    },\n"
   "    rule = {\n"
   "      __jsonorder = {\"name\", \"info\", \"key\", \"if\", \"if-any\", \"if-all\", \"then\", \"else\"},\n"
   "      __jsonval = function(self)\n"
   "        if #self[\"else\"] == 0 or #self[\"then\"] == 0 or self.key then\n"
   "          local ret = tcopy(self)\n"
   "          if #self[\"then\"] == 0 then ret[\"then\"] = nil end\n"
   "          if #self[\"else\"] == 0 then ret[\"else\"] = nil end\n"
   "          if self.key then self.key = self.key.string end\n"
   "          return ret\n"
   "        end\n"
   "        return self\n"
   "      end\n"
   "    },\n"
   "    limiter = {\n"
   "      __jsonorder = {\"name\", \"info\", \"limit\", \"interval\", \"burst\", \"burst-expire\"},\n"
   "      __jsonval = function(self)\n"
   "        if self.burst then\n"
   "          local cpy = tcopy(self)\n"
   "          cpy.burst = cpy.burst[\"name\"]\n"
   "          return cpy\n"
   "        end\n"
   "        return self\n"
   "      end\n"
   "    }\n"
   "  }\n"
   "\n"
   "  if not ruleset.name then ruleset.name = ruleset:uniqueName({}, \"ruleset\") end\n"
   "  \n"
   "  if data then\n"
   "    --load data\n"
   "    for _, v in pairs(data.limiters) do\n"
   "      ruleset:addLimiter(v, data.limiters)\n"
   "    end\n"
   "    \n"
   "    for _, v in pairs(data.rules) do\n"
   "      ruleset:addRule(v)\n"
   "    end\n"
   "    \n"
   "    for _, v in pairs(data.lists) do\n"
   "      ruleset:addList(v)\n"
   "    end\n"
   "    \n"
   "    ruleset:setPhaseTable(data.phases)\n"
   "  end\n"
   "  Binding.call(\"ruleset\", \"create\", ruleset)\n"
   "  return ruleset\n"
   "end\n"
   "\n"
   "local Ruleset = {new = newRuleset}\n"
   "\n"
   "return Ruleset\n"
   "\n"}
};
