#include <ngx_wafflex_redis_lua_scripts.h>

wfx_redis_lua_scripts_t wfx_redis_lua_scripts = {
  {"_ruleset_write_main", "f4515935d2a73f62cb3c1743640cba78ccd4220f",
   "local json = require \"dkjson\"\n"
   "local Parser = require \"parser\"\n"
   "\n"
   "--luacheck: globals redis\n"
   "\n"
   "\n"
   "redis.command(\"echo\", tostring(Parser) .. tostring(json))\n"
   "return 27\n"},

  {"init", "4f7d624f703483b37d89af715d7230c2ea24a95c",
   "\n"
   "--luacheck: globals redis\n"
   "\n"
   "redis.echo(\"hi there\")\n"
   "return \"hello\"\n"},

  {"ruleset_read", "2bcf00291dab24cc989b38ab4004269365c30db6",
   "\n"
   "--luacheck: globals redis cjson ARGV\n"
   "local prefix =        ARGV[1]\n"
   "local item =          ARGV[2]\n"
   "local ruleset_name =  ARGV[3]\n"
   "local item_name =     ARGV[4]\n"
   "\n"
   "\n"
   "local encode = cjson.encode\n"
   "local tinsert = table.insert\n"
   "\n"
   "local Jsonobj; do\n"
   "  local Jmeta = {__index = {\n"
   "    use = function(self, ...)\n"
   "      for _, k in ipairs {...} do\n"
   "        self:add(k, self.data[k])\n"
   "      end\n"
   "    end,\n"
   "    useRaw = function(self, ...)\n"
   "      for _, k in ipairs {...} do\n"
   "        self:addRaw(k, self.data[k])\n"
   "      end\n"
   "    end,\n"
   "    add = function(self, key, data, raw)\n"
   "      if data == nil then return end\n"
   "      if not raw then data = encode(data) end\n"
   "      tinsert(self.buf, (\"%s: %s\"):format(encode(key), data))\n"
   "    end,\n"
   "    addRaw = function(self, key, data)\n"
   "      return self:add(key, data, true)\n"
   "    end,\n"
   "    json = function(self)\n"
   "      return (\"{ %s }\"):format(table.concat(self.buf, \", \"))\n"
   "    end\n"
   "  }}\n"
   "  Jsonobj = function(data)\n"
   "    return setmetatable({buf={}, data=data or {}}, Jmeta)\n"
   "  end\n"
   "end\n"
   "\n"
   "local kbase = (\"%sruleset:%s\"):format(prefix and prefix..\":\" or \"\", ruleset_name)\n"
   "local key = {\n"
   "  ruleset =  kbase,\n"
   "  phases =   kbase..\":phases\",\n"
   "  lists =    kbase..\":lists\",\n"
   "  rules =    kbase..\":rules\",\n"
   "  limiters = kbase..\":limiters\"\n"
   "}\n"
   "\n"
   "local keyf = {\n"
   "  list = kbase..\":list:%s\",\n"
   "  list_rules = kbase..\":list:%s:rules\",\n"
   "  rule = kbase..\":rule:%s\",\n"
   "  limiter = kbase..\":limiter:%s\",\n"
   "  phase = kbase..\":phase:%s\"\n"
   "}\n"
   "\n"
   "local function redis_gethash(redis_key)\n"
   "  local res = redis.call(\"HGETALL\", redis_key)\n"
   "  if type(res)~=\"table\" then return nil end\n"
   "  local h, k = {}, nil\n"
   "  for _, v in ipairs(res) do\n"
   "    if k == nil then k=v\n"
   "    else h[k]=v; k=nil end\n"
   "  end\n"
   "  return h\n"
   "end\n"
   "\n"
   "local function as_json(what, name)\n"
   "  local j, ll\n"
   "  if item == \"rule\" then\n"
   "    j = Jsonobj(redis_gethash(keyf.rule:format(name)))\n"
   "    if not j then return end\n"
   "    j:use(\"name\",\"info\",\"gen\", \"key\")\n"
   "    j:useRaw(\"if\", \"then\", \"else\")\n"
   "\n"
   "  elseif item == \"limiter\" then\n"
   "    j = Jsonobj(redis_gethash(keyf.limiter:format(name)))\n"
   "    if not j then return end\n"
   "    j:use(\"name\",\"info\",\"gen\",\"interval\",\"limit\",\"sync-steps\",\"burst\",\"burst-expire\")\n"
   "    \n"
   "  elseif item == \"list\" then\n"
   "    j = Jsonobj(redis_gethash(keyf.list:format(name)))\n"
   "    if not j then return end\n"
   "    j:use(\"name\",\"info\",\"gen\")\n"
   "    ll = redis.command(\"LRANGE\", keyf.list_rules:format(name), 0, -1)\n"
   "    if ll then\n"
   "      j:add(\"rules\", ll)\n"
   "    else\n"
   "      j:addRaw(\"rules\", \"[]\")\n"
   "    end\n"
   "  \n"
   "  elseif item == \"phase\" then\n"
   "    ll = redis.command(\"LRANGE\", keyf.phase:format(name), 0, -1)\n"
   "    return ll and encode(ll) or \"[]\"\n"
   "\n"
   "  elseif item == \"ruleset\" then\n"
   "    j = Jsonobj(redis_gethash(key.ruleset))\n"
   "    if not j then return end\n"
   "    \n"
   "    local function add_ruleset_items(the_item, items_set_key, attribute)\n"
   "      local jj = Jsonobj()\n"
   "      for _, n in ipairs(table.sort(redis.comand(\"SMEMBERS\", items_set_key))) do\n"
   "        jj:addRaw(n, as_json(the_item, n))\n"
   "      end\n"
   "      j:addRaw(attribute, jj:json())\n"
   "    end\n"
   "    \n"
   "    add_ruleset_items(\"limiter\", key.limiters, \"limiters\")\n"
   "    add_ruleset_items(\"phase\", key.phases, \"phases\")\n"
   "    add_ruleset_items(\"list\", key.lists, \"lists\")\n"
   "    add_ruleset_items(\"rule\", key.rules, \"rules\")\n"
   "  else\n"
   "    error((\"unknown ruleset item \\\"%s\\\"\"):format(item))\n"
   "  end\n"
   "  return j:json()\n"
   "end\n"
   "\n"
   "return as_json(item, item_name)\n"},

  {"ruleset_write", "5e9624679efd97bcef16d68e8596949623c24312",
   "--autogenerated script, do not edit\n"
   "local require, module; do\n"
   "  local modules = {}\n"
   "  module = function(name, fn) modules[name]=fn() end\n"
   "  require = function(name) return modules[name] end\n"
   "end\n"
   "--luacheck: ignore\n"
   "local function main()\n"
   "  local json = require \"dkjson\"\n"
   "  local Parser = require \"parser\"\n"
   "  \n"
   "  --luacheck: globals redis\n"
   "  \n"
   "  \n"
   "  redis.command(\"echo\", tostring(Parser) .. tostring(json))\n"
   "  return 27\n"
   "\n"
   "end\n"
   "\n"
   "module(\"dkjson\", function()\n"
   "local a=false;local b=false;local c='json'local pairs,type,tostring,tonumber,getmetatable,setmetatable,rawset=pairs,type,tostring,tonumber,getmetatable,setmetatable,rawset;local error,require,pcall,select=error,require,pcall,select;local d,e=math.floor,math.huge;local f,g,h,i,j,k,l,m=string.rep,string.gsub,string.sub,string.byte,string.char,string.find,string.len,string.format;local n=string.match;local o=table.concat;local p={version=\"dkjson 2.5\"}if b then _G[c]=p end;local q=nil;pcall(function()local r=require\"debug\".getmetatable;if r then getmetatable=r end end)p.null=setmetatable({},{__tojson=function()return\"null\"end})local function s(t)local u,v,w=0,0,0;for x,y in pairs(t)do if x=='n'and type(y)=='number'then w=y;if y>u then u=y end else if type(x)~='number'or x<1 or d(x)~=x then return false end;if x>u then u=x end;v=v+1 end end;if u>10 and u>w and u>v*2 then return false end;return true,u end;local z={[\"\\\"\"]=\"\\\\\\\"\",[\"\\\\\"]=\"\\\\\\\\\",[\"\\b\"]=\"\\\\b\",[\"\\f\"]=\"\\\\f\",[\"\\n\"]=\"\\\\n\",[\"\\r\"]=\"\\\\r\",[\"\\t\"]=\"\\\\t\"}local function A(B)local C=z[B]if C then return C end;local D,E,F,G=i(B,1,4)D,E,F,G=D or 0,E or 0,F or 0,G or 0;if D<=0x7f then C=D elseif 0xc0<=D and D<=0xdf and E>=0x80 then C=(D-0xc0)*0x40+E-0x80 elseif 0xe0<=D and D<=0xef and E>=0x80 and F>=0x80 then C=((D-0xe0)*0x40+E-0x80)*0x40+F-0x80 elseif 0xf0<=D and D<=0xf7 and E>=0x80 and F>=0x80 and G>=0x80 then C=(((D-0xf0)*0x40+E-0x80)*0x40+F-0x80)*0x40+G-0x80 else return\"\"end;if C<=0xffff then return m(\"\\\\u%.4x\",C)elseif C<=0x10ffff then C=C-0x10000;local H,I=0xD800+d(C/0x400),0xDC00+C%0x400;return m(\"\\\\u%.4x\\\\u%.4x\",H,I)else return\"\"end end;local function J(K,L,M)if k(K,L)then return g(K,L,M)else return K end end;local function N(C)C=J(C,\"[%z\\1-\\31\\\"\\\\\\127]\",A)if k(C,\"[\\194\\216\\220\\225\\226\\239]\")then C=J(C,\"\\194[\\128-\\159\\173]\",A)C=J(C,\"\\216[\\128-\\132]\",A)C=J(C,\"\\220\\143\",A)C=J(C,\"\\225\\158[\\180\\181]\",A)C=J(C,\"\\226\\128[\\140-\\143\\168-\\175]\",A)C=J(C,\"\\226\\129[\\160-\\175]\",A)C=J(C,\"\\239\\187\\191\",A)C=J(C,\"\\239\\191[\\176-\\191]\",A)end;return\"\\\"\"..C..\"\\\"\"end;p.quotestring=N;local function O(K,P,v)local Q,R=k(K,P,1,true)if Q then return h(K,1,Q-1)..v..h(K,R+1,-1)else return K end end;local S,T;local function U()S=n(tostring(0.5),\"([^05+])\")T=\"[^0-9%-%+eE\"..g(S,\"[%^%$%(%)%%%.%[%]%*%+%-%?]\",\"%%%0\")..\"]+\"end;U()local function V(W)return O(J(tostring(W),T,\"\"),S,\".\")end;local function X(K)local W=tonumber(O(K,\".\",S))if not W then U()W=tonumber(O(K,\".\",S))end;return W end;local function Y(Z,_,a0)_[a0+1]=\"\\n\"_[a0+2]=f(\"  \",Z)a0=a0+2;return a0 end;function p.addnewline(a1)if a1.indent then a1.bufferlen=Y(a1.level or 0,a1.buffer,a1.bufferlen or#a1.buffer)end end;local a2;local function a3(a4,C,a5,a6,Z,_,a0,a7,a8,a1)local a9=type(a4)if a9~='string'and a9~='number'then return nil,\"type '\"..a9 ..\"' is not supported as a key by JSON.\"end;if a5 then a0=a0+1;_[a0]=\",\"end;if a6 then a0=Y(Z,_,a0)end;_[a0+1]=N(a4)_[a0+2]=\":\"return a2(C,a6,Z,_,a0+2,a7,a8,a1)end;local function aa(ab,_,a1)local a0=a1.bufferlen;if type(ab)=='string'then a0=a0+1;_[a0]=ab end;return a0 end;local function ac(ad,C,a1,_,a0,ae)ae=ae or ad;local af=a1.exception;if not af then return nil,ae else a1.bufferlen=a0;local ag,ah=af(ad,C,a1,ae)if not ag then return nil,ah or ae end;return aa(ag,_,a1)end end;function p.encodeexception(ad,C,a1,ae)return N(\"<\"..ae..\">\")end;a2=function(C,a6,Z,_,a0,a7,a8,a1)local ai=type(C)local aj=getmetatable(C)aj=type(aj)=='table'and aj;local ak=aj and aj.__jsonval;if ak then if type(ak)==\"function\"then C=ak(C)else C=ak end;ai=type(C)end;local al=aj and aj.__tojson;if al then if a7[C]then return ac('reference cycle',C,a1,_,a0)end;a7[C]=true;a1.bufferlen=a0;local ag,ah=al(C,a1)if not ag then return ac('custom encoder failed',C,a1,_,a0,ah)end;a7[C]=nil;a0=aa(ag,_,a1)elseif C==nil then a0=a0+1;_[a0]=\"null\"elseif ai=='number'then local am;if C~=C or C>=e or-C>=e then am=\"null\"else am=V(C)end;a0=a0+1;_[a0]=am elseif ai=='boolean'then a0=a0+1;_[a0]=C and\"true\"or\"false\"elseif ai=='string'then a0=a0+1;_[a0]=N(C)elseif ai=='table'then if a7[C]then return ac('reference cycle',C,a1,_,a0)end;a7[C]=true;Z=Z+1;local an,v=s(C)if v==0 and aj and aj.__jsontype=='object'then an=false end;local ah;if an then a0=a0+1;_[a0]=\"[\"for Q=1,v do a0,ah=a2(C[Q],a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;if Q<v then a0=a0+1;_[a0]=\",\"end end;a0=a0+1;_[a0]=\"]\"else local a5=false;a0=a0+1;_[a0]=\"{\"local ao=aj and aj.__jsonorder or a8;if ao then if type(ao)==\"function\"then ao=ao(C)end;local ap={}v=#ao;for Q=1,v do local x=ao[Q]local y=C[x]if y then ap[x]=true;a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)a5=true end end;for x,y in pairs(C)do if not ap[x]then a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;a5=true end end else for x,y in pairs(C)do a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;a5=true end end;if a6 then a0=Y(Z-1,_,a0)end;a0=a0+1;_[a0]=\"}\"end;a7[C]=nil else return ac('unsupported type',C,a1,_,a0,\"type '\"..ai..\"' is not supported by JSON.\")end;return a0 end;function p.encode(C,a1)a1=a1 or{}local aq=a1.buffer;local _=aq or{}a1.buffer=_;U()local ag,ah=a2(C,a1.indent,a1.level or 0,_,a1.bufferlen or 0,a1.tables or{},a1.keyorder,a1)if not ag then error(ah,2)elseif aq==_ then a1.bufferlen=ag;return true else a1.bufferlen=nil;a1.buffer=nil;return o(_)end end;local function ar(K,as)local at,au,av=1,1,0;while true do au=k(K,\"\\n\",au,true)if au and au<as then at=at+1;av=au;au=au+1 else break end end;return\"line \"..at..\", column \"..as-av end;local function aw(K,ax,as)return nil,l(K)+1,\"unterminated \"..ax..\" at \"..ar(K,as)end;local function ay(K,au)while true do au=k(K,\"%S\",au)if not au then return nil end;local az=h(K,au,au+1)if az==\"\\239\\187\"and h(K,au+2,au+2)==\"\\191\"then au=au+3 elseif az==\"//\"then au=k(K,\"[\\n\\r]\",au+2)if not au then return nil end elseif az==\"/*\"then au=k(K,\"*/\",au+2)if not au then return nil end;au=au+2 else return au end end end;local aA={[\"\\\"\"]=\"\\\"\",[\"\\\\\"]=\"\\\\\",[\"/\"]=\"/\",[\"b\"]=\"\\b\",[\"f\"]=\"\\f\",[\"n\"]=\"\\n\",[\"r\"]=\"\\r\",[\"t\"]=\"\\t\"}local function aB(C)if C<0 then return nil elseif C<=0x007f then return j(C)elseif C<=0x07ff then return j(0xc0+d(C/0x40),0x80+d(C)%0x40)elseif C<=0xffff then return j(0xe0+d(C/0x1000),0x80+d(C/0x40)%0x40,0x80+d(C)%0x40)elseif C<=0x10ffff then return j(0xf0+d(C/0x40000),0x80+d(C/0x1000)%0x40,0x80+d(C/0x40)%0x40,0x80+d(C)%0x40)else return nil end end;local function aC(K,au)local aD=au+1;local _,v={},0;while true do local aE=k(K,\"[\\\"\\\\]\",aD)if not aE then return aw(K,\"string\",au)end;if aE>aD then v=v+1;_[v]=h(K,aD,aE-1)end;if h(K,aE,aE)==\"\\\"\"then aD=aE+1;break else local aF=h(K,aE+1,aE+1)local C;if aF==\"u\"then C=tonumber(h(K,aE+2,aE+5),16)if C then local aG;if 0xD800<=C and C<=0xDBff then if h(K,aE+6,aE+7)==\"\\\\u\"then aG=tonumber(h(K,aE+8,aE+11),16)if aG and 0xDC00<=aG and aG<=0xDFFF then C=(C-0xD800)*0x400+aG-0xDC00+0x10000 else aG=nil end end end;C=C and aB(C)if C then if aG then aD=aE+12 else aD=aE+6 end end end end;if not C then C=aA[aF]or aF;aD=aE+2 end;v=v+1;_[v]=C end end;if v==1 then return _[1],aD elseif v>1 then return o(_),aD else return\"\",aD end end;local aH;local function aI(t,aJ,K,au)if type(aJ)==\"function\"then aJ=aJ(K,au)if type(aJ)~=\"table\"then return t end end;return setmetatable(t,aJ)end;local function aK(ax,aL,K,aM,aN,aO,aP)local aQ=l(K)local t,v={},0;local au=aM+1;if ax=='object'then aI(t,aO,K,aM)else aI(t,aP,K,aM)end;while true do au=ay(K,au)if not au then return aw(K,ax,aM)end;local aR=h(K,au,au)if aR==aL then return t,au+1 end;local aS,aT;aS,au,aT=aH(K,au,aN,aO,aP)if aT then return nil,au,aT end;au=ay(K,au)if not au then return aw(K,ax,aM)end;aR=h(K,au,au)if aR==\":\"then if aS==nil then return nil,au,\"cannot use nil as table index (at \"..ar(K,au)..\")\"end;au=ay(K,au+1)if not au then return aw(K,ax,aM)end;local aU;aU,au,aT=aH(K,au,aN,aO,aP)if aT then return nil,au,aT end;t[aS]=aU;au=ay(K,au)if not au then return aw(K,ax,aM)end;aR=h(K,au,au)else v=v+1;t[v]=aS end;if aR==\",\"then au=au+1 end end end;aH=function(K,au,aN,aO,aP)au=au or 1;au=ay(K,au)if not au then return nil,l(K)+1,\"no valid JSON value (reached the end)\"end;local aR=h(K,au,au)if aR==\"{\"then return aK('object',\"}\",K,au,aN,aO,aP)elseif aR==\"[\"then return aK('array',\"]\",K,au,aN,aO,aP)elseif aR==\"\\\"\"then return aC(K,au)else local aV,aW=k(K,\"^%-?[%d%.]+[eE]?[%+%-]?%d*\",au)if aV then local aX=X(h(K,aV,aW))if aX then return aX,aW+1 end end;aV,aW=k(K,\"^%a%w*\",au)if aV then local aY=h(K,aV,aW)if aY==\"true\"then return true,aW+1 elseif aY==\"false\"then return false,aW+1 elseif aY==\"null\"then return aN,aW+1 end end;return nil,au,\"no valid JSON value at \"..ar(K,au)end end;local function aZ(...)if select(\"#\",...)>0 then return...else return{__jsontype='object'},{__jsontype='array'}end end;function p.decode(K,au,aN,...)local aO,aP=aZ(...)return aH(K,au,aN,aO,aP)end;function p.use_lpeg()local a_=require(\"lpeg\")if a_.version()==\"0.11\"then error\"due to a bug in LPeg 0.11, it cannot be used for JSON matching\"end;local b0=a_.match;local b1,b2,b3=a_.P,a_.S,a_.R;local function b4(K,au,ah,a1)if not a1.msg then a1.msg=ah..\" at \"..ar(K,au)a1.pos=au end;return false end;local function b5(ah)return a_.Cmt(a_.Cc(ah)*a_.Carg(2),b4)end;local b6=b1\"//\"*(1-b2\"\\n\\r\")^0;local b7=b1\"/*\"*(1-b1\"*/\")^0*b1\"*/\"local b8=(b2\" \\n\\r\\t\"+b1\"\\239\\187\\191\"+b6+b7)^0;local b9=1-b2\"\\\"\\\\\\n\\r\"local ba=b1\"\\\\\"*a_.C(b2\"\\\"\\\\/bfnrt\"+b5\"unsupported escape sequence\")/aA;local bb=b3(\"09\",\"af\",\"AF\")local function bc(bd,au,be,bf)be,bf=tonumber(be,16),tonumber(bf,16)if 0xD800<=be and be<=0xDBff and 0xDC00<=bf and bf<=0xDFFF then return true,aB((be-0xD800)*0x400+bf-0xDC00+0x10000)else return false end end;local function bg(bh)return aB(tonumber(bh,16))end;local bi=b1\"\\\\u\"*a_.C(bb*bb*bb*bb)local bj=a_.Cmt(bi*bi,bc)+bi/bg;local bk=bj+ba+b9;local bl=b1\"\\\"\"*a_.Cs(bk^0)*(b1\"\\\"\"+b5\"unterminated string\")local bm=b1\"-\"^-1*(b1\"0\"+b3\"19\"*b3\"09\"^0)local bn=b1\".\"*b3\"09\"^0;local bo=b2\"eE\"*b2\"+-\"^-1*b3\"09\"^1;local bp=bm*bn^-1*bo^-1/X;local bq=b1\"true\"*a_.Cc(true)+b1\"false\"*a_.Cc(false)+b1\"null\"*a_.Carg(1)local br=bp+bl+bq;local bs,bt;local function bu(K,au,aN,a1)local bv,bw;local bx;local by,bz={},0;repeat bv,bw,bx=b0(bs,K,au,aN,a1)if not bx then break end;au=bx;bz=bz+1;by[bz]=bv until bw=='last'return au,setmetatable(by,a1.arraymeta)end;local function bA(K,au,aN,a1)local bv,a4,bw;local bx;local by={}repeat a4,bv,bw,bx=b0(bt,K,au,aN,a1)if not bx then break end;au=bx;by[a4]=bv until bw=='last'return au,setmetatable(by,a1.objectmeta)end;local bB=b1\"[\"*a_.Cmt(a_.Carg(1)*a_.Carg(2),bu)*b8*(b1\"]\"+b5\"']' expected\")local bC=b1\"{\"*a_.Cmt(a_.Carg(1)*a_.Carg(2),bA)*b8*(b1\"}\"+b5\"'}' expected\")local bD=b8*(bB+bC+br)local bE=bD+b8*b5\"value expected\"bs=bD*b8*(b1\",\"*a_.Cc'cont'+a_.Cc'last')*a_.Cp()local bF=a_.Cg(b8*bl*b8*(b1\":\"+b5\"colon expected\")*bE)bt=bF*b8*(b1\",\"*a_.Cc'cont'+a_.Cc'last')*a_.Cp()local bG=bE*a_.Cp()function p.decode(K,au,aN,...)local a1={}a1.objectmeta,a1.arraymeta=aZ(...)local bv,bH=b0(bG,K,au,aN,a1)if a1.msg then return nil,a1.pos,a1.msg else return bv,bH end end;p.use_lpeg=function()return p end;p.using_lpeg=true;return p end;if a then pcall(p.use_lpeg)end;return p\n"
   "\n"
   "end)\n"
   "\n"
   "module(\"parser\", function()\n"
   "local a=require\"rule\"local b=require\"dkjson\"local function c(d,e,f)local g=e[f.key]d:pushContext(g,f.key)local h=d.ruleset;if g then d:assert_type(g,f.type,\"wrong type for ruleset %s, expected %s, got %s\",f.key,f.type,d:jsontype(g))local i,j;for k,l in pairs(g)do d:assert_type(k,\"string\",\"wrong key type for %s, expected string, got %s %s\",f.thing,d:jsontype(k),tostring(k))i,j=f.parser_method(d,l,k)d:assert(i,j)d:assert(h[f.key][i.name]==nil,\"%s %s already exists\",f.thing,i.name)h[f.key][i.name]=i end end;d:popContext()return true end;local function m(n,o)if type(n)==type(o)then setmetatable(n,getmetatable(o))end end;local p;do local q=setmetatable({},{__mode=\"k\"})p=function(r,s)local t,u,v=1,1,0;local w=q[r]if w and w.pos<s then t=w.line;u=w.pos end;while true do u=r:find(\"\\n\",u,true)if u and u<s then t=t+1;v=u;u=u+1 else break end end;return t,s-v end end;local function x(y)return function(r,s)local t,z=p(r,s)return{__pos=s,__line=t,__column=z,__jsontype=y,__jsonmeta=true}end end;local A={}function A:jsontype(B)if type(B)==\"table\"then local C=getmetatable(B)return C and C.__jsontype or nil else return type(B)end end;function A:assert(D,j,...)if not D then self:error(j,...)end;return D end;function A:assert_type(B,E,j,...)if j then return self:assert(type(B)==E,j,...)else return self:assert(type(B)==E,\"expected type '%s', got '%s'\",E,type(B))end end;function A:assert_jsontype(B,E,j,...)if j then return self:assert(self:jsontype(B)==E,j,...)else return self:assert(self:jsontype(B)==E,\"expected JSON type '%s', got '%s'\",E,self:jsontype(B))end end;function A:assert_table_size(B,F,j,...)self:assert_type(B,\"table\")local G=0;for H,H in pairs(B)do G=G+1 end;if G~=F then if j then self:error(j,...)else self:error(\"wrong table size, expected %i, got %i\",F,G)end end;return B end;local function I(J)local K=getmetatable(J)if K.__line and K.__column then return K.__line,K.__column end end;local function L(J)local t,M=I(J)if t and M then return(\"line %s column %i\"):format(t,M)else return nil end end;function A:error(j,...)if not j then j=\"unknown error\"end;if select(\"#\",...)>0 then j=j:format(...)end;local N={}for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]if P.name then table.insert(N,P.name)end;local Q=L(P.ctx)if Q then if self.name then table.insert(N,self.name)end;error((\"%s at %s: %s\"):format(table.concat(N,\" in \"),Q,j))end end;if self.name then table.insert(N,self.name)end;if#N>0 then error((\"%s: %s\"):format(table.concat(N,\" in \"),j))else error(j)end end;function A:setInterpolationChecker(R)self.interpolation_checker=R end;function A:checkInterpolatedString(r)if self.interpolation_checker then self.interpolation_checker(r,self)end;return true end;function A:pushContext(S,T)table.insert(self.ctx_stack,{ctx=S,name=T})self.context=self.ctx_stack[#self.ctx_stack]return self end;function A:popContext()table.remove(self.ctx_stack,#self.ctx_stack)self.context=self.ctx_stack[#self.ctx_stack]end;function A:getContext(T)if not T then return self.context and self.context.ctx end;for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]if P.name==T then return P.ctx end end;return nil end;function A:printContext()for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]print(P.name or\"<?>\",self:jsontype(P.ctx)or\"<?>\",L(P.ctx)or\"\")end end;function A:parseFile(U)local V=assert(io.open(U,\"rb\"))local W=V:read(\"*a\")V:close()self.name=U;return self:parseJSON(W,\"file \"..U)end;function A:parseJSON(X,Y)self:assert_type(X,\"string\",\"expected a JSON string\")local g,H,j=b.decode(X,1,b.null,x(\"object\"),x(\"array\"))self.name=Y or self.context_name;self.source=X;if not g then self:error(j)end;return self:parseRuleSet(g)end;function A:parseInterpolatedString(r)for Z in r:gmatch(\"%$%b{}\")do if not Z:match(\"^%${[%w_]+}\")then self:error(\"invalid variable \\\"%s\\\" in interpolated string\",Z)end end;for Z in r:gmatch(\"%${?[%w_]*}?\")do if Z:sub(2,2)==\"{\"then if Z:sub(-1)~=\"}\"then self:error(\"missing '}' in interpolated string\")end;Z=Z:sub(3,-2)if Z==\"\"then self:error(\"invalid variable ${} in interpolated string\")elseif Z:match(\"^%d%d+\")then self:error(\"invalid regex capture \\\"%s\\\" in interpolated string. 1-9 only (nginx quirk)\",Z)elseif Z:match(\"^%d.+\")then self:error(\"invalid variable \\\"%s\\\" in interpolated string. can't sart with a number (nginx quirk)\",Z)end else Z=Z:sub(2,-1)end;if Z==\"\"then self:error(\"invalid empty variable in interpolated string\")end end;return{string=r}end;function A:parseRuleSet(g,T)self.ruleset={limiters={},rules={},lists={},phases={},name=T}self:pushContext(g,\"ruleset\")self:assert_type(g,\"table\",\"wrong type for ruleset\")c(self,g,{thing=\"limiter\",key=\"limiters\",type=\"table\",parser_method=self.parseLimiter})self:checkLimiters(g.limiters)c(self,g,{thing=\"rule\",key=\"rules\",type=\"table\",parser_method=function(self,g,T)self:pushContext(g,\"rule\")self:assert(type(g)~=\"string\",(\"named rule \\\"%s\\\" cannot be a string referring to another named rule \\\"%s\\\"\"):format(T,tostring(g)))self:popContext()return self:parseRule(g,T)end})c(self,g,{thing=\"list\",key=\"lists\",type=\"table\",parser_method=self.parseRuleList})self.ruleset.phases=self:parsePhaseTable(g.phases)local function _(J)local a0=getmetatable(J)if a0 and a0.__jsonmeta then setmetatable(J,{line=a0.__line,col=a0.__column})end;for H,l in pairs(J)do if type(l)==\"table\"then _(l)end end end;_(self.ruleset)return self.ruleset end;function A:parsePhaseTable(g)self:assert(g~=nil,\"missing phase table (\\\"phases\\\" attribute)\")self:assert_jsontype(g,\"object\",\"phase table must be an object\")self:pushContext(g,\"phase table\")for a1,a2 in pairs(g)do self:assert_type(a1,\"string\",\"phase table entries must be strings\")if self:jsontype(a2)==\"array\"then for O,a3 in ipairs(a2)do if type(a3)==\"string\"or self:jsontype(a3)==\"array\"or self:jsontype(a3)==\"object\"then a2[O]=self:parseRuleList(a3)else self:error(\"invalid rule list type: %s\",self:jsontype(a3))end end elseif type(a2)==\"string\"then g[a1]={self:parseRuleList(a2)}elseif self:jsontype(a2)==\"object\"then g[a1]=self:parseRuleList(a2)end end;self:popContext()return g end;function A:parseRuleList(g,T)if type(g)==\"string\"then self:assert(self.ruleset.lists[g],([[named list \"%s\" not found]]):format(g))return self.ruleset.lists[g]end;self:pushContext(g,\"list\")local a3;if self:jsontype(g)==\"object\"then if T then self:assert(T==g.name,\"rule list 'name' attribute must match outside list name\")else T=tostring(g.name)end;g=g.rules end;self:assert_jsontype(g,\"array\",\"rule list must be an array\")local a4={}for H,l in ipairs(g)do table.insert(a4,self:parseRule(l))end;self:popContext()a3={name=T,rules=a4}m(a3,g)return a3 end;function A:parseRule(g,T)self:pushContext(g,\"rule\")local a5;if type(g)==\"string\"then a5=self.ruleset.rules[g]self:assert(a5,([[named rule \"%s\" not found]]):format(g))self:popContext()return a5 end;self:assert_type(g,\"table\",\"invalid rule data type: \"..type(g))self:assert_jsontype(g,\"object\",(\"invalid rule data type: %s\"):format(self:jsontype(g)))if g[\"if\"]or g[\"if-any\"]or g[\"if-all\"]or g[\"then\"]then self:assert(not g[\"always\"],[[\"always\" clause can't be present in if/then rule]])self:assert(not g[\"switch\"],[[\"switch\" clause can't be present in if/then rule]])end;if g[\"then\"]then if g[\"if\"]and(g[\"if-any\"]or g[\"if-all\"])or g[\"if-any\"]and g[\"if-all\"]then self:error(\"only one of \\\"if\\\", \\\"if-any\\\" or \\\"if-all\\\" allowed in if/then rule\")end;local a6;if g[\"if\"]then a6=self:parseCondition(g[\"if\"])elseif g[\"if-any\"]or g[\"if-all\"]then local a7={}for H,l in ipairs(g[\"if-any\"]or g[\"if-all\"])do a6=self:assert(self:parseCondition(l))table.insert(a7,a6)end;a6={[g[\"if-any\"]and\"any\"or\"all\"]=a7}m(a6,g[\"if\"]or g[\"if-any\"]or g[\"if-all\"])end;a5={[\"if\"]=a6,[\"then\"]=g[\"then\"],[\"else\"]=g[\"else\"],name=g[\"name\"]or T,info=g[\"info\"],key=g[\"key\"]}elseif g[\"always\"]then a5={[\"if\"]={[\"true\"]={}},[\"then\"]=g[\"always\"],name=g[\"name\"]or T,info=g[\"info\"],key=g[\"key\"]}elseif next(g)==nil then self:error(\"empty rule not allowed\")else self:error(\"rule must have at least an \\\"if\\\", \\\"then\\\", or \\\"always\\\" attribute\")end;if a5[\"if\"]then a5[\"then\"]=self:parseActions(a5[\"then\"],\"then\")a5[\"else\"]=self:parseActions(a5[\"else\"],\"else\")end;if a5.key then a5.key=self:parseInterpolatedString(a5.key)end;self:popContext()m(a5,g)return a5 end;function A:parseCondition(g)self:pushContext(g,\"condition\")local a6;if type(g)==\"string\"then a6={[g]={}}elseif type(g)==\"table\"then self:assert_jsontype(g,\"object\",\"condition cannot be an array, must be an object\")self:assert_table_size(g,1,\"condition object must have exactly one attribute (the condition name)\")a6=g else self:error(\"wrong type (%s) for condition\",type(g))end;self:popContext()self:pushContext(g,\"condition \"..next(a6))a6=a.condition.parse(a6,self)self:popContext()m(a6,g)return a6 end;function A:parseAction(g)self:pushContext(g,\"action\")local a8;if type(g)==\"string\"then a8={[g]={}}elseif self:jsontype(g)==\"object\"then self:assert(next(g,next(g))==nil,\"action object must have only 1 attribute -- the action name\")a8=g else self:error(\"action must be string on 1-attribute object, but instead was a %s\",self:jsontype(g))end;self:popContext()self:pushContext(g,(\"\\\"%s\\\" action\"):format(next(a8)))m(a8,g)a8=a.action.parse(a8,self)self:popContext()return a8 end;function A:parseActions(g,T)if g==nil then return{}end;self:pushContext(g,T and(\"\\\"%s\\\" actions\"):format(T)or nil)local a9={}m(a9,g)if self:jsontype(g)==\"object\"or type(g)==\"string\"or#g==0 and next(g)~=nil then table.insert(a9,self:parseAction(g))elseif type(g)==\"table\"then for H,l in ipairs(g)do table.insert(a9,self:parseAction(l))end end;self:popContext()return a9 end;function A:parseTimeInterval(g,j)if j then j=\" for \"..j end;local aa=self:jsontype(g)if aa==\"number\"then return g elseif aa==\"string\"then local ab,ac=g:match(\"^([%d.]+)([%w_]*)\")local ad;ab=tonumber(ab)self:assert(ab and ac,(\"invalid time string \\\"%s\\\"%s\"):format(g,j))if ac==\"ms\"or ac:match(\"^millisec(ond(s?))?\")then ad=.01 elseif ac==\"\"or ac==\"s\"or ac:match(\"^sec(ond(s?))?\")then ad=1 elseif ac==\"m\"or ac:match(\"^min(ute(s)?)?\")then ad=60 elseif ac==\"h\"or ac:match(\"^hour(s?)\")then ad=3600 elseif ac==\"d\"or ac:match(\"^day(s)?\")then ad=86400 elseif ac==\"w\"or ac==\"wk\"or ac:match(\"^week(s)?\")then ad=604800 elseif ac==\"M\"or ac:match(\"^month(s)?\")then ad=2628001 else self:error(\"unknown time unit \\\"%s\\\"%s\",ac,j)end;return ab*ad else self:error(\"invalid time inteval type \\\"%s\\\"%s\",self:jsontype(g),j)end end;function A:parseLimiter(g,T)self:pushContext(g,\"limiter\")if not g.name then g.name=T end;g.interval=self:parseTimeInterval(g.interval,\"interval value\")self:assert(g.interval>=60,\"\\\"interval\\\" value must be >= 60 seconds\")self:assert(g.limit,\"missing \\\"limit\\\" value\")g.limit=self:assert(tonumber(g.limit),\"invalid \\\"limit\\\" value, must be a number\")self:assert(g.limit>=0,\"\\\"limit\\\" value must be >= 0\")if g.sync_steps then g.sync_steps=self:assert(tonumber(g.sync_steps),\"invalid \\\"sync-steps\\\" value\")end;if g.burst then self:assert_type(g.burst,\"string\",\"invalid \\\"burst\\\" value type\")end;if g[\"burst-expire\"]then g.burst_expire=self:parseTimeInterval(g[\"burst-expire\"],\"burst_expire value\")g[\"burst-expire\"]=nil end;self:assert_type(g.name,\"string\",\"invalid limiter name\")self:popContext()return g end;function A:checkLimiters(g)if not g then return true end;self:pushContext(g,\"limiters\")for H,l in pairs(g)do self:pushContext(l,(\"limiter \\\"%s\\\"\"):format(l.name))if l.burst then self:assert(g[l.burst],(\"limiter references unknown burst limiter \\\"%s\\\"\"):format(l.burst))end;self:popContext()end;self:popContext()end;local ae={__index=A}local function af()local d={name=\"<?>\",ctx_stack={}}setmetatable(d,ae)return d end;return{new=af}\n"
   "\n"
   "end)\n"
   "\n"
   "module(\"rule\", function()\n"
   "local a=require\"binding\"or{call=function()end}local function b(c)return c:sub(1,1)==\"#\"and c:sub(2)or c end;local d={__index=function(self,e)local f=b(e)if f~=e then return self[b(e)]end end}local function g(h)local self={table=setmetatable({},d)}local function i(j,k)local l,m=next(j)if type(l)==\"number\"then k:error(\"invalid data value, expected {\\\"key\\\":value}, got {\\\"key\\\"}\")elseif type(l)~=\"string\"then k:error(\"unexpected data type %s\",type(l))end;local n=self.table[l]if k then k:assert(n,(\"Unknown %s \\\"%s\\\"\"):format(h,l))else assert(n,(\"Unknown %s \\\"%s\\\"\"):format(h,l))end;return l,m end;function self.add(l,o,p)if type(l)==\"table\"then for q,r in pairs(l)do self.add(r,o,p)end;return true end;assert(o.parse,(\"%s missing parse callback\"):format(h))assert(self.table[l]==nil,(\"%s %s already exists\"):format(h,l))local s={parse=o.parse,init=o.init,delete=o.delete}if p then s.meta=p end;self.table[l]=s;return true end;function self.parse(j,k)local l,m=i(j,k)m=self.table[l].parse(m,k)or m;return{[l]=m}end;function self.new(j,t)local l,m=i(j)l=b(l)local u=self.table[l]local n=setmetatable({[h]=l,data=m},u.meta)if u.init then local v=u.init(m,n,t)if v then n.data=v end end;a.call((\"%s:%s\"):format(h,l),\"create\",n)return n end;function self.delete(n,t)local l=n[h]or n.name;local u=self.table[l]print(h..\" DELETE THING \"..l..\" \"..tostring(u.delete))if u.delete then u.delete(n.data,t)end;a.call((\"%s:%s\"):format(h,l),\"delete\",n)end;return self end;local w={condition=g(\"condition\"),action=g(\"action\")}w.condition.add(\"any\",{parse=function(j,k)k:assert_jsontype(j,\"array\",\"\\\"any\\\" condition value must be an array of conditions\")for x,r in ipairs(j)do local y=k:parseCondition(r)j[x]=y end end,init=function(j,n,t)for x,r in ipairs(j)do j[x]=w.condition.new(r,t)end end,delete=function(j,t)for q,z in ipairs(j)do w.condition.delete(z,t)end end},{__jsonval=function(self)return{any=self.data}end})w.condition.add(\"all\",{parse=function(j,k)k:assert_jsontype(j,\"array\",\"\\\"all\\\" condition value must be an array of conditions\")for x,r in ipairs(j)do local y=k:parseCondition(r)j[x]=y end end,init=function(j,t)for x,r in ipairs(j)do j[x]=w.condition.new(r,t)end end,delete=function(j,t)for q,z in ipairs(j)do w.condition.delete(z,t)end end},{__jsonval=function(self)return{all=self.data}end})w.condition.add({\"true\",\"false\"},{parse=function(j,k)end},{__jsonval=function(self)return self.condition end})w.condition.add(\"tag-check\",{parse=function(j,k)k:assert_type(j,\"string\",\"\\\"tag-check\\\" value must be a string\")return k:parseInterpolatedString(j)end,init=function(j)a.call(\"string\",\"create\",j)end,delete=function(j)a.call(\"string\",\"delete\",j)end},{__jsonval=function(self)return{[\"tag-check\"]=self.data.string}end})w.condition.add(\"match\",{parse=function(j,k)k:assert_jsontype(j,\"array\",\"\\\"match\\\" value must be an array of strings\")for x,r in ipairs(j)do k:assert_jsontype(r,\"string\",\"\\\"match\\\" value must be an array of strings\")j[x]=k:parseInterpolatedString(r)end end,init=function(j)local A=function(c)local B=0;for q in c.string:gmatch(\"%$\")do B=B+1 end;return B end;local C=function(D,E)return A(D)<A(E)end;table.sort(j,C)for q,c in ipairs(j)do a.call(\"string\",\"create\",c)end end,delete=function(j)for q,c in ipairs(j)do a.call(\"string\",\"delete\",c)end end},{__jsonval=function(self)local F={}for q,c in ipairs(self.data)do table.insert(F,c.string)end;return{match=F}end})local G={__jsonorder={\"name\",\"key\",\"increment\"}}w.condition.add({\"limit-break\",\"limit-check\"},{parse=function(j,k)if type(j)==\"string\"then j={name=j}elseif type(j)~=\"table\"then k:error(\"invalid value type %s\",type(j))end;local H=next(k:getContext())local I=k:getContext(\"rule\")if not j.key then j.key=I.key end;k:assert(j.key,\"limiter \\\"key\\\" missing, and no default \\\"key\\\" in rule\")k:assert_type(j.key,\"string\",\"invalid limiter \\\"key\\\" type\")j.key=k:parseInterpolatedString(j.key)if not j.increment then if H==\"limit-break\"then j.increment=1 elseif H==\"limit-check\"then j.increment=0 end end;j.increment=k:assert(tonumber(j.increment),\"invalid or empty \\\"increment\\\" value\")k:assert(j.increment>=0,\"\\\"increment\\\" must be >= 0\")k:assert(j.name,\"name missing\")k:assert_type(j.name,\"string\",\"invalid \\\"name\\\" type\")return j end,init=function(j,n,t)local J=assert(t:findLimiter(j.name),\"unknown limiter\")j.name=nil;j.limiter=J;if j.key then a.call(\"string\",\"create\",j.key)end end,delete=function(j)if j.key then a.call(\"string\",\"delete\",j.key)end end},{__jsonval=function(self)local K={}for L,r in pairs(self.data)do K[L]=r end;if K.derived_key then K.derived_key=nil;K.key=nil elseif K.key then K.key=K.key.string end;K.name=K.limiter.name;K.limiter=nil;setmetatable(K,G)local M={[self.condition]=K}return M end})w.condition.add(\".delay\",{parse=function(j,k)k:assert_jsontype(j,\"number\",\"delay by <number> please\")end})w.action.add(\"tag\",{parse=function(j,k)k:assert_jsontype(j,\"string\",\"\\\"tag\\\" value must be a string\")return k:parseInterpolatedString(j)end,init=function(j)a.call(\"string\",\"create\",j)end,delete=function(j)a.call(\"string\",\"delete\",j)end},{__jsonval=function(self)return{tag=self.data.string}end})w.action.add(\"accept\",{parse=function(j,k)k:assert_type(j,\"table\",\"\\\"accept\\\" value must be an object\")k:assert_table_size(j,0,\"\\\"accept\\\" value must be empty\")end})w.action.add(\"reject\",{parse=function(j,k)k:assert_type(j,\"table\",\"\\\"reject\\\" value must be an object\")end})w.action.add(\"wait\",{parse=function(j,k)k:assert_jsontype(j,\"number\",\"\\\"wait\\\" value must be a number\")end})return w\n"
   "\n"
   "end)\n"
   "\n"
   "module(\"ruleset\", function()\n"
   "local a=require\"rule\"local b=require\"binding\"or{call=function()end}local c=require\"dkjson\"local d=function(e)local f={}for g,h in pairs(e)do f[g]=h end;return setmetatable(f,getmetatable(e))end;local function i(j,e,k)assert(k.name,(\"a %s must have a name\"):format(j))assert(not e[k.name],(\"%s \\\"%s\\\" already exists\"):format(j,k.name))end;local function l(m)if type(m)==\"string\"then return m elseif type(m)==\"table\"then return m.name else return m end end;local function n(e,o)local f={}setmetatable(f,getmetatable(e))for g,h in pairs(e)do if not o[g]then f[g]=h end end;return f end;local p={__index={type=\"ruleset\",findLimiter=function(self,q)return self.limiters[l(q)]end,addLimiter=function(self,k,r)if k.__already_loaded_as_burst_limiter then k.__already_loaded_as_burst_limiter=nil;return nil end;i(\"limiter\",self.limiters,k)local s=setmetatable(k,self.__submeta.limiter)self.limiters[k.name]=s;if s.burst then local t=self:findLimiter(s.burst)if not t then t=self:addLimiter(r[s.burst],r)r[s.burst].__already_loaded_as_burst_limiter=true;s.burst=t end end;b.call(\"limiter\",\"create\",s)return s end,deleteLimiter=function(self,s)assert(self.limiters[s.name]==s,\"tried deleting unexpected list of the same name\")self.limiters[s.name]=nil;b.call(\"limiter\",\"delete\",s)end,findRule=function(self,q)return self.rules[l(q)]end,addRule=function(self,k)if not k.name then k.name=self:uniqueName(self.rules,\"rule\")else i(\"rule\",self.rules,k)end;local u=setmetatable(k,self.__submeta.rule)u.ruleset=nil;if k[\"if\"]then k[\"if\"]=a.condition.new(u[\"if\"],self)end;for v,w in pairs{\"then\",\"else\"}do if k[w]then local x={}for v,h in pairs(k[w])do table.insert(x,a.action.new(h,self))end;k[w]=x end end;self.rules[k.name]=u;b.call(\"rule\",\"create\",u)return u end,deleteRule=function(self,u)assert(self.rules[u.name]==u,\"tried deleting unexpected list of the same name\")for y,z in pairs(self.lists)do for v,A in ipairs(z)do assert(A~=u,(\"can't delete rule \\\"%s\\\", it's used in list \\\"%s\\\"\"):format(u.name,y))end end;self.rules[u.name]=nil;if u[\"if\"]then a.condition.delete(u[\"if\"],self)end;for v,w in pairs{\"then\",\"else\"}do if u[w]then local x=u[w]for v,B in pairs(x)do a.action.delete(B,self)end;u[w]={}end end;b.call(\"rule\",\"delete\",u)end,findList=function(self,q)return self.lists[l(q)]end,addList=function(self,k)if not k.name then k.name=self:uniqueName(self.lists,\"list\")else i(\"list\",self.lists,k)end;for C,D in ipairs(k.rules)do k.rules[C]=self:findRule(D.name)or self:addRule(D)end;local z=setmetatable(k,self.__submeta.list)self.lists[k.name]=z;b.call(\"list\",\"create\",z)return z end,deleteList=function(self,z)assert(self.lists[z.name]==z,\"tried deleting unexpected list of the same name\")for E,F in pairs(self.phases)do for v,G in ipairs(F)do assert(G~=z,(\"can't delete list \\\"%s\\\", it's used in phase \\\"%s\\\"\"):format(z.name,E))end end;self.lists[z.name]=nil;b.call(\"list\",\"delete\",z)end,setPhaseTable=function(self,k)if self.phases then for v,F in pairs(self.phases)do b.call(\"phase\",\"delete\",F)end end;self.phases={}for g,h in pairs(k)do local F=setmetatable({name=g,lists={}},self.__submeta.phase)for C,z in pairs(h)do F.lists[C]=self:findList(z)or self:addList(z)end;self.phases[g]=F;b.call(\"phase\",\"create\",F)end;return self.phases end,uniqueName=function(self,H,I)if not self.__n then self.__n=0 else self.__n=self.__n+1 end;local q=(\"%s%i\"):format(I,self.__n)if H[q]then return self:uniqueName(H,I)else return q end end,toJSON=function(self)local J={name=self.name,info=self.info,rules=d(self.rules),lists=d(self.lists),limiters=d(self.limiters),phases=self.phases}setmetatable(J,self.__submeta.ruleset)local K={name=true}for v,L in ipairs({\"rules\",\"lists\",\"limiters\",\"phases\"})do local M=J[L]or{}for g,m in pairs(M)do M[g]=n(m,K)end end;return c.encode(J,{indent=true})end,destroy=function(self)self:setPhaseTable({})for v,z in pairs(self.lists)do self:deleteList(z)end;for v,u in pairs(self.rules)do self:deleteRule(u)end;for v,s in pairs(self.limiters)do self:deleteLimiter(s)end;b.call(\"ruleset\",\"delete\",self)end}}local function N(e)local O={}for g in pairs(e)do table.insert(O,g)end;table.sort(O)return O end;local function P(k)local Q=setmetatable({rules=setmetatable({},{__jsonorder=N}),lists=setmetatable({},{__jsonorder=N}),limiters=setmetatable({},{__jsonorder=N}),phases={},name=k and k.name or nil},p)Q.__submeta={ruleset={__jsonorder={\"name\",\"info\",\"phases\",\"limiters\",\"lists\",\"rules\"}},phase={__jsonval=function(self)local R={}for v,z in pairs(self.lists)do table.insert(R,z.name)end;return R end},list={__jsonorder={\"name\",\"info\",\"rules\"},__jsonval=function(self)local S={}for v,u in pairs(self.rules)do table.insert(S,u.name)end;if self.info then return setmetatable({info=self.info,rules=S},getmetatable(self))else return setmetatable(S,getmetatable(self))end end},rule={__jsonorder={\"name\",\"info\",\"key\",\"if\",\"if-any\",\"if-all\",\"then\",\"else\"},__jsonval=function(self)if#self[\"else\"]==0 or#self[\"then\"]==0 or self.key then local T=d(self)if#self[\"then\"]==0 then T[\"then\"]=nil end;if#self[\"else\"]==0 then T[\"else\"]=nil end;if self.key then self.key=self.key.string end;return T end;return self end},limiter={__jsonorder={\"name\",\"info\",\"limit\",\"interval\",\"burst\",\"burst-expire\"},__jsonval=function(self)if self.burst then local f=d(self)f.burst=f.burst[\"name\"]return f end;return self end}}if not Q.name then Q.name=Q:uniqueName({},\"ruleset\")end;if k then for v,h in pairs(k.limiters)do Q:addLimiter(h,k.limiters)end;for v,h in pairs(k.rules)do Q:addRule(h)end;for v,h in pairs(k.lists)do Q:addList(h)end;Q:setPhaseTable(k.phases)end;b.call(\"ruleset\",\"create\",Q)return Q end;local U={new=P}return U\n"
   "\n"
   "end)\n"
   "\n"
   "\n"
   "return main()\n"}
};
const int wfx_redis_lua_scripts_count=4;
