#include <ngx_wafflex_redis_lua_scripts.h>

wfx_redis_lua_scripts_t wfx_redis_lua_scripts = {
  {"init", "4f7d624f703483b37d89af715d7230c2ea24a95c",
   "\n"
   "--luacheck: globals redis\n"
   "\n"
   "redis.echo(\"hi there\")\n"
   "return \"hello\"\n"},

  {"ruleset_read", "45d6e33a6842284b2adf7d969beb2b80bd53061f",
   "--[[autogenerated script, do not edit]] local require, module; local function main()   --main script\n"
   "  --luacheck: globals redis cjson ARGV\n"
   "  local prefix =        ARGV[1]\n"
   "  local ruleset_name =  ARGV[2]\n"
   "  local item =          ARGV[3]\n"
   "  local item_name =     ARGV[4]\n"
   "  \n"
   "  local get_ruleset_thing = require(\"ruleset_read\")\n"
   "  \n"
   "  return assert(get_ruleset_thing(prefix, ruleset_name, item, item_name, true))\n"
   "\n"
   "end\n"
   "do\n"
   "  local modules = {}\n"
   "  module = function(name, fn) modules[name]=fn() end\n"
   "  require = function(name) return modules[name] end\n"
   "end\n"
   "--luacheck: ignore\n"
   "\n"
   "module(\"ruleset_read\", function()\n"
   "  \n"
   "  --luacheck: globals redis cjson\n"
   "  \n"
   "  local encode = cjson.encode\n"
   "  local decode = cjson.decode\n"
   "  local tinsert = table.insert\n"
   "  \n"
   "  local Jsonobj; do\n"
   "    local Jmeta = {__index = {\n"
   "      use = function(self, ...)\n"
   "        for _, k in ipairs {...} do\n"
   "          local val\n"
   "          if type(k) == \"table\" then\n"
   "            val = k[2](self.data[k[1]])\n"
   "            k = k[1]\n"
   "          else\n"
   "            val = self.data[k]\n"
   "          end\n"
   "          self:add(k, val)\n"
   "        end\n"
   "      end,\n"
   "      useRaw = function(self, ...)\n"
   "        for _, k in ipairs {...} do\n"
   "          self:addRaw(k, self.data[k])\n"
   "        end\n"
   "      end,\n"
   "      add = function(self, key, data, raw)\n"
   "        if data == nil then return end\n"
   "        if not raw then data = encode(data) end\n"
   "        tinsert(self.buf, (\"%s: %s\"):format(encode(key), data))\n"
   "      end,\n"
   "      addRaw = function(self, key, data)\n"
   "        return self:add(key, data, true)\n"
   "      end,\n"
   "      json = function(self)\n"
   "        return (\"{ %s }\"):format(table.concat(self.buf, \", \\n\"))\n"
   "      end\n"
   "    }}\n"
   "    Jsonobj = function(data)\n"
   "      return setmetatable({buf={}, data=data or {}}, Jmeta)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local kbase, key, keyf, current_ruleset_name, current_prefix\n"
   "  local function genkeys(prefix, ruleset_name)\n"
   "    if current_ruleset_name == ruleset_name and current_prefix == prefix then return end\n"
   "    kbase = (\"%sruleset:%s\"):format(prefix, ruleset_name)\n"
   "    key = {\n"
   "      rulesets = prefix..\"rulesets\",\n"
   "      ruleset =  kbase,\n"
   "      phases =   kbase..\":phases\",\n"
   "      lists =    kbase..\":lists\",\n"
   "      rules =    kbase..\":rules\",\n"
   "      limiters = kbase..\":limiters\"\n"
   "    }\n"
   "    keyf = {\n"
   "      list =         key.ruleset..\":list:%s\",\n"
   "      list_rules =   key.ruleset..\":list:%s:rules\",\n"
   "      list_refs =    key.ruleset..\":list:%s:refs\",\n"
   "      \n"
   "      rule =         key.ruleset..\":rule:%s\",\n"
   "      rule_refs =    key.ruleset..\":rule:%s:refs\",\n"
   "      \n"
   "      limiter =      key.ruleset..\":limiter:%s\",\n"
   "      limiter_refs = key.ruleset..\":limiter:%s:refs\",\n"
   "      \n"
   "      phase =        key.ruleset..\":phase:%s\",\n"
   "      phase_lists =  key.ruleset..\":phase:%s:lists\"\n"
   "    }\n"
   "    current_prefix = prefix\n"
   "    current_ruleset_name = ruleset_name\n"
   "  end\n"
   "  \n"
   "  local function redis_gethash(redis_key)\n"
   "    local res = redis.call(\"HGETALL\", redis_key)\n"
   "    if type(res)~=\"table\" then return nil end\n"
   "    local h, k = {}, nil\n"
   "    for _, v in ipairs(res) do\n"
   "      if k == nil then k=v\n"
   "      else h[k]=v; k=nil end\n"
   "    end\n"
   "    return h\n"
   "  end\n"
   "  \n"
   "  local function get_thing(prefix, ruleset_name, item, item_name, want_json, incomplete)\n"
   "    genkeys(prefix, ruleset_name)\n"
   "    local j\n"
   "    if item == \"rule\" then\n"
   "      local rule = redis_gethash(keyf.rule:format(item_name))\n"
   "      if not rule then return nil end\n"
   "      if want_json then\n"
   "        j = Jsonobj(rule)\n"
   "        j:use(\"name\",\"info\",{\"gen\", tonumber}, \"key\")\n"
   "        j:useRaw(\"if\", \"then\", \"else\")\n"
   "        return j:json()\n"
   "      else\n"
   "        for _, k in ipairs{\"if\", \"then\", \"else\"} do\n"
   "          if rule[k] then rule[k]=decode(rule[k]) end\n"
   "        end\n"
   "        rule.gen = tonumber(rule.gen)\n"
   "        return rule\n"
   "      end\n"
   "    elseif item == \"limiter\" then\n"
   "      local lim = redis_gethash(keyf.limiter:format(item_name))\n"
   "      if not lim then return nil end\n"
   "      if want_json then\n"
   "        j = Jsonobj(lim)\n"
   "        j:use(\"name\",\"info\", {\"gen\", tonumber}, {\"interval\", tonumber}, {\"limit\", tonumber}, {\"sync-steps\", tonumber}, \"burst\", {\"burst-expire\", tonumber})\n"
   "        return j:json()\n"
   "      else\n"
   "        lim.gen = tonumber(lim.gen)\n"
   "        lim.interval = tonumber(lim.interval)\n"
   "        lim.limit = tonumber(lim.limit)\n"
   "        lim[\"sync-steps\"] = tonumber(lim[\"sync-steps\"])\n"
   "        lim[\"burst-expire\"] = tonumber(lim[\"burst-expire\"])\n"
   "        return lim\n"
   "      end\n"
   "    elseif item == \"list\" then\n"
   "      local list = redis_gethash(keyf.list:format(item_name))\n"
   "      if not list then return nil end\n"
   "      if want_json then\n"
   "        j = Jsonobj(list)\n"
   "        j:use(\"name\",\"info\",{\"gen\", tonumber})\n"
   "        local ll = redis.call(\"LRANGE\", keyf.list_rules:format(item_name), 0, -1)\n"
   "        if ll and #ll > 0 then\n"
   "          j:add(\"rules\", ll)\n"
   "        else\n"
   "          j:addRaw(\"rules\", \"[]\")\n"
   "        end\n"
   "        return j:json()\n"
   "      else\n"
   "        list.gen = tonumber(list.gen)\n"
   "        if not incomplete then\n"
   "          list.rules = redis.call(\"LRANGE\", keyf.list_rules:format(item_name), 0, -1)\n"
   "        else\n"
   "          list.incomplete = true\n"
   "          list.external = true\n"
   "        end\n"
   "        return list\n"
   "      end\n"
   "    elseif item == \"phase\" then\n"
   "      local ll = redis.call(\"LRANGE\", keyf.phase_lists:format(item_name), 0, -1)\n"
   "      if want_json then\n"
   "        return #ll > 0 and encode(ll) or \"[]\"\n"
   "      else\n"
   "        return ll\n"
   "      end\n"
   "    elseif item == \"ruleset\" then\n"
   "      local rs = redis_gethash(key.ruleset)\n"
   "      if not rs then return nil end\n"
   "      \n"
   "      rs.gen = tonumber(rs.gen)\n"
   "      \n"
   "      local function add_ruleset_items(the_item, items_set_key, attribute)\n"
   "        local member_names = redis.call(\"SMEMBERS\", items_set_key)\n"
   "        \n"
   "        if want_json then\n"
   "          local jj = Jsonobj()\n"
   "          table.sort(member_names)\n"
   "          for _, n in ipairs(member_names) do\n"
   "            jj:addRaw(n, get_thing(prefix, ruleset_name, the_item, n, want_json, incomplete))\n"
   "          end\n"
   "          j:addRaw(attribute, jj:json())\n"
   "        else\n"
   "          local members = {}\n"
   "          for _, n in ipairs(member_names) do\n"
   "            members[n]=get_thing(prefix, ruleset_name, the_item, n, want_json, incomplete)\n"
   "          end\n"
   "          rs[attribute]=members\n"
   "        end\n"
   "      end\n"
   "      \n"
   "      if want_json then\n"
   "        j = Jsonobj(rs)\n"
   "        j:use(\"name\",\"info\",{\"gen\", tonumber})\n"
   "      end\n"
   "        \n"
   "      add_ruleset_items(\"limiter\", key.limiters, \"limiters\")\n"
   "      add_ruleset_items(\"phase\", key.phases, \"phases\")\n"
   "      add_ruleset_items(\"list\", key.lists, \"lists\")\n"
   "      add_ruleset_items(\"rule\", key.rules, \"rules\")\n"
   "        \n"
   "      return want_json and j:json() or rs\n"
   "      \n"
   "    else\n"
   "      error(\"unknown thing we want here: \" .. tostring(item))\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  return get_thing\n"
   "\n"
   "end)\n"
   "\n"
   "\n"
   "return main()\n"},

  {"ruleset_write", "2f36cdd430614c1976893d715a48aa1a9c9c722a",
   "--[[autogenerated script, do not edit]] local require, module; local function main()   local Parser = require \"parser\"\n"
   "  local Ruleset = require \"ruleset\"\n"
   "  local Binding = require \"binding\"\n"
   "  local inspect = require \"inspect\"\n"
   "  local ruleset_read = require \"ruleset_read\"\n"
   "  \n"
   "  --luacheck: globals redis cjson ARGV unpack\n"
   "  local hmm = function(thing)\n"
   "    local out = inspect(thing)\n"
   "    for line in out:gmatch('[^\\r\\n]+') do\n"
   "      redis.call(\"ECHO\", line)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  Ruleset.RuleComponent.generate_refs = true\n"
   "  \n"
   "  local tunpack = table.unpack or unpack\n"
   "  local function redis_hmset(key, tbl, ...)\n"
   "    local flat = {}\n"
   "    for _, k in ipairs{...} do\n"
   "      if tbl[k] then\n"
   "        table.insert(flat, k)\n"
   "        table.insert(flat, tbl[k])\n"
   "      end\n"
   "    end\n"
   "    if #flat > 0 then\n"
   "      redis.call(\"HMSET\", key, tunpack(flat))\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function redis_gethash(redis_key)\n"
   "    local res = redis.call(\"HGETALL\", redis_key)\n"
   "    if type(res)~=\"table\" then return nil end\n"
   "    local h, k = {}, nil\n"
   "    for _, v in ipairs(res) do\n"
   "      if k == nil then k=v\n"
   "      else h[k]=v; k=nil end\n"
   "    end\n"
   "    return h\n"
   "  end\n"
   "  \n"
   "  local function table_keys(tbl)\n"
   "    local keys = {}\n"
   "    for k, _ in pairs(tbl) do\n"
   "      table.insert(keys, k)\n"
   "    end\n"
   "    return keys\n"
   "  end\n"
   "  \n"
   "  --[[local function tcopy(tbl)\n"
   "    local cpy = {}\n"
   "    for k, v in pairs(tbl) do\n"
   "      cpy[k]=v\n"
   "    end\n"
   "    return cpy\n"
   "  end\n"
   "  ]]\n"
   "  local nextarg; do local n = 0; nextarg = function(how_many)\n"
   "    local ret = {}; how_many = how_many or 1;\n"
   "    for i=1,how_many do ret[i]=ARGV[n+i] or false end\n"
   "    n = n + how_many\n"
   "    return tunpack(ret)\n"
   "  end; end\n"
   "  \n"
   "  local prefix, action, item, ruleset_name = nextarg(4)\n"
   "  prefix = #prefix>0 and prefix .. \":\" or \"\"\n"
   "  \n"
   "  local kbase, key, keyf;\n"
   "  local function genkeys(new_ruleset_name)\n"
   "    kbase = (\"%sruleset:%s\"):format(prefix, new_ruleset_name)\n"
   "    key = {\n"
   "      scripts =  \"wafflex:scripts\",\n"
   "      rulesets = prefix..\"rulesets\",\n"
   "      ruleset =  kbase,\n"
   "      ruleset_pubsub = kbase..\":pubsub\",\n"
   "      phases =   kbase..\":phases\",\n"
   "      lists =    kbase..\":lists\",\n"
   "      rules =    kbase..\":rules\",\n"
   "      limiters = kbase..\":limiters\",\n"
   "    }\n"
   "    keyf = {\n"
   "      list =         key.ruleset..\":list:%s\",\n"
   "      list_rules =   key.ruleset..\":list:%s:rules\",\n"
   "      list_refs =    key.ruleset..\":list:%s:refs\",\n"
   "      \n"
   "      rule =         key.ruleset..\":rule:%s\",\n"
   "      rule_refs =    key.ruleset..\":rule:%s:refs\",\n"
   "      \n"
   "      limiter =      key.ruleset..\":limiter:%s\",\n"
   "      limiter_refs = key.ruleset..\":limiter:%s:refs\",\n"
   "      limiter_pubsub=key.ruleset..\":limiter:%s:pubsub\",\n"
   "      \n"
   "      phase =        key.ruleset..\":phase:%s\",\n"
   "      phase_lists =  key.ruleset..\":phase:%s:lists\"\n"
   "    }\n"
   "  end\n"
   "  genkeys(ruleset_name)\n"
   "  \n"
   "  local function publish(action_name, thing_type, thing_name, thing_data)\n"
   "    local msg = {\n"
   "      action = action_name,\n"
   "      type = thing_type,\n"
   "      name = thing_name,\n"
   "      data = thing_data\n"
   "    }\n"
   "    \n"
   "    assert(action_name == \"create\" or action_name == \"update\" or action_name == \"delete\", \"publish: invalid action \" .. action_name)\n"
   "    assert(thing_type == \"ruleset\" or thing_type == \"phase\" or thing_type == \"limiter\" or thing_type == \"list\" or thing_type == \"rule\", \"publish: invalid thing type \" .. thing_type)\n"
   "    \n"
   "    redis.call(\"PUBLISH\", key.ruleset_pubsub, cjson.encode(msg))\n"
   "  end\n"
   "  \n"
   "  Ruleset.uniqueName = function(thing, thingtbl, ruleset)\n"
   "    local name, thing_key, n, set_key\n"
   "    if thing == \"ruleset\" then\n"
   "      thing_key = prefix .. \"rulesets:n\"\n"
   "      set_key = key.rulesets\n"
   "    else\n"
   "      thing_key = (prefix .. \"ruleset:\" .. ruleset.name)\n"
   "      if     thing == \"phase\" then\n"
   "        set_key = key.phases\n"
   "      elseif thing == \"list\" then\n"
   "        set_key = key.lists\n"
   "      elseif thing == \"rule\" then\n"
   "        set_key = key.rules\n"
   "      elseif thing == \"limiter\" then\n"
   "        set_key = key.limiters\n"
   "      end\n"
   "    end\n"
   "    n = redis.call(\"HINCRBY\", thing_key, thing .. \":n\", 1)\n"
   "    name = (\"%s%i\"):format(thing, n)\n"
   "    \n"
   "    if redis.call(\"SISMEMBER\", set_key, name) == 1 then --already exists\n"
   "      return Ruleset.uniqueName(thing, thingtbl, ruleset)\n"
   "    elseif thingtbl and thingtbl[name] then -- also already exists\n"
   "      return Ruleset.uniqueName(thing, thingtbl, ruleset)\n"
   "    else\n"
   "      if thing == \"ruleset\" then genkeys(name) end\n"
   "      return name\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local limiter_created = {} --needed because limiters can reference other limiters\n"
   "  Binding.set(\"limiter\", {\n"
   "    create = function(limiter)\n"
   "      if limiter.external then return end\n"
   "      if limiter_created[limiter.name] then return end\n"
   "      local lkey = keyf.limiter:format(limiter.name)\n"
   "      if redis.call(\"EXISTS\", lkey) == 1 then error(\"limiter \\\"\" .. limiter.name .. \"\\\" already exists\") end\n"
   "      limiter.gen = 0\n"
   "      redis_hmset(lkey, limiter, \"name\", \"info\", \"gen\", \"interval\", \"limit\", \"sync-steps\", \"burst-expire\")\n"
   "      if limiter.burst then\n"
   "        redis.call(\"HSET\", lkey, \"burst\", limiter.burst.name)\n"
   "      end\n"
   "      redis.call(\"SADD\", key.limiters, limiter.name)\n"
   "      \n"
   "      if limiter.burst then\n"
   "        redis.call(\"ZINCRBY\", keyf.limiter_refs:format(limiter.burst.name), 1, \"limiter:\"..limiter.name)\n"
   "      end\n"
   "      \n"
   "      limiter_created[limiter.name]=true\n"
   "    end,\n"
   "    update = function(limiter, diff)\n"
   "      local lkey = keyf.limiter:format(limiter.name)\n"
   "      if redis.call(\"EXISTS\", lkey) == 0 then error(\"limiter \\\"\" .. limiter.name .. \"\\\" does not exist\") end\n"
   "      \n"
   "      assert(not diff.name, \"don't know how to rename limiters yet\")\n"
   "      \n"
   "      limiter.gen = tonumber(limiter.gen or 0) + 1\n"
   "      diff.gen = true\n"
   "      \n"
   "      if diff.burst then\n"
   "        redis.call(\"ZINCRBY\", keyf.limiter_refs:format(diff.burst.old.name), -1, \"limiter:\"..limiter.name)\n"
   "        redis.call(\"ZREMRANGEBYSCORE\", keyf.limiter_refs:format(diff.burst.old.name), \"-inf\", 0)\n"
   "        redis.call(\"ZINCRBY\", keyf.limiter_refs:format(diff.burst.new.name), 1, \"limiter:\"..limiter.name)\n"
   "      end\n"
   "      \n"
   "      redis_hmset(lkey, limiter, table_keys(diff))\n"
   "    end,\n"
   "    delete = function(limiter)\n"
   "      local lkey = keyf.limiter:format(limiter.name)\n"
   "      if redis.call(\"EXISTS\", lkey) == 0 then error(\"limiter \\\"\" .. limiter.name .. \"\\\" does not exist\") end\n"
   "      if redis.call(\"ZCARD\", keyf.limiter_refs:format(limiter.name)) > 0 then error(\"limiter \\\"\" .. limiter.name .. \"\\\" still in use\") end\n"
   "      \n"
   "      if limiter.burst then\n"
   "        redis.call(\"ZINCRBY\", keyf.limiter_refs:format(limiter.burst.name), -1, \"limiter:\"..limiter.name)\n"
   "        redis.call(\"ZREMRANGEBYSCORE\", keyf.limiter_refs:format(limiter.burst.name), \"-inf\", 0)\n"
   "      end\n"
   "      redis.call(\"SREM\", key.limiters, limiter.name)\n"
   "      redis.call(\"DEL\", lkey)\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Binding.set(\"list\", {\n"
   "    create = function(list)\n"
   "      if list.external then return end\n"
   "      local lkey = keyf.list:format(list.name)\n"
   "      if redis.call(\"EXISTS\", lkey) == 1 then error(\"list \\\"\" .. list.name .. \"\\\" already exists\") end\n"
   "      list.gen = 0\n"
   "      redis_hmset(lkey, list, \"name\", \"info\", \"gen\")\n"
   "      \n"
   "      local list_rules_key = keyf.list_rules:format(list.name)\n"
   "      local list_ref = \"list:\"..list.name\n"
   "      for _, rule in ipairs(list.rules) do\n"
   "        redis.call(\"RPUSH\", list_rules_key, rule.name)\n"
   "        redis.call(\"ZINCRBY\", keyf.rule_refs:format(rule.name), 1, list_ref)\n"
   "      end\n"
   "      \n"
   "      redis.call(\"SADD\", key.lists, list.name)\n"
   "    end,\n"
   "    update = function(list, diff)\n"
   "      local lkey = keyf.list:format(list.name)\n"
   "      if redis.call(\"EXISTS\", lkey) == 0 then error(\"list \\\"\" .. list.name .. \"\\\" does not exist\") end\n"
   "      list.gen = tonumber(list.gen or 0) + 1\n"
   "      diff.gen = true\n"
   "      \n"
   "      assert(not diff.name, \"don't know how to rename lists yet\")\n"
   "      \n"
   "      if diff.rules then\n"
   "        local list_rules_key = keyf.list_rules:format(list.name)\n"
   "        local list_ref = \"list:\"..list.name\n"
   "        redis.call(\"DEL\", list_rules_key)\n"
   "        for _, rule in ipairs(diff.rules.old) do\n"
   "          local rule_refs_key = keyf.rule_refs:format(rule.name)\n"
   "          redis.call(\"ZINCRBY\", rule_refs_key, -1, list_ref)\n"
   "          redis.call(\"ZREMRANGEBYSCORE\", rule_refs_key, \"-inf\", 0)\n"
   "        end\n"
   "        \n"
   "        for _, rule in ipairs(diff.rules.old) do\n"
   "          redis.call(\"RPUSH\", list_rules_key, rule.name)\n"
   "          redis.call(\"SADD\", keyf.rule_refs:format(rule.name), list_ref)\n"
   "        end\n"
   "        \n"
   "        --redis.call(\"ZREMRANGEBYSCORE\", list_refs_key, \"-inf\" 0)\n"
   "        diff.rules = nil\n"
   "      end\n"
   "      \n"
   "      redis_hmset(lkey, list, table_keys(diff))\n"
   "    end,\n"
   "    delete = function(list)\n"
   "      local lkey = keyf.list:format(list.name)\n"
   "      local list_refs_key = keyf.list_refs:format(list.name)\n"
   "      if redis.call(\"EXISTS\", lkey) == 0 then error(\"list \\\"\" .. list.name .. \"\\\" does not exist\") end\n"
   "      if redis.call(\"ZCARD\", list_refs_key) ~= 0 then error(\"list \\\"\" .. list.name .. \"\\\" is still in use\") end\n"
   "      \n"
   "      local list_rules_key = keyf.list_rules:format(list.name)\n"
   "      local list_ref = \"list:\"..list.name\n"
   "      \n"
   "      for _, rule_name in ipairs(redis.call(\"LRANGE\", list_rules_key, 0, -1)) do\n"
   "        local rule_refs_key = keyf.rule_refs:format(rule_name)\n"
   "        redis.call(\"ZINCRBY\", rule_refs_key, -1, list_ref)\n"
   "        redis.call(\"ZREMRANGEBYSCORE\", rule_refs_key, \"-inf\", 0)\n"
   "      end\n"
   "      \n"
   "      redis.call(\"SREM\", key.lists, list.name)\n"
   "      redis.call(\"DEL\", lkey, list_rules_key, list_refs_key)\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Binding.set(\"phase\", {\n"
   "    create = function(phase)\n"
   "      if phase.external then return end\n"
   "      local pkey = keyf.phase:format(phase.name)\n"
   "      if redis.call(\"EXISTS\", pkey) == 1 then error(\"phase \\\"\" .. phase.name .. \"\\\" already exists\") end\n"
   "      phase.gen = 0\n"
   "      redis_hmset(pkey, phase, \"name\", \"info\", \"gen\")\n"
   "      \n"
   "      local phase_lists_key = keyf.phase_lists:format(phase.name)\n"
   "      local phase_ref = \"phase:\"..phase.name\n"
   "      for _, list in ipairs(phase.lists) do\n"
   "        redis.call(\"RPUSH\", phase_lists_key, list.name)\n"
   "        redis.call(\"ZINCRBY\", keyf.list_refs:format(list.name), 1, phase_ref)\n"
   "      end\n"
   "      \n"
   "      redis.call(\"SADD\", key.phases, phase.name)\n"
   "    end,\n"
   "    update = function(phase, diff)\n"
   "      phase.gen = tonumber(phase.gen or 0) + 1\n"
   "      diff.gen = true\n"
   "      assert(not diff.name, \"don't know how to rename phases yet\")\n"
   "      \n"
   "      local pkey = keyf.phase:format(phase.name)\n"
   "      local phase_ref = \"phase:\"..phase.name\n"
   "      \n"
   "      if diff.lists then\n"
   "        local phase_lists_key = keyf.phase_lists:format(phase.name)\n"
   "        local list_refs_key\n"
   "        for _, list_name in ipairs(redis.call(\"LRANGE\", phase_lists_key, 0, -1)) do\n"
   "          list_refs_key = keyf.list_refs:format(list_name)\n"
   "          redis.call(\"ZINCRBY\", list_refs_key, -1, phase_ref)\n"
   "          redis.call(\"ZREMRANGEBYSCORE\", list_refs_key, \"-inf\", 0)\n"
   "        end\n"
   "        redis.call(\"DEL\", phase_lists_key)\n"
   "        \n"
   "        for _, list in ipairs(diff.lists.new) do\n"
   "          list_refs_key = keyf.list_refs:format(list.name)\n"
   "          redis.call(\"RPUSH\", phase_lists_key, list.name)\n"
   "          redis.call(\"ZINCRBY\", list_refs_key, 1, phase_ref)\n"
   "        end\n"
   "        diff.lists = nil\n"
   "      end\n"
   "      \n"
   "      redis_hmset(pkey, phase, table_keys(diff))\n"
   "    end,\n"
   "    delete = function(phase)\n"
   "      local pkey = keyf.phase:format(phase.name)\n"
   "      local phase_ref = \"phase:\"..phase.name\n"
   "      \n"
   "      local phase_lists_key = keyf.phase_lists:format(phase.name)\n"
   "      local list_refs_keys\n"
   "      for _, list_name in ipairs(redis.call(\"LRANGE\", phase_lists_key, 0, -1)) do\n"
   "        list_refs_keys = keyf.list_refs:format(list_name)\n"
   "        redis.call(\"ZINCRBY\", list_refs_keys, -1, phase_ref)\n"
   "        redis.call(\"ZREMRANGEBYSCORE\", list_refs_keys, \"-inf\", 0)\n"
   "      end\n"
   "      \n"
   "      redis.call(\"SREM\", key.phases, phase.name)\n"
   "      redis.call(\"DEL\", pkey, phase_lists_key)\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Binding.set(\"rule\", {\n"
   "    create = function(rule)\n"
   "      if rule.external then return end\n"
   "      local rkey = keyf.rule:format(rule.name)\n"
   "      if redis.call(\"EXISTS\", rkey) == 1 then error(\"rule \\\"\" .. rule.name .. \"\\\" already exists\") end\n"
   "      rule.gen = 0\n"
   "      redis_hmset(rkey, rule, \"name\", \"info\", \"gen\", \"key\")\n"
   "      redis.call(\"HSET\", rkey, \"if\", rule[\"if\"]:toJSON())\n"
   "      if rule[\"then\"] then\n"
   "        redis.call(\"HSET\", rkey, \"then\", rule[\"then\"]:toJSON())\n"
   "      end\n"
   "      if rule[\"else\"] then\n"
   "        redis.call(\"HSET\", rkey, \"else\", rule[\"else\"]:toJSON())\n"
   "      end\n"
   "      if rule.refs then\n"
   "        local rule_ref = \"rule:\"..rule.name\n"
   "        for ref, _ in pairs(rule.refs) do\n"
   "          local ref_type, ref_name = ref:match \"([^:]+):(.+)\"\n"
   "          local refkeyf = assert(keyf[ref_type .. \"_refs\"], \"keyf \\\"\" .. tostring(ref_type)..\"_refs\" .. \"\\\" missing \" .. inspect(keyf))\n"
   "          redis.call(\"ZINCRBY\", refkeyf:format(ref_name), 1, rule_ref)\n"
   "        end\n"
   "      end\n"
   "      redis.call(\"SADD\", key.rules, rule.name)\n"
   "    end,\n"
   "    update = function(rule, diff)\n"
   "      local rkey = keyf.rule:format(rule.name)\n"
   "      if redis.call(\"EXISTS\", rkey) == 0 then error(\"rule \\\"\" .. rule.name .. \"\\\" does not exist\") end\n"
   "      assert(not diff.name, \"don't know how to rename rules yet\")\n"
   "      rule.gen = tonumber(rule.gen or 0) + 1\n"
   "      diff.gen = true\n"
   "      \n"
   "      if diff[\"if\"] then\n"
   "        redis.call(\"HSET\", rkey, \"if\", rule[\"if\"]:toJSON())\n"
   "        diff[\"if\"]=nil\n"
   "      end\n"
   "      if diff[\"then\"] then\n"
   "        redis.call(\"HSET\", rkey, \"then\", rule[\"then\"]:toJSON())\n"
   "        diff[\"then\"]=nil\n"
   "      end\n"
   "      if diff[\"else\"] then\n"
   "        redis.call(\"HSET\", rkey, \"else\", rule[\"else\"]:toJSON())\n"
   "        diff[\"else\"]=nil\n"
   "      end\n"
   "      \n"
   "      if diff.refs then\n"
   "        local ref_kind, ref_name, refkey\n"
   "        local rule_ref = \"rule:\"..rule.name\n"
   "        for ref, _ in pairs(diff.refs.old or {}) do\n"
   "          ref_kind, ref_name = ref:match(\"(.+):(.+)\")\n"
   "          refkey = assert(keyf[ref_kind .. \"_refs\"]):format(ref_name)\n"
   "          redis.call(\"ZINCRBY\", refkey, -1, rule_ref)\n"
   "          redis.call(\"ZREMRANGEBYSCORE\", refkey, \"-inf\", 0)\n"
   "        end\n"
   "        \n"
   "        for ref, _ in pairs(diff.refs.new or {}) do\n"
   "          ref_kind, ref_name = ref:match(\"(.+):(.+)\")\n"
   "          refkey = assert(keyf[ref_kind .. \"_refs\"]):format(ref_name)\n"
   "          redis.call(\"ZINCRBY\", refkey, 1, rule_ref)\n"
   "        end\n"
   "      end\n"
   "      \n"
   "      redis_hmset(rkey, rule, table_keys(diff))\n"
   "    end,\n"
   "    delete = function(rule)\n"
   "      local rkey = keyf.rule:format(rule.name)\n"
   "      if redis.call(\"EXISTS\", rkey) == 1 then error(\"rule \\\"\" .. rule.name .. \"\\\" does not exist\") end\n"
   "      if redis.call(\"ZCARD\", keyf.rule_refs:format(rule.name)) > 0 then error(\"rule \\\"\" .. rule.name .. \"\\\" still in use\") end\n"
   "      \n"
   "      local rule_ref = \"rule:\"..rule.name\n"
   "      for ref, _ in pairs(rule.refs or {}) do\n"
   "        local ref_kind, ref_name = ref:match(\"(.+):(.+)\")\n"
   "        local refkey = assert(keyf[ref_kind .. \"_refs\"]):format(ref_name)\n"
   "        redis.call(\"ZINCRBY\", refkey, -1, rule_ref)\n"
   "        redis.call(\"ZREMRANGEBYSCORE\", refkey, \"-inf\", 0)\n"
   "      end\n"
   "      \n"
   "      redis.call(\"SREM\", key.rules, rule.name)\n"
   "      redis.call(\"DEL\", rkey)\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Binding.set(\"ruleset\", {\n"
   "    create = function(ruleset)\n"
   "      if ruleset.external then return end\n"
   "      if redis.call(\"SISMEMBER\", key.rulesets, ruleset.name) == 1 then error((\"ruleset \\\"%s\\\" already exists\"):format(ruleset.name)) end\n"
   "      \n"
   "      ruleset.gen = 0\n"
   "      redis_hmset(key.ruleset, ruleset, \"name\", \"info\", \"gen\")\n"
   "      redis.call(\"SADD\", key.rulesets, ruleset.name)\n"
   "    end,\n"
   "    update = function(ruleset, diff)\n"
   "      if redis.call(\"SISMEMBER\", key.rulesets, ruleset.name) == 0 then error((\"ruleset \\\"%s\\\" does not exist\"):format(ruleset.name)) end\n"
   "      assert(not diff.name, \"don't know how to rename rulesets yet\")\n"
   "      assert(not diff.lists, \"don't know how to update ruleset lists inline\")\n"
   "      assert(not diff.limiters, \"don't know how to update ruleset limiters inline\")\n"
   "      assert(not diff.rules, \"don't know how to update ruleset rules inline\")\n"
   "      ruleset.gen = tonumber(ruleset.gen or 0) + 1\n"
   "      diff.gen = true\n"
   "      \n"
   "      redis_hmset(key.ruleset, ruleset, table_keys(diff))\n"
   "    end,\n"
   "    delete = function(ruleset)\n"
   "      if redis.call(\"SISMEMBER\", key.rulesets, ruleset.name) == 0 then error((\"ruleset \\\"%s\\\" does not exist\"):format(ruleset.name)) end\n"
   "      --TODO: is this ruleset in use?\n"
   "      redis.call(\"SREM\", key.rulesets, ruleset.name)\n"
   "      assert(redis.call(\"SCARD\", key.phases) == 0, \"some phases still present in ruleset\")\n"
   "      assert(redis.call(\"SCARD\", key.list) == 0, \"some lists still present in ruleset\")\n"
   "      assert(redis.call(\"SCARD\", key.rule) == 0, \"some rules still present in ruleset\")\n"
   "      assert(redis.call(\"SCARD\", key.limiter) == 0, \"some limiters still present in ruleset\")\n"
   "      \n"
   "      redis.call(\"DEL\", key.ruleset)\n"
   "      \n"
   "    end\n"
   "  })\n"
   "  \n"
   "  local function get_external_ruleset(parsed_ruleset)\n"
   "    if not ruleset_name or #ruleset_name == 0 then return nil, \"no ruleset name given\" end\n"
   "    if redis.call(\"EXISTS\", key.ruleset) == 0 then\n"
   "      return nil, (\"ruleset \\\"%s\\\" does not exist\"):format(ruleset_name)\n"
   "    end\n"
   "    local rs = redis_gethash(key.ruleset)\n"
   "    if parsed_ruleset then\n"
   "      for k,v in pairs(parsed_ruleset) do\n"
   "        rs[k]=v\n"
   "      end\n"
   "    end\n"
   "    rs.external = true\n"
   "    rs = Ruleset.new(rs)\n"
   "    return rs\n"
   "  end\n"
   "  \n"
   "  local function check_existence_for_update(name, keyfmt, description)\n"
   "    if not name or #name == 0 then\n"
   "      return nil, description..\" name missing\"\n"
   "    end\n"
   "    if redis.call(\"EXISTS\", keyfmt:format(name)) == 0 then\n"
   "      return nil, (\"%s \\\"%s\\\" does not exist\"):format(description, name)\n"
   "    end\n"
   "    return true\n"
   "  end\n"
   "  \n"
   "  local parser_update_opts = { external = {\n"
   "    list = function(parser, name)\n"
   "      return redis.call(\"EXISTS\", keyf.list:format(name)) == 1\n"
   "    end,\n"
   "    rule = function(parser, name)\n"
   "      local json = ruleset_read(prefix, ruleset_name, \"rule\", name, true)\n"
   "      local rule = parser:parseJSON(\"rule\", json, \"loaded rule\", 1)\n"
   "      parser.ruleset.rules[rule.name]=rule\n"
   "      return rule\n"
   "    end,\n"
   "    limiter = function(parser, name)\n"
   "      local json = ruleset_read(prefix, ruleset_name, \"limiter\", name, true)\n"
   "      local lim = parser:parseJSON(\"limiter\", json, \"loaded limiter\", 1)\n"
   "      parser.ruleset.limiters[lim.name]=lim\n"
   "      if lim.burst then\n"
   "        parser:getLimiter(lim.burst)\n"
   "      end\n"
   "      return lim\n"
   "    end\n"
   "  }}\n"
   "  \n"
   "  local function run_update_command(what, update_method_name, thing_name, keyfmt, extra_fn)\n"
   "    local ret, parsed, rs, err\n"
   "    if what ~= \"ruleset\" then\n"
   "      ret, err = check_existence_for_update(thing_name, keyfmt, what)\n"
   "      if not ret then return {0, err} end\n"
   "    else\n"
   "      thing_name = ruleset_name\n"
   "    end\n"
   "    \n"
   "    local parser = Parser.new(parser_update_opts)\n"
   "    local old = parser:get(what, thing_name)\n"
   "    \n"
   "    local json_in = nextarg()\n"
   "    parsed, err = parser:parseJSON(what, json_in, \"rule update\")\n"
   "    if not parsed then return {0, err} end\n"
   "    hmm(old)\n"
   "    hmm(\"AND NOW...\")\n"
   "    hmm(parser.ruleset)\n"
   "    hmm(\"also\")\n"
   "    hmm(parsed)\n"
   "    \n"
   "    rs, err = get_external_ruleset(parser.ruleset)\n"
   "    if not rs then return {0, err} end\n"
   "    hmm(\"...kay then\")\n"
   "    \n"
   "    \n"
   "    if extra_fn then\n"
   "      ret, err = extra_fn(rs, parsed)\n"
   "      if not ret then return {0, err or \"extra_fn failed\"} end\n"
   "    end\n"
   "    \n"
   "    if #thing_name == 0 and parsed then thing_name = parsed.name end\n"
   "    if not thing_name or #thing_name == 0 then\n"
   "      return {0, (\"missing %s name\"):format(what)}\n"
   "    end\n"
   "      \n"
   "    if next(parsed) then\n"
   "      ret, err = rs[update_method_name](rs, thing_name, parsed)\n"
   "      if not ret then\n"
   "        return {0, err}\n"
   "      end\n"
   "    else\n"
   "      return {0, \"nothing to update\"}\n"
   "    end\n"
   "    \n"
   "    publish(\"update\", what, thing_name, json_in)\n"
   "    \n"
   "    return {1}\n"
   "  end\n"
   "  \n"
   "  \n"
   "  local actions\n"
   "  actions = {\n"
   "    ruleset = {\n"
   "      create = function()\n"
   "        if #ruleset_name > 0 and redis.call(\"EXISTS\", key.ruleset) == 1 then\n"
   "          return {0, (\"ruleset \\\"%s\\\" already exists\"):format(ruleset_name)}\n"
   "        end\n"
   "        \n"
   "        local json_in = nextarg()\n"
   "        \n"
   "        local p = Parser.new()\n"
   "        local parsed, err = p:parseJSON(\"ruleset\", json_in, ruleset_name or \"anonymous ruleset\", true)\n"
   "        if not parsed then\n"
   "          return {0, err}\n"
   "        end\n"
   "        if #ruleset_name > 0 then\n"
   "          parsed.name = ruleset_name\n"
   "        end\n"
   "        local rs = Ruleset.new(parsed)\n"
   "        return rs and {1} or {0, \"failed to create ruleset\"}\n"
   "      end,\n"
   "      update = function()\n"
   "        return run_update_command(\"ruleset\", \"updateRuleset\", nextarg())\n"
   "      end,\n"
   "      delete = function()\n"
   "        return {0, \"can't do this yet\"}\n"
   "      end\n"
   "    },\n"
   "    list = {\n"
   "      create = function()\n"
   "        local list_name, json_in = nextarg(2)\n"
   "        if not list_name then list_name = \"\" end\n"
   "        \n"
   "        if #list_name > 0 and redis.call(\"EXISTS\", keyf.list:format(list_name)) == 1 then\n"
   "          return {0, (\"list \\\"%s\\\" already exists\"):format(list_name)}\n"
   "        end\n"
   "        \n"
   "        local p = Parser.new()\n"
   "        local parsed, err = p:parseJSON(\"list\", json_in, list_name)\n"
   "        if not parsed then\n"
   "          return {0, err}\n"
   "        end\n"
   "        \n"
   "        local list = Ruleset.newList(parsed)\n"
   "        publish(\"create\", \"list\", list.name, list:toJSON())\n"
   "        return list and {1} or {0, \"failed to create list\"}\n"
   "      end,\n"
   "      update = function()\n"
   "        return run_update_command(\"list\", \"updateList\", nextarg(), keyf.list)\n"
   "      end,\n"
   "      delete = function()\n"
   "        return {0, \"can't do this yet\"}\n"
   "      end\n"
   "    },\n"
   "    rule = {\n"
   "      create = function()\n"
   "        local rule_name, json_in = nextarg(2)\n"
   "        if not rule_name then rule_name = \"\" end\n"
   "        \n"
   "        if #rule_name > 0 and redis.call(\"EXISTS\", keyf.rule:format(rule_name)) == 1 then\n"
   "          return {0, (\"rule \\\"%s\\\" already exists\"):format(rule_name)}\n"
   "        end\n"
   "        \n"
   "        local ruleset\n"
   "        local parsed, err = Parser.new():parseJSON(\"rule\", json_in, rule_name, true)\n"
   "        if not parsed then return {0, err} end\n"
   "        \n"
   "        ruleset, err = get_external_ruleset()\n"
   "        if not ruleset then return {0, err} end\n"
   "        \n"
   "        if not parsed.name and #rule_name > 0 then parsed.name = rule_name end\n"
   "        \n"
   "        local new_rule = ruleset:addRule(parsed)\n"
   "        if new_rule then\n"
   "          publish(\"create\", \"rule\", new_rule.name, new_rule:toJSON())\n"
   "          return {1}\n"
   "        else\n"
   "          return {0, \"failed to create rule\"}\n"
   "        end\n"
   "      end,\n"
   "      update = function()\n"
   "        return run_update_command(\"rule\", \"updateRule\", nextarg(), keyf.rule)\n"
   "      end,\n"
   "      delete = function()\n"
   "        --local name = nextarg()\n"
   "        return {0, \"can't do this yet\"}\n"
   "      end\n"
   "    },\n"
   "    limiter = {\n"
   "      create = function()\n"
   "        local json_in, limiter_name = nextarg(2)\n"
   "        if not limiter_name then limiter_name = \"\" end\n"
   "        \n"
   "        if #limiter_name > 0 and redis.call(\"EXISTS\", keyf.rule:format(#limiter_name)) == 1 then\n"
   "          return {0, (\"limiter \\\"%s\\\" already exists\"):format(#limiter_name)}\n"
   "        end\n"
   "        \n"
   "        local p = Parser.new()\n"
   "        local parsed, err = p:parseJSON(\"limiter\", json_in, #limiter_name)\n"
   "        if not parsed then\n"
   "          return {0, err}\n"
   "        end\n"
   "        \n"
   "        local new_limiter = Ruleset.newLimiter(parsed)\n"
   "        if new_limiter then\n"
   "          publish(\"create\", \"limiter\", new_limiter.name, new_limiter:toJSON())\n"
   "          return {1}\n"
   "        else\n"
   "          return {0, \"failed to create rule\"}\n"
   "        end\n"
   "      end,\n"
   "      update = function()\n"
   "        return run_update_command(\"limiter\", \"updateLimiter\", nextarg(), keyf.limiter)\n"
   "      end,\n"
   "      delete = function()\n"
   "        --local name = nextarg()\n"
   "        return {0, \"can't do this yet\"}\n"
   "      end\n"
   "    }\n"
   "  }\n"
   "  \n"
   "  if type(actions[item]) == \"function\" then\n"
   "    actions[item](action)\n"
   "  elseif actions[item][action] then\n"
   "    return actions[item][action]()\n"
   "  else\n"
   "    error((\"unknown action %s for item %s\"):format(action, item))\n"
   "  end\n"
   "\n"
   "end\n"
   "do\n"
   "  local modules = {}\n"
   "  module = function(name, fn) modules[name]=fn() end\n"
   "  require = function(name) return modules[name] end\n"
   "end\n"
   "--luacheck: ignore\n"
   "\n"
   "module(\"inspect\", function()\n"
   "  local inspect ={\n"
   "    _VERSION = 'inspect.lua 3.1.0',\n"
   "    _URL     = 'http://github.com/kikito/inspect.lua',\n"
   "    _DESCRIPTION = 'human-readable representations of tables',\n"
   "    _LICENSE = \"MIT LICENSE; Copyright (c) 2013 Enrique GarcÃ­a Cota\"\n"
   "  }\n"
   "  \n"
   "  local tostring = tostring\n"
   "  \n"
   "  inspect.KEY       = setmetatable({}, {__tostring = function() return 'inspect.KEY' end})\n"
   "  inspect.METATABLE = setmetatable({}, {__tostring = function() return 'inspect.METATABLE' end})\n"
   "  \n"
   "  -- Apostrophizes the string if it has quotes, but not aphostrophes\n"
   "  -- Otherwise, it returns a regular quoted string\n"
   "  local function smartQuote(str)\n"
   "    if str:match('\"') and not str:match(\"'\") then\n"
   "      return \"'\" .. str .. \"'\"\n"
   "    end\n"
   "    return '\"' .. str:gsub('\"', '\\\\\"') .. '\"'\n"
   "  end\n"
   "  \n"
   "  -- \\a => '\\\\a', \\0 => '\\\\0', 31 => '\\31'\n"
   "  local shortControlCharEscapes = {\n"
   "    [\"\\a\"] = \"\\\\a\",  [\"\\b\"] = \"\\\\b\", [\"\\f\"] = \"\\\\f\", [\"\\n\"] = \"\\\\n\",\n"
   "    [\"\\r\"] = \"\\\\r\",  [\"\\t\"] = \"\\\\t\", [\"\\v\"] = \"\\\\v\"\n"
   "  }\n"
   "  local longControlCharEscapes = {} -- \\a => nil, \\0 => \\000, 31 => \\031\n"
   "  for i=0, 31 do\n"
   "    local ch = string.char(i)\n"
   "    if not shortControlCharEscapes[ch] then\n"
   "      shortControlCharEscapes[ch] = \"\\\\\"..i\n"
   "      longControlCharEscapes[ch]  = string.format(\"\\\\%03d\", i)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function escape(str)\n"
   "    return (str:gsub(\"\\\\\", \"\\\\\\\\\")\n"
   "               :gsub(\"(%c)%f[0-9]\", longControlCharEscapes)\n"
   "               :gsub(\"%c\", shortControlCharEscapes))\n"
   "  end\n"
   "  \n"
   "  local function isIdentifier(str)\n"
   "    return type(str) == 'string' and str:match( \"^[_%a][_%a%d]*$\" )\n"
   "  end\n"
   "  \n"
   "  local function isSequenceKey(k, sequenceLength)\n"
   "    return type(k) == 'number'\n"
   "       and 1 <= k\n"
   "       and k <= sequenceLength\n"
   "       and math.floor(k) == k\n"
   "  end\n"
   "  \n"
   "  local defaultTypeOrders = {\n"
   "    ['number']   = 1, ['boolean']  = 2, ['string'] = 3, ['table'] = 4,\n"
   "    ['function'] = 5, ['userdata'] = 6, ['thread'] = 7\n"
   "  }\n"
   "  \n"
   "  local function sortKeys(a, b)\n"
   "    local ta, tb = type(a), type(b)\n"
   "  \n"
   "    -- strings and numbers are sorted numerically/alphabetically\n"
   "    if ta == tb and (ta == 'string' or ta == 'number') then return a < b end\n"
   "  \n"
   "    local dta, dtb = defaultTypeOrders[ta], defaultTypeOrders[tb]\n"
   "    -- Two default types are compared according to the defaultTypeOrders table\n"
   "    if dta and dtb then return defaultTypeOrders[ta] < defaultTypeOrders[tb]\n"
   "    elseif dta     then return true  -- default types before custom ones\n"
   "    elseif dtb     then return false -- custom types after default ones\n"
   "    end\n"
   "  \n"
   "    -- custom types are sorted out alphabetically\n"
   "    return ta < tb\n"
   "  end\n"
   "  \n"
   "  -- For implementation reasons, the behavior of rawlen & # is \"undefined\" when\n"
   "  -- tables aren't pure sequences. So we implement our own # operator.\n"
   "  local function getSequenceLength(t)\n"
   "    local len = 1\n"
   "    local v = rawget(t,len)\n"
   "    while v ~= nil do\n"
   "      len = len + 1\n"
   "      v = rawget(t,len)\n"
   "    end\n"
   "    return len - 1\n"
   "  end\n"
   "  \n"
   "  local function getNonSequentialKeys(t)\n"
   "    local keys = {}\n"
   "    local sequenceLength = getSequenceLength(t)\n"
   "    for k,_ in pairs(t) do\n"
   "      if not isSequenceKey(k, sequenceLength) then table.insert(keys, k) end\n"
   "    end\n"
   "    table.sort(keys, sortKeys)\n"
   "    return keys, sequenceLength\n"
   "  end\n"
   "  \n"
   "  local function getToStringResultSafely(t, mt)\n"
   "    local __tostring = type(mt) == 'table' and rawget(mt, '__tostring')\n"
   "    local str, ok\n"
   "    if type(__tostring) == 'function' then\n"
   "      ok, str = pcall(__tostring, t)\n"
   "      str = ok and str or 'error: ' .. tostring(str)\n"
   "    end\n"
   "    if type(str) == 'string' and #str > 0 then return str end\n"
   "  end\n"
   "  \n"
   "  local function countTableAppearances(t, tableAppearances)\n"
   "    tableAppearances = tableAppearances or {}\n"
   "  \n"
   "    if type(t) == 'table' then\n"
   "      if not tableAppearances[t] then\n"
   "        tableAppearances[t] = 1\n"
   "        for k,v in pairs(t) do\n"
   "          countTableAppearances(k, tableAppearances)\n"
   "          countTableAppearances(v, tableAppearances)\n"
   "        end\n"
   "        countTableAppearances(getmetatable(t), tableAppearances)\n"
   "      else\n"
   "        tableAppearances[t] = tableAppearances[t] + 1\n"
   "      end\n"
   "    end\n"
   "  \n"
   "    return tableAppearances\n"
   "  end\n"
   "  \n"
   "  local copySequence = function(s)\n"
   "    local copy, len = {}, #s\n"
   "    for i=1, len do copy[i] = s[i] end\n"
   "    return copy, len\n"
   "  end\n"
   "  \n"
   "  local function makePath(path, ...)\n"
   "    local keys = {...}\n"
   "    local newPath, len = copySequence(path)\n"
   "    for i=1, #keys do\n"
   "      newPath[len + i] = keys[i]\n"
   "    end\n"
   "    return newPath\n"
   "  end\n"
   "  \n"
   "  local function processRecursive(process, item, path, visited)\n"
   "  \n"
   "      if item == nil then return nil end\n"
   "      if visited[item] then return visited[item] end\n"
   "  \n"
   "      local processed = process(item, path)\n"
   "      if type(processed) == 'table' then\n"
   "        local processedCopy = {}\n"
   "        visited[item] = processedCopy\n"
   "        local processedKey\n"
   "  \n"
   "        for k,v in pairs(processed) do\n"
   "          processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY), visited)\n"
   "          if processedKey ~= nil then\n"
   "            processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey), visited)\n"
   "          end\n"
   "        end\n"
   "  \n"
   "        local mt  = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE), visited)\n"
   "        setmetatable(processedCopy, mt)\n"
   "        processed = processedCopy\n"
   "      end\n"
   "      return processed\n"
   "  end\n"
   "  \n"
   "  \n"
   "  \n"
   "  -------------------------------------------------------------------\n"
   "  \n"
   "  local Inspector = {}\n"
   "  local Inspector_mt = {__index = Inspector}\n"
   "  \n"
   "  function Inspector:puts(...)\n"
   "    local args   = {...}\n"
   "    local buffer = self.buffer\n"
   "    local len    = #buffer\n"
   "    for i=1, #args do\n"
   "      len = len + 1\n"
   "      buffer[len] = args[i]\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Inspector:down(f)\n"
   "    self.level = self.level + 1\n"
   "    f()\n"
   "    self.level = self.level - 1\n"
   "  end\n"
   "  \n"
   "  function Inspector:tabify()\n"
   "    self:puts(self.newline, string.rep(self.indent, self.level))\n"
   "  end\n"
   "  \n"
   "  function Inspector:alreadyVisited(v)\n"
   "    return self.ids[v] ~= nil\n"
   "  end\n"
   "  \n"
   "  function Inspector:getId(v)\n"
   "    local id = self.ids[v]\n"
   "    if not id then\n"
   "      local tv = type(v)\n"
   "      id              = (self.maxIds[tv] or 0) + 1\n"
   "      self.maxIds[tv] = id\n"
   "      self.ids[v]     = id\n"
   "    end\n"
   "    return tostring(id)\n"
   "  end\n"
   "  \n"
   "  function Inspector:putKey(k)\n"
   "    if isIdentifier(k) then return self:puts(k) end\n"
   "    self:puts(\"[\")\n"
   "    self:putValue(k)\n"
   "    self:puts(\"]\")\n"
   "  end\n"
   "  \n"
   "  function Inspector:putTable(t)\n"
   "    if t == inspect.KEY or t == inspect.METATABLE then\n"
   "      self:puts(tostring(t))\n"
   "    elseif self:alreadyVisited(t) then\n"
   "      self:puts('<table ', self:getId(t), '>')\n"
   "    elseif self.level >= self.depth then\n"
   "      self:puts('{...}')\n"
   "    else\n"
   "      if self.tableAppearances[t] > 1 then self:puts('<', self:getId(t), '>') end\n"
   "  \n"
   "      local nonSequentialKeys, sequenceLength = getNonSequentialKeys(t)\n"
   "      local mt                = getmetatable(t)\n"
   "      local toStringResult    = getToStringResultSafely(t, mt)\n"
   "  \n"
   "      self:puts('{')\n"
   "      self:down(function()\n"
   "        if toStringResult then\n"
   "          self:puts(' -- ', escape(toStringResult))\n"
   "          if sequenceLength >= 1 then self:tabify() end\n"
   "        end\n"
   "  \n"
   "        local count = 0\n"
   "        for i=1, sequenceLength do\n"
   "          if count > 0 then self:puts(',') end\n"
   "          self:puts(' ')\n"
   "          self:putValue(t[i])\n"
   "          count = count + 1\n"
   "        end\n"
   "  \n"
   "        for _,k in ipairs(nonSequentialKeys) do\n"
   "          if count > 0 then self:puts(',') end\n"
   "          self:tabify()\n"
   "          self:putKey(k)\n"
   "          self:puts(' = ')\n"
   "          self:putValue(t[k])\n"
   "          count = count + 1\n"
   "        end\n"
   "  \n"
   "        if mt then\n"
   "          if count > 0 then self:puts(',') end\n"
   "          self:tabify()\n"
   "          self:puts('<metatable> = ')\n"
   "          self:putValue(mt)\n"
   "        end\n"
   "      end)\n"
   "  \n"
   "      if #nonSequentialKeys > 0 or mt then -- result is multi-lined. Justify closing }\n"
   "        self:tabify()\n"
   "      elseif sequenceLength > 0 then -- array tables have one extra space before closing }\n"
   "        self:puts(' ')\n"
   "      end\n"
   "  \n"
   "      self:puts('}')\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Inspector:putValue(v)\n"
   "    local tv = type(v)\n"
   "  \n"
   "    if tv == 'string' then\n"
   "      self:puts(smartQuote(escape(v)))\n"
   "    elseif tv == 'number' or tv == 'boolean' or tv == 'nil' then\n"
   "      self:puts(tostring(v))\n"
   "    elseif tv == 'table' then\n"
   "      self:putTable(v)\n"
   "    else\n"
   "      self:puts('<',tv,' ',self:getId(v),'>')\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  -------------------------------------------------------------------\n"
   "  \n"
   "  function inspect.inspect(root, options)\n"
   "    options       = options or {}\n"
   "  \n"
   "    local depth   = options.depth   or math.huge\n"
   "    local newline = options.newline or '\\n'\n"
   "    local indent  = options.indent  or '  '\n"
   "    local process = options.process\n"
   "  \n"
   "    if process then\n"
   "      root = processRecursive(process, root, {}, {})\n"
   "    end\n"
   "  \n"
   "    local inspector = setmetatable({\n"
   "      depth            = depth,\n"
   "      level            = 0,\n"
   "      buffer           = {},\n"
   "      ids              = {},\n"
   "      maxIds           = {},\n"
   "      newline          = newline,\n"
   "      indent           = indent,\n"
   "      tableAppearances = countTableAppearances(root)\n"
   "    }, Inspector_mt)\n"
   "  \n"
   "    inspector:putValue(root)\n"
   "  \n"
   "    return table.concat(inspector.buffer)\n"
   "  end\n"
   "  \n"
   "  setmetatable(inspect, { __call = function(_, ...) return inspect.inspect(...) end })\n"
   "  \n"
   "  return inspect\n"
   "  \n"
   "\n"
   "end)\n"
   "\n"
   "module(\"dkjson\", function()\n"
   "  --David Kolf's JSON module for Lua 5.1/5.2\n"
   "  -- small hack to generate object and array metatables, \n"
   "  -- and key ordering callbacks by slact\n"
   "  \n"
   "  local always_try_using_lpeg = false\n"
   "  local register_global_module_table = false\n"
   "  local global_module_name = 'json'\n"
   "  \n"
   "  --luacheck: ignore\n"
   "  \n"
   "  --[==[\n"
   "  \n"
   "  David Kolf's JSON module for Lua 5.1/5.2\n"
   "  \n"
   "  Version 2.5\n"
   "  \n"
   "  \n"
   "  For the documentation see the corresponding readme.txt or visit\n"
   "  <http://dkolf.de/src/dkjson-lua.fsl/>.\n"
   "  \n"
   "  You can contact the author by sending an e-mail to 'david' at the\n"
   "  domain 'dkolf.de'.\n"
   "  \n"
   "  \n"
   "  Copyright (C) 2010-2013 David Heiko Kolf\n"
   "  \n"
   "  Permission is hereby granted, free of charge, to any person obtaining\n"
   "  a copy of this software and associated documentation files (the\n"
   "  \"Software\"), to deal in the Software without restriction, including\n"
   "  without limitation the rights to use, copy, modify, merge, publish,\n"
   "  distribute, sublicense, and/or sell copies of the Software, and to\n"
   "  permit persons to whom the Software is furnished to do so, subject to\n"
   "  the following conditions:\n"
   "  \n"
   "  The above copyright notice and this permission notice shall be\n"
   "  included in all copies or substantial portions of the Software.\n"
   "  \n"
   "  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n"
   "  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
   "  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
   "  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n"
   "  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n"
   "  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n"
   "  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
   "  SOFTWARE.\n"
   "  \n"
   "  --]==]\n"
   "  \n"
   "  -- global dependencies:\n"
   "  local pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset =\n"
   "        pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset\n"
   "  local error, require, pcall, select = error, require, pcall, select\n"
   "  local floor, huge = math.floor, math.huge\n"
   "  local strrep, gsub, strsub, strbyte, strchar, strfind, strlen, strformat =\n"
   "        string.rep, string.gsub, string.sub, string.byte, string.char,\n"
   "        string.find, string.len, string.format\n"
   "  local strmatch = string.match\n"
   "  local concat = table.concat\n"
   "  \n"
   "  local json = { version = \"dkjson 2.5\" }\n"
   "  \n"
   "  if register_global_module_table then\n"
   "    _G[global_module_name] = json\n"
   "  end\n"
   "  \n"
   "  local _ENV = nil -- blocking globals in Lua 5.2\n"
   "  \n"
   "  pcall (function()\n"
   "    -- Enable access to blocked metatables.\n"
   "    -- Don't worry, this module doesn't change anything in them.\n"
   "    local debmeta = require \"debug\".getmetatable\n"
   "    if debmeta then getmetatable = debmeta end\n"
   "  end)\n"
   "  \n"
   "  json.null = setmetatable ({}, {\n"
   "    __tojson = function () return \"null\" end\n"
   "  })\n"
   "  \n"
   "  local function isarray (tbl)\n"
   "    local max, n, arraylen = 0, 0, 0\n"
   "    for k,v in pairs (tbl) do\n"
   "      if k == 'n' and type(v) == 'number' then\n"
   "        arraylen = v\n"
   "        if v > max then\n"
   "          max = v\n"
   "        end\n"
   "      else\n"
   "        if type(k) ~= 'number' or k < 1 or floor(k) ~= k then\n"
   "          return false\n"
   "        end\n"
   "        if k > max then\n"
   "          max = k\n"
   "        end\n"
   "        n = n + 1\n"
   "      end\n"
   "    end\n"
   "    if max > 10 and max > arraylen and max > n * 2 then\n"
   "      return false -- don't create an array with too many holes\n"
   "    end\n"
   "    return true, max\n"
   "  end\n"
   "  \n"
   "  local escapecodes = {\n"
   "    [\"\\\"\"] = \"\\\\\\\"\", [\"\\\\\"] = \"\\\\\\\\\", [\"\\b\"] = \"\\\\b\", [\"\\f\"] = \"\\\\f\",\n"
   "    [\"\\n\"] = \"\\\\n\",  [\"\\r\"] = \"\\\\r\",  [\"\\t\"] = \"\\\\t\"\n"
   "  }\n"
   "  \n"
   "  local function escapeutf8 (uchar)\n"
   "    local value = escapecodes[uchar]\n"
   "    if value then\n"
   "      return value\n"
   "    end\n"
   "    local a, b, c, d = strbyte (uchar, 1, 4)\n"
   "    a, b, c, d = a or 0, b or 0, c or 0, d or 0\n"
   "    if a <= 0x7f then\n"
   "      value = a\n"
   "    elseif 0xc0 <= a and a <= 0xdf and b >= 0x80 then\n"
   "      value = (a - 0xc0) * 0x40 + b - 0x80\n"
   "    elseif 0xe0 <= a and a <= 0xef and b >= 0x80 and c >= 0x80 then\n"
   "      value = ((a - 0xe0) * 0x40 + b - 0x80) * 0x40 + c - 0x80\n"
   "    elseif 0xf0 <= a and a <= 0xf7 and b >= 0x80 and c >= 0x80 and d >= 0x80 then\n"
   "      value = (((a - 0xf0) * 0x40 + b - 0x80) * 0x40 + c - 0x80) * 0x40 + d - 0x80\n"
   "    else\n"
   "      return \"\"\n"
   "    end\n"
   "    if value <= 0xffff then\n"
   "      return strformat (\"\\\\u%.4x\", value)\n"
   "    elseif value <= 0x10ffff then\n"
   "      -- encode as UTF-16 surrogate pair\n"
   "      value = value - 0x10000\n"
   "      local highsur, lowsur = 0xD800 + floor (value/0x400), 0xDC00 + (value % 0x400)\n"
   "      return strformat (\"\\\\u%.4x\\\\u%.4x\", highsur, lowsur)\n"
   "    else\n"
   "      return \"\"\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function fsub (str, pattern, repl)\n"
   "    -- gsub always builds a new string in a buffer, even when no match\n"
   "    -- exists. First using find should be more efficient when most strings\n"
   "    -- don't contain the pattern.\n"
   "    if strfind (str, pattern) then\n"
   "      return gsub (str, pattern, repl)\n"
   "    else\n"
   "      return str\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function quotestring (value)\n"
   "    -- based on the regexp \"escapable\" in https://github.com/douglascrockford/JSON-js\n"
   "    value = fsub (value, \"[%z\\1-\\31\\\"\\\\\\127]\", escapeutf8)\n"
   "    if strfind (value, \"[\\194\\216\\220\\225\\226\\239]\") then\n"
   "      value = fsub (value, \"\\194[\\128-\\159\\173]\", escapeutf8)\n"
   "      value = fsub (value, \"\\216[\\128-\\132]\", escapeutf8)\n"
   "      value = fsub (value, \"\\220\\143\", escapeutf8)\n"
   "      value = fsub (value, \"\\225\\158[\\180\\181]\", escapeutf8)\n"
   "      value = fsub (value, \"\\226\\128[\\140-\\143\\168-\\175]\", escapeutf8)\n"
   "      value = fsub (value, \"\\226\\129[\\160-\\175]\", escapeutf8)\n"
   "      value = fsub (value, \"\\239\\187\\191\", escapeutf8)\n"
   "      value = fsub (value, \"\\239\\191[\\176-\\191]\", escapeutf8)\n"
   "    end\n"
   "    return \"\\\"\" .. value .. \"\\\"\"\n"
   "  end\n"
   "  json.quotestring = quotestring\n"
   "  \n"
   "  local function replace(str, o, n)\n"
   "    local i, j = strfind (str, o, 1, true)\n"
   "    if i then\n"
   "      return strsub(str, 1, i-1) .. n .. strsub(str, j+1, -1)\n"
   "    else\n"
   "      return str\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  -- locale independent num2str and str2num functions\n"
   "  local decpoint, numfilter\n"
   "  \n"
   "  local function updatedecpoint ()\n"
   "    decpoint = strmatch(tostring(0.5), \"([^05+])\")\n"
   "    -- build a filter that can be used to remove group separators\n"
   "    numfilter = \"[^0-9%-%+eE\" .. gsub(decpoint, \"[%^%$%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\") .. \"]+\"\n"
   "  end\n"
   "  \n"
   "  updatedecpoint()\n"
   "  \n"
   "  local function num2str (num)\n"
   "    return replace(fsub(tostring(num), numfilter, \"\"), decpoint, \".\")\n"
   "  end\n"
   "  \n"
   "  local function str2num (str)\n"
   "    local num = tonumber(replace(str, \".\", decpoint))\n"
   "    if not num then\n"
   "      updatedecpoint()\n"
   "      num = tonumber(replace(str, \".\", decpoint))\n"
   "    end\n"
   "    return num\n"
   "  end\n"
   "  \n"
   "  local function addnewline2 (level, buffer, buflen)\n"
   "    buffer[buflen+1] = \"\\n\"\n"
   "    buffer[buflen+2] = strrep (\"  \", level)\n"
   "    buflen = buflen + 2\n"
   "    return buflen\n"
   "  end\n"
   "  \n"
   "  function json.addnewline (state)\n"
   "    if state.indent then\n"
   "      state.bufferlen = addnewline2 (state.level or 0,\n"
   "                             state.buffer, state.bufferlen or #(state.buffer))\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local encode2 -- forward declaration\n"
   "  \n"
   "  local function addpair (key, value, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "    local kt = type (key)\n"
   "    if kt ~= 'string' and kt ~= 'number' then\n"
   "      return nil, \"type '\" .. kt .. \"' is not supported as a key by JSON.\"\n"
   "    end\n"
   "    if prev then\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \",\"\n"
   "    end\n"
   "    if indent then\n"
   "      buflen = addnewline2 (level, buffer, buflen)\n"
   "    end\n"
   "    buffer[buflen+1] = quotestring (key)\n"
   "    buffer[buflen+2] = \":\"\n"
   "    return encode2 (value, indent, level, buffer, buflen + 2, tables, globalorder, state)\n"
   "  end\n"
   "  \n"
   "  local function appendcustom(res, buffer, state)\n"
   "    local buflen = state.bufferlen\n"
   "    if type (res) == 'string' then\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = res\n"
   "    end\n"
   "    return buflen\n"
   "  end\n"
   "  \n"
   "  local function exception(reason, value, state, buffer, buflen, defaultmessage)\n"
   "    defaultmessage = defaultmessage or reason\n"
   "    local handler = state.exception\n"
   "    if not handler then\n"
   "      return nil, defaultmessage\n"
   "    else\n"
   "      state.bufferlen = buflen\n"
   "      local ret, msg = handler (reason, value, state, defaultmessage)\n"
   "      if not ret then return nil, msg or defaultmessage end\n"
   "      return appendcustom(ret, buffer, state)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function json.encodeexception(reason, value, state, defaultmessage)\n"
   "    return quotestring(\"<\" .. defaultmessage .. \">\")\n"
   "  end\n"
   "  \n"
   "  encode2 = function (value, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "    local valtype = type (value)\n"
   "    local valmeta = getmetatable (value)\n"
   "    valmeta = type (valmeta) == 'table' and valmeta -- only tables\n"
   "    local replacementjsonval = valmeta and valmeta.__jsonval\n"
   "    if replacementjsonval then\n"
   "      if type(replacementjsonval) == \"function\" then\n"
   "        value = replacementjsonval(value)\n"
   "      else\n"
   "        value = replacementjsonval\n"
   "      end\n"
   "      valtype = type (value)\n"
   "    end\n"
   "    \n"
   "    local valtojson = valmeta and valmeta.__tojson\n"
   "    if valtojson then\n"
   "      if tables[value] then\n"
   "        return exception('reference cycle', value, state, buffer, buflen)\n"
   "      end\n"
   "      tables[value] = true\n"
   "      state.bufferlen = buflen\n"
   "      local ret, msg = valtojson (value, state)\n"
   "      if not ret then return exception('custom encoder failed', value, state, buffer, buflen, msg) end\n"
   "      tables[value] = nil\n"
   "      buflen = appendcustom(ret, buffer, state)\n"
   "    elseif value == nil then\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"null\"\n"
   "    elseif valtype == 'number' then\n"
   "      local s\n"
   "      if value ~= value or value >= huge or -value >= huge then\n"
   "        -- This is the behaviour of the original JSON implementation.\n"
   "        s = \"null\"\n"
   "      else\n"
   "        s = num2str (value)\n"
   "      end\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = s\n"
   "    elseif valtype == 'boolean' then\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = value and \"true\" or \"false\"\n"
   "    elseif valtype == 'string' then\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = quotestring (value)\n"
   "    elseif valtype == 'table' then\n"
   "      if tables[value] then\n"
   "        return exception('reference cycle', value, state, buffer, buflen)\n"
   "      end\n"
   "      tables[value] = true\n"
   "      level = level + 1\n"
   "      local isa, n = isarray (value)\n"
   "      if n == 0 and valmeta and valmeta.__jsontype == 'object' then\n"
   "        isa = false\n"
   "      end\n"
   "      local msg\n"
   "      if isa then -- JSON array\n"
   "        buflen = buflen + 1\n"
   "        buffer[buflen] = \"[\"\n"
   "        for i = 1, n do\n"
   "          buflen, msg = encode2 (value[i], indent, level, buffer, buflen, tables, globalorder, state)\n"
   "          if not buflen then return nil, msg end\n"
   "          if i < n then\n"
   "            buflen = buflen + 1\n"
   "            buffer[buflen] = \",\"\n"
   "          end\n"
   "        end\n"
   "        buflen = buflen + 1\n"
   "        buffer[buflen] = \"]\"\n"
   "      else -- JSON object\n"
   "        local prev = false\n"
   "        buflen = buflen + 1\n"
   "        buffer[buflen] = \"{\"\n"
   "        local order = valmeta and valmeta.__jsonorder or globalorder\n"
   "        if order then\n"
   "          if type(order) == \"function\" then order = order(value) end\n"
   "          local used = {}\n"
   "          n = #order\n"
   "          for i = 1, n do\n"
   "            local k = order[i]\n"
   "            local v = value[k]\n"
   "            if v then\n"
   "              used[k] = true\n"
   "              buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "              prev = true -- add a seperator before the next element\n"
   "            end\n"
   "          end\n"
   "          for k,v in pairs (value) do\n"
   "            if not used[k] then\n"
   "              buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "              if not buflen then return nil, msg end\n"
   "              prev = true -- add a seperator before the next element\n"
   "            end\n"
   "          end\n"
   "        else -- unordered\n"
   "          for k,v in pairs (value) do\n"
   "            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "            if not buflen then return nil, msg end\n"
   "            prev = true -- add a seperator before the next element\n"
   "          end\n"
   "        end\n"
   "        if indent then\n"
   "          buflen = addnewline2 (level - 1, buffer, buflen)\n"
   "        end\n"
   "        buflen = buflen + 1\n"
   "        buffer[buflen] = \"}\"\n"
   "      end\n"
   "      tables[value] = nil\n"
   "    else\n"
   "      return exception ('unsupported type', value, state, buffer, buflen,\n"
   "        \"type '\" .. valtype .. \"' is not supported by JSON.\")\n"
   "    end\n"
   "    return buflen\n"
   "  end\n"
   "  \n"
   "  function json.encode (value, state)\n"
   "    state = state or {}\n"
   "    local oldbuffer = state.buffer\n"
   "    local buffer = oldbuffer or {}\n"
   "    state.buffer = buffer\n"
   "    updatedecpoint()\n"
   "    local ret, msg = encode2 (value, state.indent, state.level or 0,\n"
   "                     buffer, state.bufferlen or 0, state.tables or {}, state.keyorder, state)\n"
   "    if not ret then\n"
   "      error (msg, 2)\n"
   "    elseif oldbuffer == buffer then\n"
   "      state.bufferlen = ret\n"
   "      return true\n"
   "    else\n"
   "      state.bufferlen = nil\n"
   "      state.buffer = nil\n"
   "      return concat (buffer)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function loc(str, where)\n"
   "    local line, pos, linepos = 1, 1, 0\n"
   "    while true do\n"
   "      pos = strfind (str, \"\\n\", pos, true)\n"
   "      if pos and pos < where then\n"
   "        line = line + 1\n"
   "        linepos = pos\n"
   "        pos = pos + 1\n"
   "      else\n"
   "        break\n"
   "      end\n"
   "    end\n"
   "    return \"line \" .. line .. \", column \" .. (where - linepos)\n"
   "  end\n"
   "  \n"
   "  local function unterminated (str, what, where)\n"
   "    return nil, strlen (str) + 1, \"unterminated \" .. what .. \" at \" .. loc (str, where)\n"
   "  end\n"
   "  \n"
   "  local function scanwhite (str, pos)\n"
   "    while true do\n"
   "      pos = strfind (str, \"%S\", pos)\n"
   "      if not pos then return nil end\n"
   "      local sub2 = strsub (str, pos, pos + 1)\n"
   "      if sub2 == \"\\239\\187\" and strsub (str, pos + 2, pos + 2) == \"\\191\" then\n"
   "        -- UTF-8 Byte Order Mark\n"
   "        pos = pos + 3\n"
   "      elseif sub2 == \"//\" then\n"
   "        pos = strfind (str, \"[\\n\\r]\", pos + 2)\n"
   "        if not pos then return nil end\n"
   "      elseif sub2 == \"/*\" then\n"
   "        pos = strfind (str, \"*/\", pos + 2)\n"
   "        if not pos then return nil end\n"
   "        pos = pos + 2\n"
   "      else\n"
   "        return pos\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local escapechars = {\n"
   "    [\"\\\"\"] = \"\\\"\", [\"\\\\\"] = \"\\\\\", [\"/\"] = \"/\", [\"b\"] = \"\\b\", [\"f\"] = \"\\f\",\n"
   "    [\"n\"] = \"\\n\", [\"r\"] = \"\\r\", [\"t\"] = \"\\t\"\n"
   "  }\n"
   "  \n"
   "  local function unichar (value)\n"
   "    if value < 0 then\n"
   "      return nil\n"
   "    elseif value <= 0x007f then\n"
   "      return strchar (value)\n"
   "    elseif value <= 0x07ff then\n"
   "      return strchar (0xc0 + floor(value/0x40),\n"
   "                      0x80 + (floor(value) % 0x40))\n"
   "    elseif value <= 0xffff then\n"
   "      return strchar (0xe0 + floor(value/0x1000),\n"
   "                      0x80 + (floor(value/0x40) % 0x40),\n"
   "                      0x80 + (floor(value) % 0x40))\n"
   "    elseif value <= 0x10ffff then\n"
   "      return strchar (0xf0 + floor(value/0x40000),\n"
   "                      0x80 + (floor(value/0x1000) % 0x40),\n"
   "                      0x80 + (floor(value/0x40) % 0x40),\n"
   "                      0x80 + (floor(value) % 0x40))\n"
   "    else\n"
   "      return nil\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function scanstring (str, pos)\n"
   "    local lastpos = pos + 1\n"
   "    local buffer, n = {}, 0\n"
   "    while true do\n"
   "      local nextpos = strfind (str, \"[\\\"\\\\]\", lastpos)\n"
   "      if not nextpos then\n"
   "        return unterminated (str, \"string\", pos)\n"
   "      end\n"
   "      if nextpos > lastpos then\n"
   "        n = n + 1\n"
   "        buffer[n] = strsub (str, lastpos, nextpos - 1)\n"
   "      end\n"
   "      if strsub (str, nextpos, nextpos) == \"\\\"\" then\n"
   "        lastpos = nextpos + 1\n"
   "        break\n"
   "      else\n"
   "        local escchar = strsub (str, nextpos + 1, nextpos + 1)\n"
   "        local value\n"
   "        if escchar == \"u\" then\n"
   "          value = tonumber (strsub (str, nextpos + 2, nextpos + 5), 16)\n"
   "          if value then\n"
   "            local value2\n"
   "            if 0xD800 <= value and value <= 0xDBff then\n"
   "              -- we have the high surrogate of UTF-16. Check if there is a\n"
   "              -- low surrogate escaped nearby to combine them.\n"
   "              if strsub (str, nextpos + 6, nextpos + 7) == \"\\\\u\" then\n"
   "                value2 = tonumber (strsub (str, nextpos + 8, nextpos + 11), 16)\n"
   "                if value2 and 0xDC00 <= value2 and value2 <= 0xDFFF then\n"
   "                  value = (value - 0xD800)  * 0x400 + (value2 - 0xDC00) + 0x10000\n"
   "                else\n"
   "                  value2 = nil -- in case it was out of range for a low surrogate\n"
   "                end\n"
   "              end\n"
   "            end\n"
   "            value = value and unichar (value)\n"
   "            if value then\n"
   "              if value2 then\n"
   "                lastpos = nextpos + 12\n"
   "              else\n"
   "                lastpos = nextpos + 6\n"
   "              end\n"
   "            end\n"
   "          end\n"
   "        end\n"
   "        if not value then\n"
   "          value = escapechars[escchar] or escchar\n"
   "          lastpos = nextpos + 2\n"
   "        end\n"
   "        n = n + 1\n"
   "        buffer[n] = value\n"
   "      end\n"
   "    end\n"
   "    if n == 1 then\n"
   "      return buffer[1], lastpos\n"
   "    elseif n > 1 then\n"
   "      return concat (buffer), lastpos\n"
   "    else\n"
   "      return \"\", lastpos\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local scanvalue -- forward declaration\n"
   "  \n"
   "  local function set_scantable_metatable (tbl, meta, str, pos)\n"
   "    if type(meta)==\"function\" then\n"
   "      meta = meta(str, pos)\n"
   "      if type(meta) ~= \"table\" then\n"
   "        return tbl\n"
   "      end\n"
   "    end\n"
   "    return setmetatable(tbl, meta)\n"
   "  end\n"
   "  \n"
   "  local function scantable (what, closechar, str, startpos, nullval, objectmeta, arraymeta)\n"
   "    local len = strlen (str)\n"
   "    local tbl, n = {}, 0\n"
   "    local pos = startpos + 1\n"
   "    if what == 'object' then\n"
   "      set_scantable_metatable(tbl, objectmeta, str, startpos)\n"
   "    else\n"
   "      set_scantable_metatable(tbl, arraymeta, str, startpos)\n"
   "    end\n"
   "    while true do\n"
   "      pos = scanwhite (str, pos)\n"
   "      if not pos then return unterminated (str, what, startpos) end\n"
   "      local char = strsub (str, pos, pos)\n"
   "      if char == closechar then\n"
   "        return tbl, pos + 1\n"
   "      end\n"
   "      local val1, err\n"
   "      val1, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "      if err then return nil, pos, err end\n"
   "      pos = scanwhite (str, pos)\n"
   "      if not pos then return unterminated (str, what, startpos) end\n"
   "      char = strsub (str, pos, pos)\n"
   "      if char == \":\" then\n"
   "        if val1 == nil then\n"
   "          return nil, pos, \"cannot use nil as table index (at \" .. loc (str, pos) .. \")\"\n"
   "        end\n"
   "        pos = scanwhite (str, pos + 1)\n"
   "        if not pos then return unterminated (str, what, startpos) end\n"
   "        local val2\n"
   "        val2, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "        if err then return nil, pos, err end\n"
   "        tbl[val1] = val2\n"
   "        pos = scanwhite (str, pos)\n"
   "        if not pos then return unterminated (str, what, startpos) end\n"
   "        char = strsub (str, pos, pos)\n"
   "      else\n"
   "        n = n + 1\n"
   "        tbl[n] = val1\n"
   "      end\n"
   "      if char == \",\" then\n"
   "        pos = pos + 1\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  scanvalue = function (str, pos, nullval, objectmeta, arraymeta)\n"
   "    pos = pos or 1\n"
   "    pos = scanwhite (str, pos)\n"
   "    if not pos then\n"
   "      return nil, strlen (str) + 1, \"no valid JSON value (reached the end)\"\n"
   "    end\n"
   "    local char = strsub (str, pos, pos)\n"
   "    if char == \"{\" then\n"
   "      return scantable ('object', \"}\", str, pos, nullval, objectmeta, arraymeta)\n"
   "    elseif char == \"[\" then\n"
   "      return scantable ('array', \"]\", str, pos, nullval, objectmeta, arraymeta)\n"
   "    elseif char == \"\\\"\" then\n"
   "      return scanstring (str, pos)\n"
   "    else\n"
   "      local pstart, pend = strfind (str, \"^%-?[%d%.]+[eE]?[%+%-]?%d*\", pos)\n"
   "      if pstart then\n"
   "        local number = str2num (strsub (str, pstart, pend))\n"
   "        if number then\n"
   "          return number, pend + 1\n"
   "        end\n"
   "      end\n"
   "      pstart, pend = strfind (str, \"^%a%w*\", pos)\n"
   "      if pstart then\n"
   "        local name = strsub (str, pstart, pend)\n"
   "        if name == \"true\" then\n"
   "          return true, pend + 1\n"
   "        elseif name == \"false\" then\n"
   "          return false, pend + 1\n"
   "        elseif name == \"null\" then\n"
   "          return nullval, pend + 1\n"
   "        end\n"
   "      end\n"
   "      return nil, pos, \"no valid JSON value at \" .. loc (str, pos)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function optionalmetatables(...)\n"
   "    if select(\"#\", ...) > 0 then\n"
   "      return ...\n"
   "    else\n"
   "      return {__jsontype = 'object'}, {__jsontype = 'array'}\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function json.decode (str, pos, nullval, ...)\n"
   "    local objectmeta, arraymeta = optionalmetatables(...)\n"
   "    return scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "  end\n"
   "  \n"
   "  function json.use_lpeg ()\n"
   "    local g = require (\"lpeg\")\n"
   "  \n"
   "    if g.version() == \"0.11\" then\n"
   "      error \"due to a bug in LPeg 0.11, it cannot be used for JSON matching\"\n"
   "    end\n"
   "  \n"
   "    local pegmatch = g.match\n"
   "    local P, S, R = g.P, g.S, g.R\n"
   "  \n"
   "    local function ErrorCall (str, pos, msg, state)\n"
   "      if not state.msg then\n"
   "        state.msg = msg .. \" at \" .. loc (str, pos)\n"
   "        state.pos = pos\n"
   "      end\n"
   "      return false\n"
   "    end\n"
   "  \n"
   "    local function Err (msg)\n"
   "      return g.Cmt (g.Cc (msg) * g.Carg (2), ErrorCall)\n"
   "    end\n"
   "  \n"
   "    local SingleLineComment = P\"//\" * (1 - S\"\\n\\r\")^0\n"
   "    local MultiLineComment = P\"/*\" * (1 - P\"*/\")^0 * P\"*/\"\n"
   "    local Space = (S\" \\n\\r\\t\" + P\"\\239\\187\\191\" + SingleLineComment + MultiLineComment)^0\n"
   "  \n"
   "    local PlainChar = 1 - S\"\\\"\\\\\\n\\r\"\n"
   "    local EscapeSequence = (P\"\\\\\" * g.C (S\"\\\"\\\\/bfnrt\" + Err \"unsupported escape sequence\")) / escapechars\n"
   "    local HexDigit = R(\"09\", \"af\", \"AF\")\n"
   "    local function UTF16Surrogate (match, pos, high, low)\n"
   "      high, low = tonumber (high, 16), tonumber (low, 16)\n"
   "      if 0xD800 <= high and high <= 0xDBff and 0xDC00 <= low and low <= 0xDFFF then\n"
   "        return true, unichar ((high - 0xD800)  * 0x400 + (low - 0xDC00) + 0x10000)\n"
   "      else\n"
   "        return false\n"
   "      end\n"
   "    end\n"
   "    local function UTF16BMP (hex)\n"
   "      return unichar (tonumber (hex, 16))\n"
   "    end\n"
   "    local U16Sequence = (P\"\\\\u\" * g.C (HexDigit * HexDigit * HexDigit * HexDigit))\n"
   "    local UnicodeEscape = g.Cmt (U16Sequence * U16Sequence, UTF16Surrogate) + U16Sequence/UTF16BMP\n"
   "    local Char = UnicodeEscape + EscapeSequence + PlainChar\n"
   "    local String = P\"\\\"\" * g.Cs (Char ^ 0) * (P\"\\\"\" + Err \"unterminated string\")\n"
   "    local Integer = P\"-\"^(-1) * (P\"0\" + (R\"19\" * R\"09\"^0))\n"
   "    local Fractal = P\".\" * R\"09\"^0\n"
   "    local Exponent = (S\"eE\") * (S\"+-\")^(-1) * R\"09\"^1\n"
   "    local Number = (Integer * Fractal^(-1) * Exponent^(-1))/str2num\n"
   "    local Constant = P\"true\" * g.Cc (true) + P\"false\" * g.Cc (false) + P\"null\" * g.Carg (1)\n"
   "    local SimpleValue = Number + String + Constant\n"
   "    local ArrayContent, ObjectContent\n"
   "  \n"
   "    -- The functions parsearray and parseobject parse only a single value/pair\n"
   "    -- at a time and store them directly to avoid hitting the LPeg limits.\n"
   "    local function parsearray (str, pos, nullval, state)\n"
   "      local obj, cont\n"
   "      local npos\n"
   "      local t, nt = {}, 0\n"
   "      repeat\n"
   "        obj, cont, npos = pegmatch (ArrayContent, str, pos, nullval, state)\n"
   "        if not npos then break end\n"
   "        pos = npos\n"
   "        nt = nt + 1\n"
   "        t[nt] = obj\n"
   "      until cont == 'last'\n"
   "      return pos, setmetatable (t, state.arraymeta)\n"
   "    end\n"
   "  \n"
   "    local function parseobject (str, pos, nullval, state)\n"
   "      local obj, key, cont\n"
   "      local npos\n"
   "      local t = {}\n"
   "      repeat\n"
   "        key, obj, cont, npos = pegmatch (ObjectContent, str, pos, nullval, state)\n"
   "        if not npos then break end\n"
   "        pos = npos\n"
   "        t[key] = obj\n"
   "      until cont == 'last'\n"
   "      return pos, setmetatable (t, state.objectmeta)\n"
   "    end\n"
   "  \n"
   "    local Array = P\"[\" * g.Cmt (g.Carg(1) * g.Carg(2), parsearray) * Space * (P\"]\" + Err \"']' expected\")\n"
   "    local Object = P\"{\" * g.Cmt (g.Carg(1) * g.Carg(2), parseobject) * Space * (P\"}\" + Err \"'}' expected\")\n"
   "    local Value = Space * (Array + Object + SimpleValue)\n"
   "    local ExpectedValue = Value + Space * Err \"value expected\"\n"
   "    ArrayContent = Value * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
   "    local Pair = g.Cg (Space * String * Space * (P\":\" + Err \"colon expected\") * ExpectedValue)\n"
   "    ObjectContent = Pair * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
   "    local DecodeValue = ExpectedValue * g.Cp ()\n"
   "  \n"
   "    function json.decode (str, pos, nullval, ...)\n"
   "      local state = {}\n"
   "      state.objectmeta, state.arraymeta = optionalmetatables(...)\n"
   "      local obj, retpos = pegmatch (DecodeValue, str, pos, nullval, state)\n"
   "      if state.msg then\n"
   "        return nil, state.pos, state.msg\n"
   "      else\n"
   "        return obj, retpos\n"
   "      end\n"
   "    end\n"
   "  \n"
   "    -- use this function only once:\n"
   "    json.use_lpeg = function () return json end\n"
   "  \n"
   "    json.using_lpeg = true\n"
   "  \n"
   "    return json -- so you can get the module using json = require \"dkjson\".use_lpeg()\n"
   "  end\n"
   "  \n"
   "  if always_try_using_lpeg then\n"
   "    pcall (json.use_lpeg)\n"
   "  end\n"
   "  \n"
   "  return json\n"
   "  \n"
   "\n"
   "end)\n"
   "\n"
   "module(\"binding\", function()\n"
   "  local binds = {}\n"
   "  local Binding = {\n"
   "    bindings = binds,\n"
   "    require_create_userdata = false,\n"
   "    require_binding = false\n"
   "  }\n"
   "  setmetatable(binds, {__index = function(t,k)\n"
   "    if Binding.require_binding then\n"
   "      error(\"missing binding for \" .. tostring(k))\n"
   "    end\n"
   "  end})\n"
   "  --local mm = require \"mm\"\n"
   "  \n"
   "  local calls = {\n"
   "    create = function(create_callback, self, ...)\n"
   "      if type(self) ~= \"table\" then\n"
   "        return nil, (\"expected 'self' to be table, got %s)\"):format(type(self))\n"
   "      end\n"
   "      local ref = create_callback(self, ...)\n"
   "      if (Binding.require_create_userdata or ref) and type(ref) ~= \"userdata\" then\n"
   "        return nil, (\"expected userdata, got %s\"):format(type(ref))\n"
   "      elseif type(ref) == \"userdata\" then\n"
   "        self.__binding = ref\n"
   "      end\n"
   "      return true\n"
   "    end,\n"
   "    update = function(update_callback, self, delta)\n"
   "      if type(self) ~= \"table\" then\n"
   "        return nil, (\"expected self (current data) to be table, got %s)\"):format(type(self))\n"
   "      end\n"
   "      if not self.name then\n"
   "        return nil, \"can't update nameless thing\"\n"
   "      end\n"
   "      local ref = update_callback(self, delta)\n"
   "      if type(ref) == \"userdata\" then\n"
   "        self.__binding = ref\n"
   "      end\n"
   "      return true\n"
   "    end,\n"
   "    delete = function(delete_callback, self, ...)\n"
   "      if type(self) ~= \"table\" then\n"
   "        return nil, (\"expected 'self' to be table, got %s)\"):format(type(self))\n"
   "      end\n"
   "      assert(type(self.__binding) == \"userdata\", (\"expected seld.__binding userdata, got %s\"):format(type(self.__binding)))\n"
   "      delete_callback(self.__binding, self, ...)\n"
   "      return true\n"
   "    end\n"
   "  }\n"
   "  \n"
   "  function Binding.set(name, create, update, delete)\n"
   "    assert(not rawget(binds, name), (\"binding %s already set\"):format(name))\n"
   "    assert(type(name)==\"string\", \"binding name must be a string, got \" .. type(name))\n"
   "    if type(create) == \"table\" and update == nil and delete == nil then\n"
   "      local tbl = create\n"
   "      create = tbl.create\n"
   "      update = tbl.update\n"
   "      delete = tbl.delete\n"
   "    end\n"
   "    \n"
   "    local callbacks = {\n"
   "      create = create,\n"
   "      update = update,\n"
   "      delete = delete\n"
   "    }\n"
   "    \n"
   "    for n,f in pairs(callbacks) do\n"
   "      assert(type(f) == \"function\" or type(f) == nil, (\"\\\"%s\\\" binding \\\"%s\\\" callback must be function or nil, was %s\"):format(name, n, type(f)))\n"
   "    end\n"
   "    \n"
   "    binds[name]=callbacks\n"
   "  end\n"
   "  function Binding.call(binding_name, call_name, ...)\n"
   "    local callbacks = binds[binding_name]\n"
   "    if not callbacks then return end\n"
   "    local binding_call = calls[call_name]\n"
   "    if not binding_call then\n"
   "      error((\"unknown binding call \\\"%s\\\" for \\\"%s\\\"\"):format(call_name, binding_name))\n"
   "    end\n"
   "    if not callbacks[call_name] then\n"
   "      error((\"no callback for binding call \\\"%s\\\" for \\\"%s\\\"\"):format(call_name, binding_name))\n"
   "    end\n"
   "    local ok, err = binding_call(callbacks[call_name], ...)\n"
   "    if not ok then\n"
   "      error((\"Binding \\\"%s\\\" call \\\"%s\\\" error: %s\"):format(binding_name, call_name, err))\n"
   "    end\n"
   "    return ok\n"
   "  end\n"
   "  \n"
   "  return Binding\n"
   "\n"
   "end)\n"
   "\n"
   "module(\"rulecomponent\", function()\n"
   "  local Binding = require \"binding\"\n"
   "  local json = require \"dkjson\"\n"
   "  --local mm = require \"mm\"\n"
   "  \n"
   "  local Component -- forward declaration\n"
   "  \n"
   "  local function ignore_leading_hash(str)\n"
   "    return str:sub(1,1)==\"#\" and str:sub(2) or str\n"
   "  end\n"
   "  \n"
   "  local thingstorage_meta = {__index = function(self, key)\n"
   "    local unhashed = ignore_leading_hash(key)\n"
   "    if unhashed ~= key then\n"
   "      return self[ignore_leading_hash(key)]\n"
   "    end\n"
   "  end}\n"
   "  \n"
   "  local function create_thing_storage(thing_name)\n"
   "    local self = {table = setmetatable({}, thingstorage_meta)}\n"
   "    \n"
   "    local function unpack_thing(data, parser)\n"
   "      local name, val = next(data)\n"
   "      if type(name) == \"number\" then\n"
   "        parser:error(\"invalid data value, expected {\\\"key\\\":value}, got {\\\"key\\\"}\")\n"
   "      elseif type(name) ~= \"string\" then\n"
   "        parser:error(\"unexpected data type %s\", type(name))\n"
   "      end\n"
   "      local thing = self.table[name]\n"
   "      if parser then\n"
   "        parser:assert(thing, (\"Unknown %s \\\"%s\\\"\"):format(thing_name, name))\n"
   "      else\n"
   "        assert(thing, (\"Unknown %s \\\"%s\\\"\"):format(thing_name, name))\n"
   "      end\n"
   "      return name, val\n"
   "    end\n"
   "    \n"
   "    function self.add(name, funcs)\n"
   "      if type(name) == \"table\" then\n"
   "        for _,v in pairs(name) do\n"
   "          self.add(v, funcs)\n"
   "        end\n"
   "        return true\n"
   "      end\n"
   "      assert(funcs.parse, (\"%s missing parse callback\"):format(thing_name))\n"
   "      assert(self.table[name] == nil, (\"%s %s already exists\"):format(thing_name, name))\n"
   "      local added = {\n"
   "        parse=funcs.parse,\n"
   "        init=funcs.init,\n"
   "        delete=funcs.delete,\n"
   "        meta = {\n"
   "          __jsonval = funcs.jsonval,\n"
   "          __jsonorder = funcs.jsonorder or {\"action\", \"condition\"},\n"
   "          __index = {\n"
   "            toJSON = function(tbl)\n"
   "              return json.encode(tbl, {indent = true})\n"
   "            end\n"
   "          }\n"
   "        }\n"
   "      }\n"
   "      self.table[name]=added\n"
   "      \n"
   "      return true\n"
   "    end\n"
   "    \n"
   "    function self.parse(data, parser)\n"
   "      local name, val = unpack_thing(data, parser)\n"
   "      val = self.table[name].parse(val, parser) or val\n"
   "      return {[name]=val}\n"
   "    end\n"
   "    \n"
   "    function self.new(data, ruleset)\n"
   "      local name, val = unpack_thing(data)\n"
   "      name = ignore_leading_hash(name)\n"
   "      local thing_preset = self.table[name]\n"
   "      local thing = setmetatable({[thing_name]=name, data=val}, thing_preset.meta)\n"
   "      if thing_preset.init then\n"
   "        local replacement_data = thing_preset.init(val, thing, ruleset)\n"
   "        if replacement_data then\n"
   "          thing.data = replacement_data\n"
   "        end\n"
   "      end\n"
   "      Binding.call((\"%s:%s\"):format(thing_name, name), \"create\", thing)\n"
   "      return thing\n"
   "    end\n"
   "    \n"
   "    function self.delete(thing, ruleset)\n"
   "      local name = thing[thing_name] or thing.name\n"
   "      local thing_preset = self.table[name]\n"
   "      print(thing_name .. \" DELETE THING \" .. name .. \" \" .. tostring(thing_preset.delete))\n"
   "      if thing_preset.delete then\n"
   "        thing_preset.delete(thing.data, ruleset)\n"
   "      end\n"
   "      Binding.call((\"%s:%s\"):format(thing_name, name), \"delete\", thing)\n"
   "    end\n"
   "    \n"
   "    return self\n"
   "  end\n"
   "  \n"
   "  Component = {\n"
   "    condition = create_thing_storage(\"condition\"),\n"
   "    action = create_thing_storage(\"action\")\n"
   "  }\n"
   "  \n"
   "  --now let's add some basic conditions and actions\n"
   "  Component.condition.add(\"any\", {\n"
   "    parse = function(data, parser)\n"
   "      parser:assert_jsontype(data, \"array\", \"\\\"any\\\" condition value must be an array of conditions\")\n"
   "      for i, v in ipairs(data) do\n"
   "        local condition = parser:parseCondition(v)\n"
   "        data[i]=condition\n"
   "      end\n"
   "    end,\n"
   "    init = function(data, thing, ruleset)\n"
   "      for i, v in ipairs(data) do\n"
   "        data[i] = Component.condition.new(v, ruleset)\n"
   "      end\n"
   "    end,\n"
   "    delete = function(data, ruleset)\n"
   "      for _, cond in ipairs(data) do\n"
   "        Component.condition.delete(cond, ruleset)\n"
   "      end\n"
   "    end,\n"
   "    jsonval = function(self)\n"
   "      return {any=self.data}\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Component.condition.add(\"all\", {\n"
   "    parse = function(data, parser)\n"
   "      parser:assert_jsontype(data, \"array\", \"\\\"all\\\" condition value must be an array of conditions\")\n"
   "      for i, v in ipairs(data) do\n"
   "        local condition = parser:parseCondition(v)\n"
   "        data[i]=condition\n"
   "      end\n"
   "    end,\n"
   "    init = function(data, ruleset)\n"
   "      for i, v in ipairs(data) do\n"
   "        data[i] = Component.condition.new(v, ruleset)\n"
   "      end\n"
   "    end,\n"
   "    delete = function(data, ruleset)\n"
   "      for _, cond in ipairs(data) do\n"
   "        Component.condition.delete(cond, ruleset)\n"
   "      end\n"
   "    end,\n"
   "    jsonval = function(self)\n"
   "      return {all=self.data}\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Component.condition.add({\"true\", \"false\"}, {\n"
   "    parse = function(data, parser)\n"
   "    --parser:assert(next(data) == nil, \"\\\"true\\\" condition must have empty parameters\")\n"
   "    end,\n"
   "    jsonval = function(self)\n"
   "      return self.condition\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Component.condition.add(\"tag-check\", {\n"
   "    parse = function(data, parser)\n"
   "      parser:assert_type(data, \"string\", \"\\\"tag-check\\\" value must be a string\")\n"
   "      return parser:parseInterpolatedString(data)\n"
   "    end,\n"
   "    init = function(data)\n"
   "      Binding.call(\"string\", \"create\", data)\n"
   "    end,\n"
   "    delete = function(data)\n"
   "      Binding.call(\"string\", \"delete\", data)\n"
   "    end,\n"
   "    jsonval=function(self)\n"
   "      return {[\"tag-check\"]=self.data.string}\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Component.condition.add(\"match\", {\n"
   "    parse = function(data, parser)\n"
   "      parser:assert_jsontype(data, \"array\", \"\\\"match\\\" value must be an array of strings\")\n"
   "      for i, v in ipairs(data) do\n"
   "        parser:assert_jsontype(v, \"string\", \"\\\"match\\\" value must be an array of strings\")\n"
   "        data[i]=parser:parseInterpolatedString(v)\n"
   "      end\n"
   "    end,\n"
   "    init = function(data)\n"
   "      local complexity = function(str)\n"
   "        local n = 0\n"
   "        for _ in str.string:gmatch(\"%$\") do\n"
   "          n=n+1\n"
   "        end\n"
   "        return n\n"
   "      end\n"
   "      local simplefirst = function(str1, str2)\n"
   "        return complexity(str1) < complexity(str2)\n"
   "      end\n"
   "      table.sort(data, simplefirst)\n"
   "      for _, str in ipairs(data) do\n"
   "        Binding.call(\"string\", \"create\", str)\n"
   "      end\n"
   "    end,\n"
   "    delete = function(data)\n"
   "      for _, str in ipairs(data) do\n"
   "        Binding.call(\"string\", \"delete\", str)\n"
   "      end\n"
   "    end,\n"
   "    jsonval = function(self)\n"
   "      local strings = {}\n"
   "      for _, str in ipairs(self.data) do\n"
   "        table.insert(strings, str.string)\n"
   "      end\n"
   "      return {match=strings}\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  local limit_thing_meta = {__jsonorder={\"name\", \"key\", \"increment\"}}\n"
   "  \n"
   "  --limiter conditions\n"
   "  Component.condition.add({\"limit-break\", \"limit-check\"}, {\n"
   "    parse = function(data, parser)\n"
   "      if type(data) == \"string\" then\n"
   "        data = {name=data}\n"
   "      elseif type(data) ~= \"table\" then\n"
   "        parser:error(\"invalid value type %s\", type(data))\n"
   "      end\n"
   "      local condition_name = next(parser:getContext())\n"
   "      local rule = parser:getContext(\"rule\")\n"
   "      local rule_condition = parser:getContext(\"if\")\n"
   "      \n"
   "      if not data.key then\n"
   "        data.key = rule.key\n"
   "      end\n"
   "      parser:assert(data.key, \"limiter \\\"key\\\" missing, and no default \\\"key\\\" in rule\")\n"
   "      parser:assert_type(data.key, \"string\", \"invalid limiter \\\"key\\\" type\")\n"
   "      \n"
   "      data.key = parser:parseInterpolatedString(data.key)\n"
   "      \n"
   "      if not data.increment then\n"
   "        if condition_name == \"limit-break\" then\n"
   "          data.increment = 1\n"
   "        elseif condition_name == \"limit-check\" then\n"
   "          data.increment = 0\n"
   "        end\n"
   "      end\n"
   "      data.increment = parser:assert(tonumber(data.increment), \"invalid or empty \\\"increment\\\" value\")\n"
   "      parser:assert(data.increment >= 0, \"\\\"increment\\\" must be >= 0\")\n"
   "      \n"
   "      parser:assert(data.name, \"limiter name missing\")\n"
   "      parser:assert_type(data.name, \"string\", \"invalid \\\"name\\\" type\")\n"
   "      \n"
   "      if not parser:getLimiter(data.name) then\n"
   "        parser:error(\"unknown limiter \\\"%s\\\"\", data.name)\n"
   "      end\n"
   "      \n"
   "      if Component.generate_refs then\n"
   "        if not rule.refs then rule.refs = {} end\n"
   "        if not rule_condition.refs then rule_condition.refs = {} end\n"
   "        rule.refs[\"limiter:\"..data.name]=true\n"
   "        rule_condition.refs[\"limiter:\"..data.name]=true\n"
   "      end\n"
   "      \n"
   "      return data\n"
   "    end,\n"
   "    init = function(data, thing, ruleset)\n"
   "      local limiter = ruleset:findLimiter(data.name)\n"
   "      if not limiter then error(\"unknown limiter \" .. data.name) end\n"
   "      data.name = nil\n"
   "      data.limiter = limiter\n"
   "      if data.key then\n"
   "        Binding.call(\"string\", \"create\", data.key)\n"
   "      end\n"
   "    end,\n"
   "    delete = function(data)\n"
   "      if data.key then\n"
   "        Binding.call(\"string\", \"delete\", data.key)\n"
   "      end\n"
   "    end,\n"
   "    jsonval = function(self)\n"
   "      local cpy = {}\n"
   "      for k,v in pairs(self.data) do\n"
   "        cpy[k]=v\n"
   "      end\n"
   "      if cpy.derived_key then\n"
   "        cpy.derived_key = nil\n"
   "        cpy.key = nil\n"
   "      elseif cpy.key then\n"
   "        cpy.key = cpy.key.string\n"
   "      end\n"
   "      cpy.name = cpy.limiter.name\n"
   "      cpy.limiter = nil\n"
   "      setmetatable(cpy, limit_thing_meta)\n"
   "      local ret = {[self.condition]=cpy}\n"
   "      return ret\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Component.condition.add(\".delay\", {\n"
   "    parse = function(data, parser)\n"
   "      parser:assert_jsontype(data, \"number\", \"delay by <number> please\")\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  --some actions, too\n"
   "  Component.action.add(\"tag\", {\n"
   "    parse = function(data, parser)\n"
   "      parser:assert_jsontype(data, \"string\", \"\\\"tag\\\" value must be a string\")\n"
   "      return parser:parseInterpolatedString(data)\n"
   "    end,\n"
   "    init = function(data)\n"
   "      Binding.call(\"string\", \"create\", data)\n"
   "    end,\n"
   "    delete = function(data)\n"
   "      Binding.call(\"string\", \"delete\", data)\n"
   "    end,\n"
   "    jsonval = function(self)\n"
   "      return {tag=self.data.string}\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Component.action.add(\"accept\", {parse = function(data, parser)\n"
   "    parser:assert_type(data, \"table\", \"\\\"accept\\\" value must be an object\")\n"
   "    parser:assert_table_size(data, 0, \"\\\"accept\\\" value must be empty\")\n"
   "  end})\n"
   "  Component.action.add(\"reject\", {parse = function(data, parser)\n"
   "    parser:assert_type(data, \"table\", \"\\\"reject\\\" value must be an object\")\n"
   "    --parser:assert_table_size(data, 0, \"\\\"reject\\\" value must be empty\")\n"
   "  end})\n"
   "  \n"
   "  Component.action.add(\"wait\", {\n"
   "    parse = function(data, parser)\n"
   "      parser:assert_jsontype(data, \"number\", \"\\\"wait\\\" value must be a number\")\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  return Component\n"
   "\n"
   "end)\n"
   "\n"
   "module(\"parser\", function()\n"
   "  local RuleComponent = require \"rulecomponent\"\n"
   "  local json = require \"dkjson\"\n"
   "  --local mm = require \"mm\"\n"
   "  \n"
   "  local function parseRulesetThing(parser, data_in, opt)\n"
   "    local data = data_in[opt.key]\n"
   "    parser:pushContext(data, opt.key)\n"
   "    local ruleset = parser.ruleset\n"
   "    \n"
   "    if data then\n"
   "      parser:assert_type(data, opt.type, \"wrong type for ruleset %s, expected %s, got %s\", opt.key, opt.type, parser:jsontype(data))\n"
   "      local ret, err\n"
   "      for k,v in pairs(data) do\n"
   "        parser:assert_type(k, \"string\", \"wrong key type for %s, expected string, got %s %s\", opt.thing, parser:jsontype(k), tostring(k))\n"
   "        ret, err = opt.parser_method(parser, v, k)\n"
   "        parser:assert(ret, err)\n"
   "        parser:assert(ruleset[opt.key][ret.name] == nil, \"%s %s already exists\", opt.thing, ret.name)\n"
   "        ruleset[opt.key][ret.name]=ret\n"
   "      end\n"
   "    end\n"
   "    parser:popContext()\n"
   "    return true\n"
   "  end\n"
   "  \n"
   "  local function inheritmetatable(dst, src)\n"
   "    if type(dst) == type(src) then\n"
   "      setmetatable(dst, getmetatable(src))\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local getloc; do --location caching\n"
   "    local lc = setmetatable({}, {__mode=\"k\"}) -- weak keys\n"
   "    getloc = function(str, where)\n"
   "      local line, pos, linepos = 1, 1, 0\n"
   "      local prev = lc[str]\n"
   "      if prev and prev.pos < where then\n"
   "        line = prev.line\n"
   "        pos = prev.pos\n"
   "      end\n"
   "      while true do\n"
   "        pos = str:find(\"\\n\", pos, true)\n"
   "        if pos and pos < where then\n"
   "          line = line + 1\n"
   "          linepos = pos\n"
   "          pos = pos + 1\n"
   "        else\n"
   "          break\n"
   "        end\n"
   "      end\n"
   "      return line, (where - linepos) -- line, column\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function jsonmeta(what)\n"
   "    return function(str, where)\n"
   "      local line, column = getloc(str, where)\n"
   "      return {__pos=where,__line=line, __column=column,  __jsontype = what, __jsonmeta = true}\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local Parser = {}\n"
   "  \n"
   "  function Parser:jsontype(var)\n"
   "    if type(var) == \"table\" then\n"
   "      local m = getmetatable(var)\n"
   "      return m and m.__jsontype or nil\n"
   "    else\n"
   "      return type(var)\n"
   "    end\n"
   "  end\n"
   "  function Parser:assert(cond, err, ...)\n"
   "    if not cond then self:error(err, ...) end\n"
   "    return cond\n"
   "  end\n"
   "  function Parser:assert_type(var, expected_type, err, ...)\n"
   "    if err then\n"
   "      return self:assert(type(var) == expected_type, err, ...)\n"
   "    else\n"
   "      return self:assert(type(var) == expected_type, \"expected type '%s', got '%s'\", expected_type, type(var))\n"
   "    end\n"
   "  end\n"
   "  function Parser:assert_jsontype(var, expected_type, err, ...)\n"
   "    if err then\n"
   "      return self:assert(self:jsontype(var) == expected_type, err, ...)\n"
   "    else\n"
   "      return self:assert(self:jsontype(var) == expected_type,\"expected JSON type '%s', got '%s'\", expected_type, self:jsontype(var))\n"
   "    end\n"
   "  end\n"
   "  function Parser:assert_table_size(var, expected_size, err, ...)\n"
   "    self:assert_type(var, \"table\")\n"
   "    local n = 0\n"
   "    for _, _ in pairs(var) do\n"
   "      n = n + 1\n"
   "    end\n"
   "    if n ~= expected_size then\n"
   "      if err then\n"
   "        self:error(err, ...)\n"
   "      else\n"
   "        self:error(\"wrong table size, expected %i, got %i\", expected_size, n)\n"
   "      end\n"
   "    end\n"
   "    return var\n"
   "  end\n"
   "  \n"
   "  local function getlc(tbl)\n"
   "    local mt = getmetatable(tbl)\n"
   "    if mt.__line and mt.__column then\n"
   "      return mt.__line, mt.__column\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function getlc_str(tbl)\n"
   "    local line, col = getlc(tbl)\n"
   "    if line and col then\n"
   "      return (\"line %s column %i\"):format(line, col)\n"
   "    else\n"
   "      return nil\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Parser:get(what, name)\n"
   "    if     what == \"rule\" then return self:getRule(name)\n"
   "    elseif what == \"list\" then return self:getList(name)\n"
   "    elseif what == \"limiter\" then return self:getLimiter(name)\n"
   "    else\n"
   "      error(\"unknown thing to get\")\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Parser:error(err, ...)\n"
   "    \n"
   "    if not err then err = \"unknown error\" end\n"
   "    if select(\"#\", ...) > 0 then\n"
   "      err = err:format(...)\n"
   "    end\n"
   "    \n"
   "    local nested_names = {}\n"
   "    \n"
   "    for i=#self.ctx_stack,1,-1 do\n"
   "      local cur = self.ctx_stack[i]\n"
   "      if cur.name then table.insert(nested_names, cur.name) end\n"
   "      local lc_str = getlc_str(cur.ctx)\n"
   "      if lc_str then\n"
   "        if self.name then table.insert(nested_names, self.name) end\n"
   "        error((\"%s at %s: %s\"):format(table.concat(nested_names, \" in \"), lc_str, err))\n"
   "      end\n"
   "    end\n"
   "    if self.name then table.insert(nested_names, self.name) end\n"
   "    if #nested_names > 0 then\n"
   "      error((\"%s: %s\"):format(table.concat(nested_names, \" in \"), err))\n"
   "    else\n"
   "      error(err)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Parser:setInterpolationChecker(func)\n"
   "    self.interpolation_checker = func\n"
   "  end\n"
   "  function Parser:checkInterpolatedString(str)\n"
   "    if self.interpolation_checker then\n"
   "      self.interpolation_checker(str, self)\n"
   "    end\n"
   "    return true\n"
   "  end\n"
   "  \n"
   "  function Parser:pushContext(ctx, name)\n"
   "    table.insert(self.ctx_stack, {ctx=ctx, name=name})\n"
   "    self.context = self.ctx_stack[#self.ctx_stack]\n"
   "    return self\n"
   "  end\n"
   "  function Parser:popContext()\n"
   "    table.remove(self.ctx_stack, #self.ctx_stack)\n"
   "    self.context = self.ctx_stack[#self.ctx_stack]\n"
   "  end\n"
   "  function Parser:getContext(name)\n"
   "    if not name then return self.context and self.context.ctx end\n"
   "    for i=#self.ctx_stack, 1, -1 do\n"
   "      local cur = self.ctx_stack[i]\n"
   "      if cur.name==name then\n"
   "        return cur.ctx\n"
   "      end\n"
   "    end\n"
   "    return nil\n"
   "  end\n"
   "  function Parser:printContext()\n"
   "    for i=#self.ctx_stack, 1, -1 do\n"
   "      local cur = self.ctx_stack[i]\n"
   "      print(cur.name or \"<?>\", self:jsontype(cur.ctx) or \"<?>\", getlc_str(cur.ctx) or \"\")\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Parser:parseFile(path, unprotected)\n"
   "    local file, err = io.open(path, \"rb\") -- r read mode and b binary mode\n"
   "    if not file then return nil, err end\n"
   "    local content = file:read(\"*a\") -- *a or *all reads the whole file\n"
   "    file:close()\n"
   "    self.name = path\n"
   "    return self:parseJSON(\"ruleset\", content, \"file \" .. path, unprotected)\n"
   "  end\n"
   "  \n"
   "  function Parser:parseJSON(element_name, json_str, json_name, unprotected)\n"
   "    self:assert_type(json_str, \"string\", (\"expected a JSON string, got %s\"):format(type(json_str)))\n"
   "    local data, _, err = json.decode(json_str, 1, json.null, jsonmeta(\"object\"), jsonmeta(\"array\"))\n"
   "    if not self.name then self.name = json_name end\n"
   "    \n"
   "    local function parse_it()\n"
   "      if not data then self:error(\"Error parsing JSON: \" .. err) end\n"
   "      if element_name == \"ruleset\" then\n"
   "        return self:parseRuleSet(data)\n"
   "      elseif element_name == \"phase\" then\n"
   "        return self:parsePhase(data)\n"
   "      elseif element_name == \"limiter\" then\n"
   "        return self:parseLimiter(data)\n"
   "      elseif element_name == \"list\" then\n"
   "        return self:parseList(data)\n"
   "      elseif element_name == \"rule\" then\n"
   "        return self:parseRule(data)\n"
   "      end\n"
   "    end\n"
   "    \n"
   "    if unprotected then\n"
   "      return parse_it()\n"
   "    else\n"
   "      local ok, res = pcall(parse_it)\n"
   "      if not ok then\n"
   "        return nil, (res:match(\"[^:]*:%d+: (.*)\") or res)\n"
   "      else\n"
   "        return res\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Parser:parseInterpolatedString(str)\n"
   "    --validate the string\n"
   "    for sub in str:gmatch(\"%$%b{}\") do\n"
   "      if not sub:match(\"^%${[%w_]+}\") then\n"
   "        self:error(\"invalid variable \\\"%s\\\" in interpolated string\", sub)\n"
   "      end\n"
   "    end\n"
   "    for sub in str:gmatch(\"%${?[%w_]*}?\") do\n"
   "      if sub:sub(2,2) == \"{\" then\n"
   "        if sub:sub(-1) ~=\"}\" then --unterminated bracket\n"
   "          self:error(\"missing '}' in interpolated string\")\n"
   "        end\n"
   "        sub=sub:sub(3, -2)\n"
   "        if sub == \"\" then\n"
   "          self:error(\"invalid variable ${} in interpolated string\")\n"
   "        elseif sub:match(\"^%d%d+\") then\n"
   "          self:error(\"invalid regex capture \\\"%s\\\" in interpolated string. 1-9 only (nginx quirk)\", sub)\n"
   "        elseif sub:match(\"^%d.+\") then\n"
   "          self:error(\"invalid variable \\\"%s\\\" in interpolated string. can't sart with a number (nginx quirk)\", sub)\n"
   "        end\n"
   "      else\n"
   "        sub=sub:sub(2, -1)\n"
   "      end\n"
   "      if sub == \"\" then\n"
   "        self:error(\"invalid empty variable in interpolated string\")\n"
   "      end\n"
   "      \n"
   "    end\n"
   "    \n"
   "    return {string = str}\n"
   "  end\n"
   "  \n"
   "  local function attr_present(parser, data, attr_name, err)\n"
   "    local target = attr_name and data[attr_name] or data\n"
   "    if not target then\n"
   "      if parser.allow_incomplete then\n"
   "        data.incomplete = true\n"
   "        parser.incomplete = true\n"
   "      else\n"
   "        parser:error(err or \"missing required attribute \\\"%s\\\"\", attr_name)\n"
   "      end\n"
   "      return false\n"
   "    else\n"
   "      return true\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Parser:parseRuleSet(data, name)\n"
   "    self:pushContext(data, \"ruleset\")\n"
   "    \n"
   "    self:assert_type(data, \"table\", \"wrong type for ruleset\")\n"
   "    self.ruleset.name = name or data.name\n"
   "    \n"
   "    if attr_present(self, data, \"limiters\") then\n"
   "      parseRulesetThing(self, data, {\n"
   "        thing=\"limiter\", key=\"limiters\", type=\"table\",\n"
   "        parser_method= self.parseLimiter\n"
   "      })\n"
   "      self:checkLimiters(data.limiters)\n"
   "    end\n"
   "    \n"
   "    --luacheck: push ignore 432 --don't mind the shadowing\n"
   "    if attr_present(self, data, \"rules\") then\n"
   "      parseRulesetThing(self, data, {\n"
   "        thing=\"rule\", key=\"rules\",  type=\"table\",\n"
   "        parser_method=function(self, data, name)\n"
   "          self:pushContext(data, \"rule\")\n"
   "          self:assert(type(data) ~= \"string\", (\"named rule \\\"%s\\\" cannot be a string referring to another named rule \\\"%s\\\"\"):format(name, tostring(data)))\n"
   "          self:popContext()\n"
   "          return self:parseRule(data, name)\n"
   "        end\n"
   "      })\n"
   "    end\n"
   "    --luacheck: pop\n"
   "    \n"
   "    if attr_present(self, data, \"lists\") then\n"
   "      parseRulesetThing(self, data, {\n"
   "        thing=\"list\", key=\"lists\",  type=\"table\",\n"
   "        parser_method= self.parseList\n"
   "      })\n"
   "    end\n"
   "    \n"
   "    if attr_present(self, data, \"phases\") then\n"
   "      self.ruleset.phases = self:parsePhaseTable(data.phases)\n"
   "    end\n"
   "    --convert debug metatable data to __dbg table whenever possible\n"
   "    local function move_dbg_data(tbl)\n"
   "      local meta = getmetatable(tbl)\n"
   "      if meta and meta.__jsonmeta then\n"
   "        setmetatable(tbl, {line=meta.__line, col=meta.__column})\n"
   "      end\n"
   "      for _, v in pairs(tbl) do\n"
   "        if type(v) == \"table\" then\n"
   "          move_dbg_data(v)\n"
   "        end\n"
   "      end\n"
   "    end\n"
   "    move_dbg_data(self.ruleset)\n"
   "    \n"
   "    return self.ruleset\n"
   "  end\n"
   "  \n"
   "  function Parser:parsePhaseTable(data)\n"
   "    self:assert(data ~= nil, \"missing phase table (\\\"phases\\\" attribute)\")\n"
   "    self:assert_jsontype(data, \"object\", \"phase table must be an object\")\n"
   "    self:pushContext(data, \"phase table\")\n"
   "    \n"
   "    self:assert(not data.external, \"forbidden attribute \\\"external\\\"\")\n"
   "    \n"
   "    for phase_name, phase_data in pairs(data) do\n"
   "      self:assert_type(phase_name, \"string\", \"phase table entries must be strings\")\n"
   "      if self:jsontype(phase_data) == \"array\" then\n"
   "        for i, list in ipairs(phase_data) do\n"
   "          if type(list)==\"string\" or self:jsontype(list) == \"array\" or self:jsontype(list) == \"object\" then\n"
   "            phase_data[i]=self:parseList(list)\n"
   "          else\n"
   "            self:error(\"invalid rule list type: %s\", self:jsontype(list))\n"
   "          end\n"
   "        end\n"
   "      elseif type(phase_data) == \"string\" then\n"
   "        --singe named list\n"
   "        data[phase_name]={ self:parseList(phase_data) }\n"
   "      elseif self:jsontype(phase_data)==\"object\" then\n"
   "        --single long-form list\n"
   "        data[phase_name]=self:parseList(phase_data)\n"
   "      end\n"
   "    end\n"
   "    \n"
   "    self:popContext()\n"
   "    \n"
   "    return data\n"
   "  end\n"
   "  \n"
   "  function Parser:getList(name)\n"
   "    local list = self.ruleset.lists[name]\n"
   "    if not list and self.external then\n"
   "      list = self.external.lists[name]\n"
   "    end\n"
   "    return list\n"
   "  end\n"
   "  \n"
   "  function Parser:parseList(data, name)\n"
   "    if type(data)==\"string\" then\n"
   "      return self:assert(self:getList(data), ([[named list \"%s\" not found]]):format(data))\n"
   "    end\n"
   "    self:pushContext(data, \"list\")\n"
   "    local list = {}\n"
   "    if self:jsontype(data) == \"object\" then\n"
   "      self:assert(not data.external, \"forbidden attribute \\\"external\\\"\")\n"
   "      if name then\n"
   "        self:assert(name == data.name, \"rule list 'name' attribute must match outside list name\")\n"
   "      else\n"
   "        name = tostring(data.name)\n"
   "      end\n"
   "      data = data.rules\n"
   "    end\n"
   "    \n"
   "    local rules\n"
   "    \n"
   "    if attr_present(self, data, nil, \"missing rule list\") then\n"
   "      self:assert_jsontype(data, \"array\", \"rule list must be an array\")\n"
   "      rules = {}\n"
   "      for _,v in ipairs(data) do\n"
   "        table.insert(rules, self:parseRule(v))\n"
   "      end\n"
   "    end\n"
   "    self:popContext()\n"
   "    list.name=name\n"
   "    list.rules=rules\n"
   "    inheritmetatable(list, data)\n"
   "    return list\n"
   "  end\n"
   "  \n"
   "  function Parser:getRule(name)\n"
   "    local r = self.ruleset.rules[name]\n"
   "    if not r and self.external then\n"
   "      r = self.external.rules[name]\n"
   "    end\n"
   "    return r\n"
   "  end\n"
   "  \n"
   "  function Parser:parseRule(data, name)\n"
   "    self:pushContext(data, \"rule\")\n"
   "    local rule\n"
   "    if type(data) == \"string\" then\n"
   "      rule = self:getRule(data)\n"
   "      self:assert(rule, ([[named rule \"%s\" not found]]):format(data))\n"
   "      self:popContext()\n"
   "      return rule\n"
   "    end\n"
   "    self:assert_type(data, \"table\", \"invalid rule data type: \" .. type(data))\n"
   "    self:assert_jsontype(data, \"object\", (\"invalid rule data type: %s\"):format(self:jsontype(data)))\n"
   "    \n"
   "    self:assert(not data.external, \"forbidden attribute \\\"external\\\"\")\n"
   "    \n"
   "    if ((data[\"if\"] or data[\"if-any\"] or data[\"if-all\"]) or data[\"then\"]) then\n"
   "      self:assert(not data[\"always\"], [[\"always\" clause can't be present in if/then rule]])\n"
   "      self:assert(not data[\"switch\"], [[\"switch\" clause can't be present in if/then rule]])\n"
   "    end\n"
   "    \n"
   "    if data[\"then\"] then\n"
   "      if (data[\"if\"] and (data[\"if-any\"] or data[\"if-all\"])) or (data[\"if-any\"] and data[\"if-all\"]) then\n"
   "        self:error(\"only one of \\\"if\\\", \\\"if-any\\\" or \\\"if-all\\\" allowed in if/then rule\")\n"
   "      end\n"
   "      \n"
   "      local condition\n"
   "      if data[\"if\"] then\n"
   "        self:pushContext(data, \"if\")\n"
   "        condition = self:parseCondition(data[\"if\"])\n"
   "        self:popContext()\n"
   "      elseif data[\"if-any\"] or data[\"if-all\"] then\n"
   "        local conditions = {}\n"
   "        self:pushContext(data, \"if\")\n"
   "        for _, v in ipairs(data[\"if-any\"] or data[\"if-all\"]) do\n"
   "          condition = self:assert(self:parseCondition(v))\n"
   "          table.insert(conditions, condition)\n"
   "        end\n"
   "        self:popContext()\n"
   "        condition = {[(data[\"if-any\"] and \"any\" or \"all\")]=conditions}\n"
   "        inheritmetatable(condition, data[\"if\"] or data[\"if-any\"] or data[\"if-all\"])\n"
   "        data[\"if-any\"]=nil\n"
   "        data[\"if-all\"]=nil\n"
   "      end\n"
   "      data[\"if\"]=condition\n"
   "    elseif data[\"always\"] then\n"
   "      data[\"if\"]={[\"true\"]={}}\n"
   "      data[\"then\"]=data[\"always\"]\n"
   "      data[\"always\"]=nil\n"
   "    elseif next(data) == nil then\n"
   "      self:error(\"empty rule not allowed\")\n"
   "    elseif self.allow_incomplete then\n"
   "      data.incomplete = true\n"
   "      self.incomplete = true\n"
   "    else\n"
   "      self:error(\"rule must have at least an \\\"if\\\", \\\"then\\\", or \\\"always\\\" attribute\")\n"
   "    end\n"
   "    \n"
   "    if not data.name then\n"
   "      data.name = name\n"
   "    end\n"
   "    \n"
   "    if data[\"if\"] then\n"
   "      if attr_present(self, data, \"then\") then\n"
   "        data[\"then\"] = self:parseActions(data[\"then\"], \"then\")\n"
   "      end\n"
   "      if data[\"else\"] or not self.allow_incomplete then\n"
   "        data[\"else\"] = self:parseActions(data[\"else\"], \"else\")\n"
   "      end\n"
   "    end\n"
   "    if data.key then\n"
   "      data.key = self:parseInterpolatedString(data.key)\n"
   "    end\n"
   "    \n"
   "    self:popContext()\n"
   "    --reuse metatable for debugging purposes\n"
   "    return data\n"
   "  end\n"
   "  \n"
   "  function Parser:parseCondition(data)\n"
   "    self:pushContext(data, \"condition\")\n"
   "    local condition\n"
   "    if type(data) == \"string\" then\n"
   "      condition = {[data]={}}\n"
   "    elseif type(data) == \"table\" then\n"
   "      self:assert_jsontype(data, \"object\", \"condition cannot be an array, must be an object\")\n"
   "      self:assert_table_size(data, 1, \"condition object must have exactly one attribute (the condition name)\")\n"
   "      condition = data\n"
   "    else\n"
   "      self:error(\"wrong type (%s) for condition\", type(data))\n"
   "    end\n"
   "    self:popContext()\n"
   "    -- be more specific with condition name\n"
   "    self:pushContext(data, \"condition \" .. (next(condition)))\n"
   "    condition = RuleComponent.condition.parse(condition, self)\n"
   "    self:popContext()\n"
   "    inheritmetatable(condition, data)\n"
   "    return condition\n"
   "  end\n"
   "    \n"
   "  function Parser:parseAction(data)\n"
   "    self:pushContext(data, \"action\")\n"
   "    local action\n"
   "    if type(data) == \"string\" then\n"
   "      action = {[data]={}}\n"
   "    elseif self:jsontype(data) == \"object\" then\n"
   "      self:assert(next(data, next(data)) == nil, \"action object must have only 1 attribute -- the action name\")\n"
   "      action = data\n"
   "    else\n"
   "      self:error(\"action must be string on 1-attribute object, but instead was a %s\", self:jsontype(data))\n"
   "    end\n"
   "    self:popContext()\n"
   "    --we can be more specific about the action name now\n"
   "    self:pushContext(data, (\"\\\"%s\\\" action\"):format(next(action)))\n"
   "    inheritmetatable(action, data)\n"
   "    action = RuleComponent.action.parse(action, self)\n"
   "    self:popContext()\n"
   "    return action\n"
   "  end\n"
   "  \n"
   "  function Parser:parseActions(data, name)\n"
   "    if data == nil then\n"
   "      return {}\n"
   "    end\n"
   "    self:pushContext(data, name and (\"\\\"%s\\\" actions\"):format(name) or nil)\n"
   "    local actions = {}\n"
   "    inheritmetatable(actions, data)\n"
   "    if self:jsontype(data) == \"object\" or type(data)==\"string\" or (#data == 0 and next(data) ~= nil) then\n"
   "      table.insert(actions, self:parseAction(data))\n"
   "    elseif type(data) == \"table\" then\n"
   "      for _, v in ipairs(data) do\n"
   "        table.insert(actions, self:parseAction(v))\n"
   "      end\n"
   "    end\n"
   "    self:popContext()\n"
   "    return actions\n"
   "  end\n"
   "  \n"
   "  function Parser:parseTimeInterval(data, err)\n"
   "    if err then err = \" for \" .. err end\n"
   "    local typ = self:jsontype(data)\n"
   "    if typ == \"number\" then\n"
   "      return data\n"
   "    elseif typ == \"string\" then\n"
   "      local num, unit = data:match(\"^([%d.]+)([%w_]*)\")\n"
   "      local scale\n"
   "      num = tonumber(num)\n"
   "      self:assert(num and unit, (\"invalid time string \\\"%s\\\"%s\"):format(data, err))\n"
   "      if unit == \"ms\" or unit:match(\"^millisec(ond(s?))?\") then\n"
   "        scale = .01\n"
   "      elseif unit == \"\" or unit == \"s\" or unit:match(\"^sec(ond(s?))?\") then\n"
   "        scale = 1\n"
   "      elseif unit == \"m\" or unit:match(\"^min(ute(s)?)?\") then\n"
   "        scale = 60\n"
   "      elseif unit == \"h\" or unit:match(\"^hour(s?)\") then\n"
   "        scale = 3600\n"
   "      elseif unit == \"d\" or unit:match(\"^day(s)?\") then\n"
   "        scale = 86400\n"
   "      elseif unit == \"w\" or unit == \"wk\" or unit:match(\"^week(s)?\") then\n"
   "        scale = 604800\n"
   "      elseif unit == \"M\" or unit:match(\"^month(s)?\") then\n"
   "        scale = 2628001\n"
   "      else\n"
   "        self:error(\"unknown time unit \\\"%s\\\"%s\", unit, err)\n"
   "      end\n"
   "      return num * scale\n"
   "    else\n"
   "      self:error(\"invalid time inteval type \\\"%s\\\"%s\", self:jsontype(data), err)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Parser:getLimiter(name)\n"
   "    local lim = self.ruleset.limiters[name]\n"
   "    if not lim and self.external then\n"
   "      lim = self.external.limiters[name]\n"
   "    end\n"
   "    return lim\n"
   "  end\n"
   "  \n"
   "  function Parser:parseLimiter(data, name)\n"
   "    self:pushContext(data, \"limiter\")\n"
   "    \n"
   "    if not data.name then data.name = name end\n"
   "    \n"
   "    self:assert(not data.external, \"forbidden attribute \\\"external\\\"\")\n"
   "    \n"
   "    if attr_present(self, data, \"interval\") then\n"
   "      data.interval = self:parseTimeInterval(data.interval, \"interval value\")\n"
   "      self:assert(data.interval >= 60, \"\\\"interval\\\" value must be >= 60 seconds\")\n"
   "    end\n"
   "    \n"
   "    if attr_present(self, data, \"limit\") then\n"
   "      data.limit = self:assert(tonumber(data.limit), \"invalid \\\"limit\\\" value, must be a number\")\n"
   "      self:assert(data.limit >= 0, \"\\\"limit\\\" value must be >= 0\")\n"
   "    end\n"
   "    \n"
   "    if data.sync_steps then\n"
   "      data.sync_steps = self:assert(tonumber(data.sync_steps), \"invalid \\\"sync-steps\\\" value\")\n"
   "    end\n"
   "    if data.burst then\n"
   "      self:assert_type(data.burst, \"string\", \"invalid \\\"burst\\\" value type\")\n"
   "    end\n"
   "    if data[\"burst-expire\"] then\n"
   "      data.burst_expire = self:parseTimeInterval(data[\"burst-expire\"], \"burst_expire value\")\n"
   "      data[\"burst-expire\"] = nil\n"
   "    end\n"
   "    \n"
   "    self:assert_type(data.name, \"string\", \"invalid limiter name\")\n"
   "    self:popContext()\n"
   "    return data\n"
   "  end\n"
   "  function Parser:checkLimiters(data)\n"
   "    if not data then return true end\n"
   "    self:pushContext(data, \"limiters\")\n"
   "    for _, v in pairs(data) do\n"
   "      self:pushContext(v, (\"limiter \\\"%s\\\"\"):format(v.name))\n"
   "      if v.burst then\n"
   "        --make sure the burst value refers to a known limiter\n"
   "        self:assert(data[v.burst], (\"limiter references unknown burst limiter \\\"%s\\\"\"):format(v.burst))\n"
   "      end\n"
   "      self:popContext()\n"
   "    end\n"
   "    self:popContext()\n"
   "  end\n"
   "  \n"
   "  local Parser_meta = {__index = Parser}\n"
   "  \n"
   "  local function newparser(opt)\n"
   "    local parser = {\n"
   "      name = \"<?>\",\n"
   "      ctx_stack = {},\n"
   "      ruleset = {\n"
   "        limiters = {},\n"
   "        rules = {},\n"
   "        lists = {},\n"
   "        phases ={},\n"
   "      }\n"
   "    }\n"
   "    \n"
   "    opt = opt or {}\n"
   "    if opt.external then\n"
   "      parser.external = {}\n"
   "      for k, n in pairs{lists=\"list\", rules=\"rule\", limiters=\"limiter\"} do\n"
   "        local fn = opt.external[n]\n"
   "        parser.external[k]=setmetatable({}, {__index = function(tbl, key)\n"
   "          local ret = fn(parser, key)\n"
   "          if ret then\n"
   "            if type(ret) ~= \"table\" then\n"
   "              ret = {name=key, external=true}\n"
   "            else\n"
   "              ret.external = true\n"
   "              if not ret.name then ret.name = key end\n"
   "            end\n"
   "          end\n"
   "          tbl[key]=ret\n"
   "          return ret\n"
   "        end})\n"
   "      end\n"
   "    end\n"
   "    if opt.allow_incomplete then\n"
   "      parser.allow_incomplete = true\n"
   "    end\n"
   "  \n"
   "    setmetatable(parser, Parser_meta)\n"
   "    return parser\n"
   "  end\n"
   "  \n"
   "  return {\n"
   "    new = newparser,\n"
   "    RuleComponent = RuleComponent\n"
   "  }\n"
   "\n"
   "end)\n"
   "\n"
   "module(\"ruleset\", function()\n"
   "  local RuleComponent = require \"rulecomponent\"\n"
   "  local Binding = require \"binding\"\n"
   "  local json = require \"dkjson\"\n"
   "  --local mm = require \"mm\"\n"
   "  \n"
   "  --local inspect = require \"inspect\"\n"
   "  \n"
   "  --luacheck: globals redis cjson ARGV unpack\n"
   "  --[[local hmm = function(thing)\n"
   "    local out = inspect(thing)\n"
   "    for line in out:gmatch('[^\\r\\n]+') do\n"
   "      if redis then\n"
   "        redis.call(\"ECHO\", line)\n"
   "      end\n"
   "    end\n"
   "  end]]\n"
   "  \n"
   "  local Module -- forward declaration\n"
   "  \n"
   "  local tcopy = function(tbl, skipmetatable)\n"
   "    local cpy = {}\n"
   "    for k,v in pairs(tbl) do\n"
   "      cpy[k]=v\n"
   "    end\n"
   "    if skipmetatable then\n"
   "      return cpy\n"
   "    else\n"
   "      return setmetatable(cpy, getmetatable(tbl))\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function assert_unique_name(what, tbl, data)\n"
   "    assert(data.name, (\"a %s must have a name\"):format(what))\n"
   "    assert(not tbl[data.name], (\"%s \\\"%s\\\" already exists\"):format(what, data.name))\n"
   "  end\n"
   "  \n"
   "  local function thing_name(thing)\n"
   "    if type(thing)==\"string\" then\n"
   "      return thing\n"
   "    elseif type(thing) == \"table\" then\n"
   "      return thing.name\n"
   "    else\n"
   "      return thing\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function table_copy(tbl, exclude_keys)\n"
   "    local cpy = {}\n"
   "    setmetatable(cpy, getmetatable(tbl))\n"
   "    for k,v in pairs(tbl) do\n"
   "      if not exclude_keys[k] then\n"
   "        cpy[k]=v\n"
   "      end\n"
   "    end\n"
   "    return cpy\n"
   "  end\n"
   "  \n"
   "  local function sorted_keys(tbl)\n"
   "    local keys = {}\n"
   "    for k in pairs(tbl) do\n"
   "      table.insert(keys, k)\n"
   "    end\n"
   "    table.sort(keys)\n"
   "    return keys\n"
   "  end\n"
   "  \n"
   "  local Ruleset = {} --forward declaration\n"
   "  \n"
   "  local mt = {}\n"
   "  \n"
   "  mt.ruleset = {\n"
   "    __index = Ruleset,\n"
   "    __jsonorder = {\"name\", \"info\", \"phases\", \"limiters\", \"lists\", \"rules\"}\n"
   "  }\n"
   "    \n"
   "  mt.phase = {\n"
   "    new = function(name, data)\n"
   "      return setmetatable({name=name, lists=data}, mt.phase)\n"
   "    end,\n"
   "    __index = {\n"
   "      toJSON = function(self)\n"
   "        return json.encode(self, {indent=true})\n"
   "      end\n"
   "    },\n"
   "    __jsonval = function(self)\n"
   "      local lists = {}\n"
   "      for _, list in pairs(self.lists) do\n"
   "        table.insert(lists, list.name)\n"
   "      end\n"
   "      return lists\n"
   "    end\n"
   "  }\n"
   "    \n"
   "  mt.rules={__jsonorder=sorted_keys}\n"
   "  mt.lists={__jsonorder=sorted_keys}\n"
   "  mt.limiters={__jsonorder=sorted_keys}\n"
   "    \n"
   "  mt.list = {\n"
   "    new = function(data)\n"
   "      return setmetatable(data, mt.list)\n"
   "    end,\n"
   "    __index = {\n"
   "      toJSON = function(self)\n"
   "        return json.encode(self, {indent=true})\n"
   "      end\n"
   "    },\n"
   "    __jsonorder = {\"name\", \"info\", \"rules\"},\n"
   "    __jsonval = function(self)\n"
   "      local rules = {}\n"
   "      for _, rule in pairs(self.rules) do\n"
   "        table.insert(rules, rule.name)\n"
   "      end\n"
   "      \n"
   "      if self.info then\n"
   "        return setmetatable({info=self.info, rules=rules}, getmetatable(self))\n"
   "      else\n"
   "        return setmetatable(rules, getmetatable(self))\n"
   "      end\n"
   "    end\n"
   "  }\n"
   "  \n"
   "  local actions_array_meta = {__index = {toJSON=function(self) return json.encode(self, {indent = true}) end}}\n"
   "  mt.rule = {\n"
   "    new = function(data, ruleset)\n"
   "      local rule =setmetatable(data, mt.rule)\n"
   "      if data[\"if\"] then\n"
   "        data[\"if\"] = RuleComponent.condition.new(rule[\"if\"], ruleset)\n"
   "      end\n"
   "      \n"
   "      for _,clause in pairs{\"then\", \"else\"} do\n"
   "        if data[clause] then\n"
   "          local actions = setmetatable({}, actions_array_meta)\n"
   "          for _,v in pairs(data[clause]) do\n"
   "            table.insert(actions, RuleComponent.action.new(v, ruleset))\n"
   "          end\n"
   "          data[clause]=actions\n"
   "        end\n"
   "      end\n"
   "      return data\n"
   "    end,\n"
   "    __index = {\n"
   "      toJSON = function(self)\n"
   "        return json.encode(self, {indent=true})\n"
   "      end\n"
   "    },\n"
   "    __jsonorder = {\"name\", \"info\", \"key\", \"if\", \"if-any\", \"if-all\", \"then\", \"else\"},\n"
   "    __jsonval = function(self)\n"
   "      if #self[\"else\"] <= 1 or #self[\"then\"] <= 1 or self.key or self[\"if\"].condition == \"any\" or self[\"if\"].condition == \"all\" or self[\"refs\"] then\n"
   "        local ret = tcopy(self)\n"
   "        if self[\"if\"].condition == \"any\" then ret[\"if-any\"] = ret[\"if\"].data; ret[\"if\"] = nil end\n"
   "        if self[\"if\"].condition == \"all\" then ret[\"if-all\"] = ret[\"if\"].data; ret[\"if\"] = nil end\n"
   "        if #self[\"then\"] == 0 then ret[\"then\"] = nil end\n"
   "        if #self[\"then\"] == 1 then ret[\"then\"] = self[\"then\"][1] end\n"
   "        if #self[\"else\"] == 0 then ret[\"else\"] = nil end\n"
   "        if #self[\"else\"] == 1 then ret[\"else\"] = self[\"else\"][1] end\n"
   "        if self.key then self.key = self.key.string end\n"
   "        if ret.refs then ret.refs = nil end\n"
   "        return ret\n"
   "      end\n"
   "      return self\n"
   "    end\n"
   "  }\n"
   "    \n"
   "  mt.limiter = {\n"
   "    new = function(data)\n"
   "      return setmetatable(data, mt.limiter)\n"
   "    end,\n"
   "    __index = {\n"
   "      toJSON = function(self)\n"
   "        return json.encode(self, {indent=true})\n"
   "      end\n"
   "    },\n"
   "    __jsonorder = {\"name\", \"info\", \"limit\", \"interval\", \"burst\", \"burst-expire\"},\n"
   "    __jsonval = function(self)\n"
   "      if self.burst then\n"
   "        local cpy = tcopy(self)\n"
   "        cpy.burst = cpy.burst[\"name\"]\n"
   "        return cpy\n"
   "      end\n"
   "      return self\n"
   "    end\n"
   "  }\n"
   "  \n"
   "  local function updateThing(self, thing_type, findThing, name, data)\n"
   "    --assumes data is already valid\n"
   "    assert(type(thing_type)==\"string\", \"wrong thing_type type\")\n"
   "    assert(type(name)==\"string\", \"wrong name type\")\n"
   "    local thing = findThing(self, name)\n"
   "    if not thing then return nil, (\"%s \\\"%s\\\" not found.\"):format(thing_type, name) end\n"
   "    local delta = {}\n"
   "    for k, v in pairs(data) do\n"
   "      delta[k]={old=thing[k], new=v}\n"
   "      thing[k]=v\n"
   "    end\n"
   "    --hmm(delta)\n"
   "    if next(delta) then --at least one thing to update\n"
   "      Binding.call(thing_type, \"update\", thing, delta)\n"
   "    end\n"
   "    return thing\n"
   "  end\n"
   "  \n"
   "  function Ruleset:findLimiter(name)\n"
   "    return self.limiters[thing_name(name)]\n"
   "  end\n"
   "  function Ruleset:addLimiter(data, limiters_in)\n"
   "    if data.__already_loaded_as_burst_limiter then\n"
   "      data.__already_loaded_as_burst_limiter = nil\n"
   "      return nil\n"
   "    end\n"
   "    if not data.external then\n"
   "      assert_unique_name(\"limiter\", self.limiters, data)\n"
   "    end\n"
   "    local limiter = mt.limiter.new(data)\n"
   "    self.limiters[data.name]=limiter\n"
   "    if limiter.burst then\n"
   "      local burst_limiter = self:findLimiter(limiter.burst)\n"
   "      if not burst_limiter then\n"
   "        burst_limiter = self:addLimiter(limiters_in[limiter.burst], limiters_in)\n"
   "        limiters_in[limiter.burst].__already_loaded_as_burst_limiter = true\n"
   "        limiter.burst = burst_limiter\n"
   "      end\n"
   "    end\n"
   "    Binding.call(\"limiter\", \"create\", limiter)\n"
   "    return limiter\n"
   "  end\n"
   "  function Ruleset:updateLimiter(name, data)\n"
   "    if data.burst then\n"
   "      local burst = self:findLimiter(data.burst)\n"
   "      assert(burst, (\"unknown burst limiter \\\"%s\\\"\"):format(thing_name(data.burst)))\n"
   "      data.burst = burst\n"
   "    end\n"
   "  \n"
   "    return updateThing(self, \"limiter\", self.findLimiter, name, data)\n"
   "  end\n"
   "  function Ruleset:deleteLimiter(limiter)\n"
   "    assert(self.limiters[limiter.name] == limiter, \"tried deleting unexpected limiter of the same name\")\n"
   "    --TODO: check which rules use this limiter\n"
   "    self.limiters[limiter.name] = nil\n"
   "    \n"
   "    Binding.call(\"limiter\", \"delete\", limiter)\n"
   "  end\n"
   "  \n"
   "  function Ruleset:findRule(name)\n"
   "    return self.rules[thing_name(name)]\n"
   "  end\n"
   "  \n"
   "  function Ruleset:addRule(data)\n"
   "    if not data.name then\n"
   "      data.name = self:uniqueName(\"rule\")\n"
   "    elseif not data.external then\n"
   "      assert_unique_name(\"rule\", self.rules, data)\n"
   "    end\n"
   "    local rule = mt.rule.new(data, self)\n"
   "    self.rules[data.name]=rule\n"
   "    Binding.call(\"rule\", \"create\", rule)\n"
   "    return rule\n"
   "  end\n"
   "  function Ruleset:updateRule(name, data)\n"
   "    --hmm(\"updating... make new rule\")\n"
   "    local newRule = mt.rule.new(data, self)\n"
   "    --hmm(\"...ok\")\n"
   "    return updateThing(self, \"rule\", self.findRule, name, newRule)\n"
   "  end\n"
   "  function Ruleset:deleteRule(rule)\n"
   "    assert(self.rules[rule.name] == rule, \"tried deleting unexpected rule of the same name\")\n"
   "    for list_name, list in pairs(self.lists) do\n"
   "      for _, list_rule in ipairs(list) do\n"
   "        assert(list_rule ~= rule, (\"can't delete rule \\\"%s\\\", it's used in list \\\"%s\\\"\"):format(rule.name, list_name))\n"
   "      end\n"
   "    end\n"
   "    \n"
   "    self.rules[rule.name] = nil\n"
   "    \n"
   "    if rule[\"if\"] then\n"
   "      RuleComponent.condition.delete(rule[\"if\"], self)\n"
   "    end\n"
   "    \n"
   "    for _,clause in pairs{\"then\", \"else\"} do\n"
   "      if rule[clause] then\n"
   "        local actions = rule[clause]\n"
   "        for _,action in pairs(actions) do\n"
   "          RuleComponent.action.delete(action, self)\n"
   "        end\n"
   "        rule[clause]={}\n"
   "      end\n"
   "    end\n"
   "    Binding.call(\"rule\", \"delete\", rule)\n"
   "  end\n"
   "  \n"
   "  function Ruleset:findList(name)\n"
   "    return self.lists[thing_name(name)]\n"
   "  end\n"
   "  \n"
   "  function Ruleset:addList(data)\n"
   "    assert(data.rules)\n"
   "    if not data.name then\n"
   "      data.name = self:uniqueName(\"list\")\n"
   "    elseif not data.external then\n"
   "      assert_unique_name(\"list\", self.lists, data)\n"
   "    end\n"
   "    \n"
   "    for i, rule_data in ipairs(data.rules) do\n"
   "      data.rules[i]= self:findRule(rule_data.name) or self:addRule(rule_data)\n"
   "    end\n"
   "    local list = mt.list.new(data)\n"
   "    self.lists[data.name] = list\n"
   "    Binding.call(\"list\", \"create\", list)\n"
   "    return list\n"
   "  end\n"
   "  function Ruleset:updateList(name, data)\n"
   "    if data.insertRule then\n"
   "      local list = assert(self:findList(name or data.name), \"List not found\")\n"
   "      local rule = assert(self:findRule(data.insertRule.name), \"Rule to insert not found\")\n"
   "      assert(data.insertRule.index, \"Rule index missing\")\n"
   "      if list.rules then\n"
   "        table.insert(list.rules, data.insertRule.index or #list.rules, rule)\n"
   "      end\n"
   "      Binding.call(\"list\", \"update\", list, {insertRule = data.insertRule})\n"
   "      data.insertRule = nil\n"
   "    end\n"
   "    if data.removeRule then\n"
   "      local list = assert(self:findList(name or data.name), \"List not found\")\n"
   "      assert(tonumber(data.removeRule.index), \"Rule index missing or not a number\")\n"
   "      if list.rules then\n"
   "        table.remove(list.rules, data.removeRule.index)\n"
   "      end\n"
   "      Binding.call(\"list\", \"update\", list, {removeRule=data.removeRule})\n"
   "      data.removeRule = nil\n"
   "    end\n"
   "    if data.rules then\n"
   "      data = data.rules\n"
   "      if data.name then assert(name == data.name) end\n"
   "    end\n"
   "    for i, rule_data in ipairs(data.rules) do\n"
   "      data.rules[i]= self:findRule(rule_data.name) or self:addRule(rule_data)\n"
   "    end\n"
   "    \n"
   "    return updateThing(self, \"list\", self.findList, name, data)\n"
   "  end\n"
   "  function Ruleset:deleteList(list)\n"
   "    assert(self.lists[list.name] == list, \"tried deleting unexpected list of the same name\")\n"
   "    for phase_name, phase in pairs(self.phases) do\n"
   "      for _, phase_list in ipairs(phase) do\n"
   "        assert(phase_list ~= list, (\"can't delete list \\\"%s\\\", it's used in phase \\\"%s\\\"\"):format(list.name, phase_name))\n"
   "      end\n"
   "    end\n"
   "    self.lists[list.name] = nil\n"
   "    Binding.call(\"list\", \"delete\", list)\n"
   "  end\n"
   "  \n"
   "  local possible_phases = {request=true}\n"
   "  function Ruleset:addPhase(data, name)\n"
   "    local lists\n"
   "    if data.name then -- {name: phaseName, lists: [...]}\n"
   "      if name then assert(name == data.name) end\n"
   "      lists = data.lists\n"
   "    else  -- [ lists ]\n"
   "      assert(name)\n"
   "      lists = data\n"
   "    end\n"
   "    \n"
   "    assert(possible_phases[name], (\"unknown phase \\\"%s\\\"\"):format(name))\n"
   "    assert(not self.phases[name], (\"phase \\\"%s\\\" already exists\"):format(name))\n"
   "    \n"
   "    local err\n"
   "    for i, list in ipairs(lists) do\n"
   "      if type(list) == \"string\" then\n"
   "        list, err = self:findList(list)\n"
   "      else\n"
   "        local found_list = self:findList(list)\n"
   "        if found_list then\n"
   "          list = found_list\n"
   "        else\n"
   "          list, err = self:addList(list)\n"
   "        end\n"
   "      end\n"
   "      if not list then return nil, err or (\"can't find list \\\"%s\\\" for phase \\\"%s\\\"\"):format(list, name) end\n"
   "      lists[i]=list\n"
   "    end\n"
   "    local phase = mt.phase.new(name, lists)\n"
   "    Binding.call(\"phase\", \"create\", phase)\n"
   "    return phase\n"
   "  end\n"
   "  function Ruleset:deletePhase(name)\n"
   "    local phase = assert(self.phases[name], (\"phase \\\"%s\\\" does not exist\"):format(name))\n"
   "    Binding.call(\"phase\", \"delete\", phase)\n"
   "    self.phases[name]=nil\n"
   "  end\n"
   "  \n"
   "  function Ruleset:uniqueName(thing)\n"
   "    local uniqs = {\n"
   "      ruleset = {},\n"
   "      rule = self.rules,\n"
   "      list = self.lists,\n"
   "      limiter = self.limiters\n"
   "    }\n"
   "    local checktbl = uniqs[thing]\n"
   "    if checktbl == nil then\n"
   "      error(\"don't knoq how to generate unique name for \" .. tostring(thing))\n"
   "    end\n"
   "    \n"
   "    return assert(Module.uniqueName(thing, checktbl, self), \"unique name can't be nil\")\n"
   "  end\n"
   "  \n"
   "  function Ruleset:toJSON()\n"
   "    local rs = {\n"
   "      name = self.name,\n"
   "      info = self.info,\n"
   "      rules = tcopy(self.rules),\n"
   "      lists = tcopy(self.lists),\n"
   "      limiters = tcopy(self.limiters),\n"
   "      phases = self.phases,\n"
   "    }\n"
   "    setmetatable(rs, mt.ruleset)\n"
   "    \n"
   "    --remove inlined names from rules, lists, and limiters\n"
   "    local excludes = {name=true}\n"
   "    for _, thingsname in ipairs({\"rules\", \"lists\", \"limiters\", \"phases\"}) do\n"
   "      local things = rs[thingsname] or {}\n"
   "      for k, thing in pairs(things) do\n"
   "        things[k]=table_copy(thing, excludes)\n"
   "      end\n"
   "    end\n"
   "    \n"
   "    return json.encode(rs, {indent=true})\n"
   "  end\n"
   "  \n"
   "  function Ruleset:destroy()\n"
   "    --clear phases\n"
   "    for name, _ in pairs(self.phases) do\n"
   "      self:deletePhase(name)\n"
   "    end\n"
   "    \n"
   "    --clear lists\n"
   "    for _, list in pairs(self.lists) do\n"
   "      self:deleteList(list)\n"
   "    end\n"
   "    \n"
   "    --clear rules\n"
   "    for _, rule in pairs(self.rules) do\n"
   "      self:deleteRule(rule)\n"
   "    end\n"
   "    \n"
   "    --clear limiters\n"
   "    for _, limiter in pairs(self.limiters) do\n"
   "      self:deleteLimiter(limiter)\n"
   "    end\n"
   "    \n"
   "    Binding.call(\"ruleset\", \"delete\", self)\n"
   "    \n"
   "  end\n"
   "  \n"
   "  Module = {\n"
   "    new = function(data)\n"
   "      local ruleset = setmetatable({\n"
   "        rules=setmetatable({}, mt.rules),\n"
   "        lists=setmetatable({}, mt.lists),\n"
   "        limiters=setmetatable({}, mt.limiters),\n"
   "        phases=setmetatable({}, mt.phases),\n"
   "        name = data and data.name or nil\n"
   "      }, mt.ruleset)\n"
   "  \n"
   "      if not ruleset.name then ruleset.name = ruleset:uniqueName(\"ruleset\") end\n"
   "      \n"
   "      if data then\n"
   "        --load data\n"
   "        if data.external then ruleset.external = true end\n"
   "        \n"
   "        for _, v in pairs(data.limiters or {}) do\n"
   "          ruleset:addLimiter(v, data.limiters)\n"
   "        end\n"
   "        \n"
   "        for _, v in pairs(data.rules or {}) do\n"
   "          ruleset:addRule(v)\n"
   "        end\n"
   "        \n"
   "        for _, v in pairs(data.lists or {}) do\n"
   "          ruleset:addList(v)\n"
   "        end\n"
   "        \n"
   "        for n, v in pairs(data.phases or {}) do\n"
   "          ruleset:addPhase(v, n)\n"
   "        end\n"
   "        \n"
   "      end\n"
   "      Binding.call(\"ruleset\", \"create\", ruleset)\n"
   "      return ruleset\n"
   "    end,\n"
   "    newLimiter = mt.limiter.new,\n"
   "    newPhase = mt.phase.new,\n"
   "    newList = mt.list.new,\n"
   "    newRule = mt.rule.new,\n"
   "    \n"
   "    uniqueName = function(thingname, checktbl, ruleset)\n"
   "      error(\"uniqueName must be configured outside the Ruleset module\")\n"
   "    end,\n"
   "    \n"
   "    RuleComponent = RuleComponent\n"
   "  }\n"
   "  \n"
   "  return Module\n"
   "  \n"
   "\n"
   "end)\n"
   "\n"
   "module(\"ruleset_read\", function()\n"
   "  \n"
   "  --luacheck: globals redis cjson\n"
   "  \n"
   "  local encode = cjson.encode\n"
   "  local decode = cjson.decode\n"
   "  local tinsert = table.insert\n"
   "  \n"
   "  local Jsonobj; do\n"
   "    local Jmeta = {__index = {\n"
   "      use = function(self, ...)\n"
   "        for _, k in ipairs {...} do\n"
   "          local val\n"
   "          if type(k) == \"table\" then\n"
   "            val = k[2](self.data[k[1]])\n"
   "            k = k[1]\n"
   "          else\n"
   "            val = self.data[k]\n"
   "          end\n"
   "          self:add(k, val)\n"
   "        end\n"
   "      end,\n"
   "      useRaw = function(self, ...)\n"
   "        for _, k in ipairs {...} do\n"
   "          self:addRaw(k, self.data[k])\n"
   "        end\n"
   "      end,\n"
   "      add = function(self, key, data, raw)\n"
   "        if data == nil then return end\n"
   "        if not raw then data = encode(data) end\n"
   "        tinsert(self.buf, (\"%s: %s\"):format(encode(key), data))\n"
   "      end,\n"
   "      addRaw = function(self, key, data)\n"
   "        return self:add(key, data, true)\n"
   "      end,\n"
   "      json = function(self)\n"
   "        return (\"{ %s }\"):format(table.concat(self.buf, \", \\n\"))\n"
   "      end\n"
   "    }}\n"
   "    Jsonobj = function(data)\n"
   "      return setmetatable({buf={}, data=data or {}}, Jmeta)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local kbase, key, keyf, current_ruleset_name, current_prefix\n"
   "  local function genkeys(prefix, ruleset_name)\n"
   "    if current_ruleset_name == ruleset_name and current_prefix == prefix then return end\n"
   "    kbase = (\"%sruleset:%s\"):format(prefix, ruleset_name)\n"
   "    key = {\n"
   "      rulesets = prefix..\"rulesets\",\n"
   "      ruleset =  kbase,\n"
   "      phases =   kbase..\":phases\",\n"
   "      lists =    kbase..\":lists\",\n"
   "      rules =    kbase..\":rules\",\n"
   "      limiters = kbase..\":limiters\"\n"
   "    }\n"
   "    keyf = {\n"
   "      list =         key.ruleset..\":list:%s\",\n"
   "      list_rules =   key.ruleset..\":list:%s:rules\",\n"
   "      list_refs =    key.ruleset..\":list:%s:refs\",\n"
   "      \n"
   "      rule =         key.ruleset..\":rule:%s\",\n"
   "      rule_refs =    key.ruleset..\":rule:%s:refs\",\n"
   "      \n"
   "      limiter =      key.ruleset..\":limiter:%s\",\n"
   "      limiter_refs = key.ruleset..\":limiter:%s:refs\",\n"
   "      \n"
   "      phase =        key.ruleset..\":phase:%s\",\n"
   "      phase_lists =  key.ruleset..\":phase:%s:lists\"\n"
   "    }\n"
   "    current_prefix = prefix\n"
   "    current_ruleset_name = ruleset_name\n"
   "  end\n"
   "  \n"
   "  local function redis_gethash(redis_key)\n"
   "    local res = redis.call(\"HGETALL\", redis_key)\n"
   "    if type(res)~=\"table\" then return nil end\n"
   "    local h, k = {}, nil\n"
   "    for _, v in ipairs(res) do\n"
   "      if k == nil then k=v\n"
   "      else h[k]=v; k=nil end\n"
   "    end\n"
   "    return h\n"
   "  end\n"
   "  \n"
   "  local function get_thing(prefix, ruleset_name, item, item_name, want_json, incomplete)\n"
   "    genkeys(prefix, ruleset_name)\n"
   "    local j\n"
   "    if item == \"rule\" then\n"
   "      local rule = redis_gethash(keyf.rule:format(item_name))\n"
   "      if not rule then return nil end\n"
   "      if want_json then\n"
   "        j = Jsonobj(rule)\n"
   "        j:use(\"name\",\"info\",{\"gen\", tonumber}, \"key\")\n"
   "        j:useRaw(\"if\", \"then\", \"else\")\n"
   "        return j:json()\n"
   "      else\n"
   "        for _, k in ipairs{\"if\", \"then\", \"else\"} do\n"
   "          if rule[k] then rule[k]=decode(rule[k]) end\n"
   "        end\n"
   "        rule.gen = tonumber(rule.gen)\n"
   "        return rule\n"
   "      end\n"
   "    elseif item == \"limiter\" then\n"
   "      local lim = redis_gethash(keyf.limiter:format(item_name))\n"
   "      if not lim then return nil end\n"
   "      if want_json then\n"
   "        j = Jsonobj(lim)\n"
   "        j:use(\"name\",\"info\", {\"gen\", tonumber}, {\"interval\", tonumber}, {\"limit\", tonumber}, {\"sync-steps\", tonumber}, \"burst\", {\"burst-expire\", tonumber})\n"
   "        return j:json()\n"
   "      else\n"
   "        lim.gen = tonumber(lim.gen)\n"
   "        lim.interval = tonumber(lim.interval)\n"
   "        lim.limit = tonumber(lim.limit)\n"
   "        lim[\"sync-steps\"] = tonumber(lim[\"sync-steps\"])\n"
   "        lim[\"burst-expire\"] = tonumber(lim[\"burst-expire\"])\n"
   "        return lim\n"
   "      end\n"
   "    elseif item == \"list\" then\n"
   "      local list = redis_gethash(keyf.list:format(item_name))\n"
   "      if not list then return nil end\n"
   "      if want_json then\n"
   "        j = Jsonobj(list)\n"
   "        j:use(\"name\",\"info\",{\"gen\", tonumber})\n"
   "        local ll = redis.call(\"LRANGE\", keyf.list_rules:format(item_name), 0, -1)\n"
   "        if ll and #ll > 0 then\n"
   "          j:add(\"rules\", ll)\n"
   "        else\n"
   "          j:addRaw(\"rules\", \"[]\")\n"
   "        end\n"
   "        return j:json()\n"
   "      else\n"
   "        list.gen = tonumber(list.gen)\n"
   "        if not incomplete then\n"
   "          list.rules = redis.call(\"LRANGE\", keyf.list_rules:format(item_name), 0, -1)\n"
   "        else\n"
   "          list.incomplete = true\n"
   "          list.external = true\n"
   "        end\n"
   "        return list\n"
   "      end\n"
   "    elseif item == \"phase\" then\n"
   "      local ll = redis.call(\"LRANGE\", keyf.phase_lists:format(item_name), 0, -1)\n"
   "      if want_json then\n"
   "        return #ll > 0 and encode(ll) or \"[]\"\n"
   "      else\n"
   "        return ll\n"
   "      end\n"
   "    elseif item == \"ruleset\" then\n"
   "      local rs = redis_gethash(key.ruleset)\n"
   "      if not rs then return nil end\n"
   "      \n"
   "      rs.gen = tonumber(rs.gen)\n"
   "      \n"
   "      local function add_ruleset_items(the_item, items_set_key, attribute)\n"
   "        local member_names = redis.call(\"SMEMBERS\", items_set_key)\n"
   "        \n"
   "        if want_json then\n"
   "          local jj = Jsonobj()\n"
   "          table.sort(member_names)\n"
   "          for _, n in ipairs(member_names) do\n"
   "            jj:addRaw(n, get_thing(prefix, ruleset_name, the_item, n, want_json, incomplete))\n"
   "          end\n"
   "          j:addRaw(attribute, jj:json())\n"
   "        else\n"
   "          local members = {}\n"
   "          for _, n in ipairs(member_names) do\n"
   "            members[n]=get_thing(prefix, ruleset_name, the_item, n, want_json, incomplete)\n"
   "          end\n"
   "          rs[attribute]=members\n"
   "        end\n"
   "      end\n"
   "      \n"
   "      if want_json then\n"
   "        j = Jsonobj(rs)\n"
   "        j:use(\"name\",\"info\",{\"gen\", tonumber})\n"
   "      end\n"
   "        \n"
   "      add_ruleset_items(\"limiter\", key.limiters, \"limiters\")\n"
   "      add_ruleset_items(\"phase\", key.phases, \"phases\")\n"
   "      add_ruleset_items(\"list\", key.lists, \"lists\")\n"
   "      add_ruleset_items(\"rule\", key.rules, \"rules\")\n"
   "        \n"
   "      return want_json and j:json() or rs\n"
   "      \n"
   "    else\n"
   "      error(\"unknown thing we want here: \" .. tostring(item))\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  return get_thing\n"
   "\n"
   "end)\n"
   "\n"
   "\n"
   "return main()\n"}
};
const int wfx_redis_lua_scripts_count=3;
