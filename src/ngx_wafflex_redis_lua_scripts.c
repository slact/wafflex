#include <ngx_wafflex_redis_lua_scripts.h>

wfx_redis_lua_scripts_t wfx_redis_lua_scripts = {
  {"_parser_main", "f4515935d2a73f62cb3c1743640cba78ccd4220f",
   "local json = require \"dkjson\"\n"
   "local Parser = require \"parser\"\n"
   "\n"
   "--luacheck: globals redis\n"
   "\n"
   "\n"
   "redis.command(\"echo\", tostring(Parser) .. tostring(json))\n"
   "return 27\n"},

  {"init", "4f7d624f703483b37d89af715d7230c2ea24a95c",
   "\n"
   "--luacheck: globals redis\n"
   "\n"
   "redis.echo(\"hi there\")\n"
   "return \"hello\"\n"},

  {"parser", "55f4fbebbe89f666358549199405828eef61efa6",
   "--autogenerated script, do not edit\n"
   "local require, module; do\n"
   "  local modules = {}\n"
   "  module = function(name, fn) modules[name]=fn() end\n"
   "  require = function(name) return modules[name] end\n"
   "end\n"
   "--luacheck: ignore\n"
   "local function main()\n"
   "  local json = require \"dkjson\"\n"
   "  local Parser = require \"parser\"\n"
   "  \n"
   "  --luacheck: globals redis\n"
   "  \n"
   "  \n"
   "  redis.command(\"echo\", tostring(Parser) .. tostring(json))\n"
   "  return 27\n"
   "\n"
   "end\n"
   "\n"
   "module(\"dkjson\", function()\n"
   "  --David Kolf's JSON module for Lua 5.1/5.2\n"
   "  --small hack to generate object and array metatables by slact\n"
   "  \n"
   "  local always_try_using_lpeg = false\n"
   "  local register_global_module_table = false\n"
   "  local global_module_name = 'json'\n"
   "  \n"
   "  --luacheck: ignore\n"
   "  \n"
   "  --[==[\n"
   "  \n"
   "  David Kolf's JSON module for Lua 5.1/5.2\n"
   "  \n"
   "  Version 2.5\n"
   "  \n"
   "  \n"
   "  For the documentation see the corresponding readme.txt or visit\n"
   "  <http://dkolf.de/src/dkjson-lua.fsl/>.\n"
   "  \n"
   "  You can contact the author by sending an e-mail to 'david' at the\n"
   "  domain 'dkolf.de'.\n"
   "  \n"
   "  \n"
   "  Copyright (C) 2010-2013 David Heiko Kolf\n"
   "  \n"
   "  Permission is hereby granted, free of charge, to any person obtaining\n"
   "  a copy of this software and associated documentation files (the\n"
   "  \"Software\"), to deal in the Software without restriction, including\n"
   "  without limitation the rights to use, copy, modify, merge, publish,\n"
   "  distribute, sublicense, and/or sell copies of the Software, and to\n"
   "  permit persons to whom the Software is furnished to do so, subject to\n"
   "  the following conditions:\n"
   "  \n"
   "  The above copyright notice and this permission notice shall be\n"
   "  included in all copies or substantial portions of the Software.\n"
   "  \n"
   "  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n"
   "  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
   "  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
   "  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n"
   "  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n"
   "  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n"
   "  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
   "  SOFTWARE.\n"
   "  \n"
   "  --]==]\n"
   "  \n"
   "  -- global dependencies:\n"
   "  local pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset =\n"
   "        pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset\n"
   "  local error, require, pcall, select = error, require, pcall, select\n"
   "  local floor, huge = math.floor, math.huge\n"
   "  local strrep, gsub, strsub, strbyte, strchar, strfind, strlen, strformat =\n"
   "        string.rep, string.gsub, string.sub, string.byte, string.char,\n"
   "        string.find, string.len, string.format\n"
   "  local strmatch = string.match\n"
   "  local concat = table.concat\n"
   "  \n"
   "  local json = { version = \"dkjson 2.5\" }\n"
   "  \n"
   "  if register_global_module_table then\n"
   "    _G[global_module_name] = json\n"
   "  end\n"
   "  \n"
   "  local _ENV = nil -- blocking globals in Lua 5.2\n"
   "  \n"
   "  pcall (function()\n"
   "    -- Enable access to blocked metatables.\n"
   "    -- Don't worry, this module doesn't change anything in them.\n"
   "    local debmeta = require \"debug\".getmetatable\n"
   "    if debmeta then getmetatable = debmeta end\n"
   "  end)\n"
   "  \n"
   "  json.null = setmetatable ({}, {\n"
   "    __tojson = function () return \"null\" end\n"
   "  })\n"
   "  \n"
   "  local function isarray (tbl)\n"
   "    local max, n, arraylen = 0, 0, 0\n"
   "    for k,v in pairs (tbl) do\n"
   "      if k == 'n' and type(v) == 'number' then\n"
   "        arraylen = v\n"
   "        if v > max then\n"
   "          max = v\n"
   "        end\n"
   "      else\n"
   "        if type(k) ~= 'number' or k < 1 or floor(k) ~= k then\n"
   "          return false\n"
   "        end\n"
   "        if k > max then\n"
   "          max = k\n"
   "        end\n"
   "        n = n + 1\n"
   "      end\n"
   "    end\n"
   "    if max > 10 and max > arraylen and max > n * 2 then\n"
   "      return false -- don't create an array with too many holes\n"
   "    end\n"
   "    return true, max\n"
   "  end\n"
   "  \n"
   "  local escapecodes = {\n"
   "    [\"\\\"\"] = \"\\\\\\\"\", [\"\\\\\"] = \"\\\\\\\\\", [\"\\b\"] = \"\\\\b\", [\"\\f\"] = \"\\\\f\",\n"
   "    [\"\\n\"] = \"\\\\n\",  [\"\\r\"] = \"\\\\r\",  [\"\\t\"] = \"\\\\t\"\n"
   "  }\n"
   "  \n"
   "  local function escapeutf8 (uchar)\n"
   "    local value = escapecodes[uchar]\n"
   "    if value then\n"
   "      return value\n"
   "    end\n"
   "    local a, b, c, d = strbyte (uchar, 1, 4)\n"
   "    a, b, c, d = a or 0, b or 0, c or 0, d or 0\n"
   "    if a <= 0x7f then\n"
   "      value = a\n"
   "    elseif 0xc0 <= a and a <= 0xdf and b >= 0x80 then\n"
   "      value = (a - 0xc0) * 0x40 + b - 0x80\n"
   "    elseif 0xe0 <= a and a <= 0xef and b >= 0x80 and c >= 0x80 then\n"
   "      value = ((a - 0xe0) * 0x40 + b - 0x80) * 0x40 + c - 0x80\n"
   "    elseif 0xf0 <= a and a <= 0xf7 and b >= 0x80 and c >= 0x80 and d >= 0x80 then\n"
   "      value = (((a - 0xf0) * 0x40 + b - 0x80) * 0x40 + c - 0x80) * 0x40 + d - 0x80\n"
   "    else\n"
   "      return \"\"\n"
   "    end\n"
   "    if value <= 0xffff then\n"
   "      return strformat (\"\\\\u%.4x\", value)\n"
   "    elseif value <= 0x10ffff then\n"
   "      -- encode as UTF-16 surrogate pair\n"
   "      value = value - 0x10000\n"
   "      local highsur, lowsur = 0xD800 + floor (value/0x400), 0xDC00 + (value % 0x400)\n"
   "      return strformat (\"\\\\u%.4x\\\\u%.4x\", highsur, lowsur)\n"
   "    else\n"
   "      return \"\"\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function fsub (str, pattern, repl)\n"
   "    -- gsub always builds a new string in a buffer, even when no match\n"
   "    -- exists. First using find should be more efficient when most strings\n"
   "    -- don't contain the pattern.\n"
   "    if strfind (str, pattern) then\n"
   "      return gsub (str, pattern, repl)\n"
   "    else\n"
   "      return str\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function quotestring (value)\n"
   "    -- based on the regexp \"escapable\" in https://github.com/douglascrockford/JSON-js\n"
   "    value = fsub (value, \"[%z\\1-\\31\\\"\\\\\\127]\", escapeutf8)\n"
   "    if strfind (value, \"[\\194\\216\\220\\225\\226\\239]\") then\n"
   "      value = fsub (value, \"\\194[\\128-\\159\\173]\", escapeutf8)\n"
   "      value = fsub (value, \"\\216[\\128-\\132]\", escapeutf8)\n"
   "      value = fsub (value, \"\\220\\143\", escapeutf8)\n"
   "      value = fsub (value, \"\\225\\158[\\180\\181]\", escapeutf8)\n"
   "      value = fsub (value, \"\\226\\128[\\140-\\143\\168-\\175]\", escapeutf8)\n"
   "      value = fsub (value, \"\\226\\129[\\160-\\175]\", escapeutf8)\n"
   "      value = fsub (value, \"\\239\\187\\191\", escapeutf8)\n"
   "      value = fsub (value, \"\\239\\191[\\176-\\191]\", escapeutf8)\n"
   "    end\n"
   "    return \"\\\"\" .. value .. \"\\\"\"\n"
   "  end\n"
   "  json.quotestring = quotestring\n"
   "  \n"
   "  local function replace(str, o, n)\n"
   "    local i, j = strfind (str, o, 1, true)\n"
   "    if i then\n"
   "      return strsub(str, 1, i-1) .. n .. strsub(str, j+1, -1)\n"
   "    else\n"
   "      return str\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  -- locale independent num2str and str2num functions\n"
   "  local decpoint, numfilter\n"
   "  \n"
   "  local function updatedecpoint ()\n"
   "    decpoint = strmatch(tostring(0.5), \"([^05+])\")\n"
   "    -- build a filter that can be used to remove group separators\n"
   "    numfilter = \"[^0-9%-%+eE\" .. gsub(decpoint, \"[%^%$%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\") .. \"]+\"\n"
   "  end\n"
   "  \n"
   "  updatedecpoint()\n"
   "  \n"
   "  local function num2str (num)\n"
   "    return replace(fsub(tostring(num), numfilter, \"\"), decpoint, \".\")\n"
   "  end\n"
   "  \n"
   "  local function str2num (str)\n"
   "    local num = tonumber(replace(str, \".\", decpoint))\n"
   "    if not num then\n"
   "      updatedecpoint()\n"
   "      num = tonumber(replace(str, \".\", decpoint))\n"
   "    end\n"
   "    return num\n"
   "  end\n"
   "  \n"
   "  local function addnewline2 (level, buffer, buflen)\n"
   "    buffer[buflen+1] = \"\\n\"\n"
   "    buffer[buflen+2] = strrep (\"  \", level)\n"
   "    buflen = buflen + 2\n"
   "    return buflen\n"
   "  end\n"
   "  \n"
   "  function json.addnewline (state)\n"
   "    if state.indent then\n"
   "      state.bufferlen = addnewline2 (state.level or 0,\n"
   "                             state.buffer, state.bufferlen or #(state.buffer))\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local encode2 -- forward declaration\n"
   "  \n"
   "  local function addpair (key, value, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "    local kt = type (key)\n"
   "    if kt ~= 'string' and kt ~= 'number' then\n"
   "      return nil, \"type '\" .. kt .. \"' is not supported as a key by JSON.\"\n"
   "    end\n"
   "    if prev then\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \",\"\n"
   "    end\n"
   "    if indent then\n"
   "      buflen = addnewline2 (level, buffer, buflen)\n"
   "    end\n"
   "    buffer[buflen+1] = quotestring (key)\n"
   "    buffer[buflen+2] = \":\"\n"
   "    return encode2 (value, indent, level, buffer, buflen + 2, tables, globalorder, state)\n"
   "  end\n"
   "  \n"
   "  local function appendcustom(res, buffer, state)\n"
   "    local buflen = state.bufferlen\n"
   "    if type (res) == 'string' then\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = res\n"
   "    end\n"
   "    return buflen\n"
   "  end\n"
   "  \n"
   "  local function exception(reason, value, state, buffer, buflen, defaultmessage)\n"
   "    defaultmessage = defaultmessage or reason\n"
   "    local handler = state.exception\n"
   "    if not handler then\n"
   "      return nil, defaultmessage\n"
   "    else\n"
   "      state.bufferlen = buflen\n"
   "      local ret, msg = handler (reason, value, state, defaultmessage)\n"
   "      if not ret then return nil, msg or defaultmessage end\n"
   "      return appendcustom(ret, buffer, state)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function json.encodeexception(reason, value, state, defaultmessage)\n"
   "    return quotestring(\"<\" .. defaultmessage .. \">\")\n"
   "  end\n"
   "  \n"
   "  encode2 = function (value, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "    local valtype = type (value)\n"
   "    local valmeta = getmetatable (value)\n"
   "    valmeta = type (valmeta) == 'table' and valmeta -- only tables\n"
   "    local replacementjsonval = valmeta and valmeta.__jsonval\n"
   "    if replacementjsonval then\n"
   "      if type(replacementjsonval) == \"function\" then\n"
   "        value = replacementjsonval(value)\n"
   "      else\n"
   "        value = replacementjsonval\n"
   "      end\n"
   "      valtype = type (value)\n"
   "    end\n"
   "    \n"
   "    local valtojson = valmeta and valmeta.__tojson\n"
   "    if valtojson then\n"
   "      if tables[value] then\n"
   "        return exception('reference cycle', value, state, buffer, buflen)\n"
   "      end\n"
   "      tables[value] = true\n"
   "      state.bufferlen = buflen\n"
   "      local ret, msg = valtojson (value, state)\n"
   "      if not ret then return exception('custom encoder failed', value, state, buffer, buflen, msg) end\n"
   "      tables[value] = nil\n"
   "      buflen = appendcustom(ret, buffer, state)\n"
   "    elseif value == nil then\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = \"null\"\n"
   "    elseif valtype == 'number' then\n"
   "      local s\n"
   "      if value ~= value or value >= huge or -value >= huge then\n"
   "        -- This is the behaviour of the original JSON implementation.\n"
   "        s = \"null\"\n"
   "      else\n"
   "        s = num2str (value)\n"
   "      end\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = s\n"
   "    elseif valtype == 'boolean' then\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = value and \"true\" or \"false\"\n"
   "    elseif valtype == 'string' then\n"
   "      buflen = buflen + 1\n"
   "      buffer[buflen] = quotestring (value)\n"
   "    elseif valtype == 'table' then\n"
   "      if tables[value] then\n"
   "        return exception('reference cycle', value, state, buffer, buflen)\n"
   "      end\n"
   "      tables[value] = true\n"
   "      level = level + 1\n"
   "      local isa, n = isarray (value)\n"
   "      if n == 0 and valmeta and valmeta.__jsontype == 'object' then\n"
   "        isa = false\n"
   "      end\n"
   "      local msg\n"
   "      if isa then -- JSON array\n"
   "        buflen = buflen + 1\n"
   "        buffer[buflen] = \"[\"\n"
   "        for i = 1, n do\n"
   "          buflen, msg = encode2 (value[i], indent, level, buffer, buflen, tables, globalorder, state)\n"
   "          if not buflen then return nil, msg end\n"
   "          if i < n then\n"
   "            buflen = buflen + 1\n"
   "            buffer[buflen] = \",\"\n"
   "          end\n"
   "        end\n"
   "        buflen = buflen + 1\n"
   "        buffer[buflen] = \"]\"\n"
   "      else -- JSON object\n"
   "        local prev = false\n"
   "        buflen = buflen + 1\n"
   "        buffer[buflen] = \"{\"\n"
   "        local order = valmeta and valmeta.__jsonorder or globalorder\n"
   "        if order then\n"
   "          if type(order) == \"function\" then order = order(value) end\n"
   "          local used = {}\n"
   "          n = #order\n"
   "          for i = 1, n do\n"
   "            local k = order[i]\n"
   "            local v = value[k]\n"
   "            if v then\n"
   "              used[k] = true\n"
   "              buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "              prev = true -- add a seperator before the next element\n"
   "            end\n"
   "          end\n"
   "          for k,v in pairs (value) do\n"
   "            if not used[k] then\n"
   "              buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "              if not buflen then return nil, msg end\n"
   "              prev = true -- add a seperator before the next element\n"
   "            end\n"
   "          end\n"
   "        else -- unordered\n"
   "          for k,v in pairs (value) do\n"
   "            buflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n"
   "            if not buflen then return nil, msg end\n"
   "            prev = true -- add a seperator before the next element\n"
   "          end\n"
   "        end\n"
   "        if indent then\n"
   "          buflen = addnewline2 (level - 1, buffer, buflen)\n"
   "        end\n"
   "        buflen = buflen + 1\n"
   "        buffer[buflen] = \"}\"\n"
   "      end\n"
   "      tables[value] = nil\n"
   "    else\n"
   "      return exception ('unsupported type', value, state, buffer, buflen,\n"
   "        \"type '\" .. valtype .. \"' is not supported by JSON.\")\n"
   "    end\n"
   "    return buflen\n"
   "  end\n"
   "  \n"
   "  function json.encode (value, state)\n"
   "    state = state or {}\n"
   "    local oldbuffer = state.buffer\n"
   "    local buffer = oldbuffer or {}\n"
   "    state.buffer = buffer\n"
   "    updatedecpoint()\n"
   "    local ret, msg = encode2 (value, state.indent, state.level or 0,\n"
   "                     buffer, state.bufferlen or 0, state.tables or {}, state.keyorder, state)\n"
   "    if not ret then\n"
   "      error (msg, 2)\n"
   "    elseif oldbuffer == buffer then\n"
   "      state.bufferlen = ret\n"
   "      return true\n"
   "    else\n"
   "      state.bufferlen = nil\n"
   "      state.buffer = nil\n"
   "      return concat (buffer)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function loc(str, where)\n"
   "    local line, pos, linepos = 1, 1, 0\n"
   "    while true do\n"
   "      pos = strfind (str, \"\\n\", pos, true)\n"
   "      if pos and pos < where then\n"
   "        line = line + 1\n"
   "        linepos = pos\n"
   "        pos = pos + 1\n"
   "      else\n"
   "        break\n"
   "      end\n"
   "    end\n"
   "    return \"line \" .. line .. \", column \" .. (where - linepos)\n"
   "  end\n"
   "  \n"
   "  local function unterminated (str, what, where)\n"
   "    return nil, strlen (str) + 1, \"unterminated \" .. what .. \" at \" .. loc (str, where)\n"
   "  end\n"
   "  \n"
   "  local function scanwhite (str, pos)\n"
   "    while true do\n"
   "      pos = strfind (str, \"%S\", pos)\n"
   "      if not pos then return nil end\n"
   "      local sub2 = strsub (str, pos, pos + 1)\n"
   "      if sub2 == \"\\239\\187\" and strsub (str, pos + 2, pos + 2) == \"\\191\" then\n"
   "        -- UTF-8 Byte Order Mark\n"
   "        pos = pos + 3\n"
   "      elseif sub2 == \"//\" then\n"
   "        pos = strfind (str, \"[\\n\\r]\", pos + 2)\n"
   "        if not pos then return nil end\n"
   "      elseif sub2 == \"/*\" then\n"
   "        pos = strfind (str, \"*/\", pos + 2)\n"
   "        if not pos then return nil end\n"
   "        pos = pos + 2\n"
   "      else\n"
   "        return pos\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local escapechars = {\n"
   "    [\"\\\"\"] = \"\\\"\", [\"\\\\\"] = \"\\\\\", [\"/\"] = \"/\", [\"b\"] = \"\\b\", [\"f\"] = \"\\f\",\n"
   "    [\"n\"] = \"\\n\", [\"r\"] = \"\\r\", [\"t\"] = \"\\t\"\n"
   "  }\n"
   "  \n"
   "  local function unichar (value)\n"
   "    if value < 0 then\n"
   "      return nil\n"
   "    elseif value <= 0x007f then\n"
   "      return strchar (value)\n"
   "    elseif value <= 0x07ff then\n"
   "      return strchar (0xc0 + floor(value/0x40),\n"
   "                      0x80 + (floor(value) % 0x40))\n"
   "    elseif value <= 0xffff then\n"
   "      return strchar (0xe0 + floor(value/0x1000),\n"
   "                      0x80 + (floor(value/0x40) % 0x40),\n"
   "                      0x80 + (floor(value) % 0x40))\n"
   "    elseif value <= 0x10ffff then\n"
   "      return strchar (0xf0 + floor(value/0x40000),\n"
   "                      0x80 + (floor(value/0x1000) % 0x40),\n"
   "                      0x80 + (floor(value/0x40) % 0x40),\n"
   "                      0x80 + (floor(value) % 0x40))\n"
   "    else\n"
   "      return nil\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function scanstring (str, pos)\n"
   "    local lastpos = pos + 1\n"
   "    local buffer, n = {}, 0\n"
   "    while true do\n"
   "      local nextpos = strfind (str, \"[\\\"\\\\]\", lastpos)\n"
   "      if not nextpos then\n"
   "        return unterminated (str, \"string\", pos)\n"
   "      end\n"
   "      if nextpos > lastpos then\n"
   "        n = n + 1\n"
   "        buffer[n] = strsub (str, lastpos, nextpos - 1)\n"
   "      end\n"
   "      if strsub (str, nextpos, nextpos) == \"\\\"\" then\n"
   "        lastpos = nextpos + 1\n"
   "        break\n"
   "      else\n"
   "        local escchar = strsub (str, nextpos + 1, nextpos + 1)\n"
   "        local value\n"
   "        if escchar == \"u\" then\n"
   "          value = tonumber (strsub (str, nextpos + 2, nextpos + 5), 16)\n"
   "          if value then\n"
   "            local value2\n"
   "            if 0xD800 <= value and value <= 0xDBff then\n"
   "              -- we have the high surrogate of UTF-16. Check if there is a\n"
   "              -- low surrogate escaped nearby to combine them.\n"
   "              if strsub (str, nextpos + 6, nextpos + 7) == \"\\\\u\" then\n"
   "                value2 = tonumber (strsub (str, nextpos + 8, nextpos + 11), 16)\n"
   "                if value2 and 0xDC00 <= value2 and value2 <= 0xDFFF then\n"
   "                  value = (value - 0xD800)  * 0x400 + (value2 - 0xDC00) + 0x10000\n"
   "                else\n"
   "                  value2 = nil -- in case it was out of range for a low surrogate\n"
   "                end\n"
   "              end\n"
   "            end\n"
   "            value = value and unichar (value)\n"
   "            if value then\n"
   "              if value2 then\n"
   "                lastpos = nextpos + 12\n"
   "              else\n"
   "                lastpos = nextpos + 6\n"
   "              end\n"
   "            end\n"
   "          end\n"
   "        end\n"
   "        if not value then\n"
   "          value = escapechars[escchar] or escchar\n"
   "          lastpos = nextpos + 2\n"
   "        end\n"
   "        n = n + 1\n"
   "        buffer[n] = value\n"
   "      end\n"
   "    end\n"
   "    if n == 1 then\n"
   "      return buffer[1], lastpos\n"
   "    elseif n > 1 then\n"
   "      return concat (buffer), lastpos\n"
   "    else\n"
   "      return \"\", lastpos\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local scanvalue -- forward declaration\n"
   "  \n"
   "  local function set_scantable_metatable (tbl, meta, str, pos)\n"
   "    if type(meta)==\"function\" then\n"
   "      meta = meta(str, pos)\n"
   "      if type(meta) ~= \"table\" then\n"
   "        return tbl\n"
   "      end\n"
   "    end\n"
   "    return setmetatable(tbl, meta)\n"
   "  end\n"
   "  \n"
   "  local function scantable (what, closechar, str, startpos, nullval, objectmeta, arraymeta)\n"
   "    local len = strlen (str)\n"
   "    local tbl, n = {}, 0\n"
   "    local pos = startpos + 1\n"
   "    if what == 'object' then\n"
   "      set_scantable_metatable(tbl, objectmeta, str, startpos)\n"
   "    else\n"
   "      set_scantable_metatable(tbl, arraymeta, str, startpos)\n"
   "    end\n"
   "    while true do\n"
   "      pos = scanwhite (str, pos)\n"
   "      if not pos then return unterminated (str, what, startpos) end\n"
   "      local char = strsub (str, pos, pos)\n"
   "      if char == closechar then\n"
   "        return tbl, pos + 1\n"
   "      end\n"
   "      local val1, err\n"
   "      val1, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "      if err then return nil, pos, err end\n"
   "      pos = scanwhite (str, pos)\n"
   "      if not pos then return unterminated (str, what, startpos) end\n"
   "      char = strsub (str, pos, pos)\n"
   "      if char == \":\" then\n"
   "        if val1 == nil then\n"
   "          return nil, pos, \"cannot use nil as table index (at \" .. loc (str, pos) .. \")\"\n"
   "        end\n"
   "        pos = scanwhite (str, pos + 1)\n"
   "        if not pos then return unterminated (str, what, startpos) end\n"
   "        local val2\n"
   "        val2, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "        if err then return nil, pos, err end\n"
   "        tbl[val1] = val2\n"
   "        pos = scanwhite (str, pos)\n"
   "        if not pos then return unterminated (str, what, startpos) end\n"
   "        char = strsub (str, pos, pos)\n"
   "      else\n"
   "        n = n + 1\n"
   "        tbl[n] = val1\n"
   "      end\n"
   "      if char == \",\" then\n"
   "        pos = pos + 1\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  scanvalue = function (str, pos, nullval, objectmeta, arraymeta)\n"
   "    pos = pos or 1\n"
   "    pos = scanwhite (str, pos)\n"
   "    if not pos then\n"
   "      return nil, strlen (str) + 1, \"no valid JSON value (reached the end)\"\n"
   "    end\n"
   "    local char = strsub (str, pos, pos)\n"
   "    if char == \"{\" then\n"
   "      return scantable ('object', \"}\", str, pos, nullval, objectmeta, arraymeta)\n"
   "    elseif char == \"[\" then\n"
   "      return scantable ('array', \"]\", str, pos, nullval, objectmeta, arraymeta)\n"
   "    elseif char == \"\\\"\" then\n"
   "      return scanstring (str, pos)\n"
   "    else\n"
   "      local pstart, pend = strfind (str, \"^%-?[%d%.]+[eE]?[%+%-]?%d*\", pos)\n"
   "      if pstart then\n"
   "        local number = str2num (strsub (str, pstart, pend))\n"
   "        if number then\n"
   "          return number, pend + 1\n"
   "        end\n"
   "      end\n"
   "      pstart, pend = strfind (str, \"^%a%w*\", pos)\n"
   "      if pstart then\n"
   "        local name = strsub (str, pstart, pend)\n"
   "        if name == \"true\" then\n"
   "          return true, pend + 1\n"
   "        elseif name == \"false\" then\n"
   "          return false, pend + 1\n"
   "        elseif name == \"null\" then\n"
   "          return nullval, pend + 1\n"
   "        end\n"
   "      end\n"
   "      return nil, pos, \"no valid JSON value at \" .. loc (str, pos)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function optionalmetatables(...)\n"
   "    if select(\"#\", ...) > 0 then\n"
   "      return ...\n"
   "    else\n"
   "      return {__jsontype = 'object'}, {__jsontype = 'array'}\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function json.decode (str, pos, nullval, ...)\n"
   "    local objectmeta, arraymeta = optionalmetatables(...)\n"
   "    return scanvalue (str, pos, nullval, objectmeta, arraymeta)\n"
   "  end\n"
   "  \n"
   "  function json.use_lpeg ()\n"
   "    local g = require (\"lpeg\")\n"
   "  \n"
   "    if g.version() == \"0.11\" then\n"
   "      error \"due to a bug in LPeg 0.11, it cannot be used for JSON matching\"\n"
   "    end\n"
   "  \n"
   "    local pegmatch = g.match\n"
   "    local P, S, R = g.P, g.S, g.R\n"
   "  \n"
   "    local function ErrorCall (str, pos, msg, state)\n"
   "      if not state.msg then\n"
   "        state.msg = msg .. \" at \" .. loc (str, pos)\n"
   "        state.pos = pos\n"
   "      end\n"
   "      return false\n"
   "    end\n"
   "  \n"
   "    local function Err (msg)\n"
   "      return g.Cmt (g.Cc (msg) * g.Carg (2), ErrorCall)\n"
   "    end\n"
   "  \n"
   "    local SingleLineComment = P\"//\" * (1 - S\"\\n\\r\")^0\n"
   "    local MultiLineComment = P\"/*\" * (1 - P\"*/\")^0 * P\"*/\"\n"
   "    local Space = (S\" \\n\\r\\t\" + P\"\\239\\187\\191\" + SingleLineComment + MultiLineComment)^0\n"
   "  \n"
   "    local PlainChar = 1 - S\"\\\"\\\\\\n\\r\"\n"
   "    local EscapeSequence = (P\"\\\\\" * g.C (S\"\\\"\\\\/bfnrt\" + Err \"unsupported escape sequence\")) / escapechars\n"
   "    local HexDigit = R(\"09\", \"af\", \"AF\")\n"
   "    local function UTF16Surrogate (match, pos, high, low)\n"
   "      high, low = tonumber (high, 16), tonumber (low, 16)\n"
   "      if 0xD800 <= high and high <= 0xDBff and 0xDC00 <= low and low <= 0xDFFF then\n"
   "        return true, unichar ((high - 0xD800)  * 0x400 + (low - 0xDC00) + 0x10000)\n"
   "      else\n"
   "        return false\n"
   "      end\n"
   "    end\n"
   "    local function UTF16BMP (hex)\n"
   "      return unichar (tonumber (hex, 16))\n"
   "    end\n"
   "    local U16Sequence = (P\"\\\\u\" * g.C (HexDigit * HexDigit * HexDigit * HexDigit))\n"
   "    local UnicodeEscape = g.Cmt (U16Sequence * U16Sequence, UTF16Surrogate) + U16Sequence/UTF16BMP\n"
   "    local Char = UnicodeEscape + EscapeSequence + PlainChar\n"
   "    local String = P\"\\\"\" * g.Cs (Char ^ 0) * (P\"\\\"\" + Err \"unterminated string\")\n"
   "    local Integer = P\"-\"^(-1) * (P\"0\" + (R\"19\" * R\"09\"^0))\n"
   "    local Fractal = P\".\" * R\"09\"^0\n"
   "    local Exponent = (S\"eE\") * (S\"+-\")^(-1) * R\"09\"^1\n"
   "    local Number = (Integer * Fractal^(-1) * Exponent^(-1))/str2num\n"
   "    local Constant = P\"true\" * g.Cc (true) + P\"false\" * g.Cc (false) + P\"null\" * g.Carg (1)\n"
   "    local SimpleValue = Number + String + Constant\n"
   "    local ArrayContent, ObjectContent\n"
   "  \n"
   "    -- The functions parsearray and parseobject parse only a single value/pair\n"
   "    -- at a time and store them directly to avoid hitting the LPeg limits.\n"
   "    local function parsearray (str, pos, nullval, state)\n"
   "      local obj, cont\n"
   "      local npos\n"
   "      local t, nt = {}, 0\n"
   "      repeat\n"
   "        obj, cont, npos = pegmatch (ArrayContent, str, pos, nullval, state)\n"
   "        if not npos then break end\n"
   "        pos = npos\n"
   "        nt = nt + 1\n"
   "        t[nt] = obj\n"
   "      until cont == 'last'\n"
   "      return pos, setmetatable (t, state.arraymeta)\n"
   "    end\n"
   "  \n"
   "    local function parseobject (str, pos, nullval, state)\n"
   "      local obj, key, cont\n"
   "      local npos\n"
   "      local t = {}\n"
   "      repeat\n"
   "        key, obj, cont, npos = pegmatch (ObjectContent, str, pos, nullval, state)\n"
   "        if not npos then break end\n"
   "        pos = npos\n"
   "        t[key] = obj\n"
   "      until cont == 'last'\n"
   "      return pos, setmetatable (t, state.objectmeta)\n"
   "    end\n"
   "  \n"
   "    local Array = P\"[\" * g.Cmt (g.Carg(1) * g.Carg(2), parsearray) * Space * (P\"]\" + Err \"']' expected\")\n"
   "    local Object = P\"{\" * g.Cmt (g.Carg(1) * g.Carg(2), parseobject) * Space * (P\"}\" + Err \"'}' expected\")\n"
   "    local Value = Space * (Array + Object + SimpleValue)\n"
   "    local ExpectedValue = Value + Space * Err \"value expected\"\n"
   "    ArrayContent = Value * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
   "    local Pair = g.Cg (Space * String * Space * (P\":\" + Err \"colon expected\") * ExpectedValue)\n"
   "    ObjectContent = Pair * Space * (P\",\" * g.Cc'cont' + g.Cc'last') * g.Cp()\n"
   "    local DecodeValue = ExpectedValue * g.Cp ()\n"
   "  \n"
   "    function json.decode (str, pos, nullval, ...)\n"
   "      local state = {}\n"
   "      state.objectmeta, state.arraymeta = optionalmetatables(...)\n"
   "      local obj, retpos = pegmatch (DecodeValue, str, pos, nullval, state)\n"
   "      if state.msg then\n"
   "        return nil, state.pos, state.msg\n"
   "      else\n"
   "        return obj, retpos\n"
   "      end\n"
   "    end\n"
   "  \n"
   "    -- use this function only once:\n"
   "    json.use_lpeg = function () return json end\n"
   "  \n"
   "    json.using_lpeg = true\n"
   "  \n"
   "    return json -- so you can get the module using json = require \"dkjson\".use_lpeg()\n"
   "  end\n"
   "  \n"
   "  if always_try_using_lpeg then\n"
   "    pcall (json.use_lpeg)\n"
   "  end\n"
   "  \n"
   "  return json\n"
   "  \n"
   "\n"
   "end)\n"
   "\n"
   "module(\"parser\", function()\n"
   "  local Rule = require \"rule\"\n"
   "  local json = require \"dkjson\"\n"
   "  --local mm = require \"mm\"\n"
   "  \n"
   "  local function parseRulesetThing(parser, data_in, opt)\n"
   "    local data = data_in[opt.key]\n"
   "    parser:pushContext(data, opt.key)\n"
   "    local ruleset = parser.ruleset\n"
   "    \n"
   "    if data then\n"
   "      parser:assert_type(data, opt.type, \"wrong type for ruleset %s, expected %s, got %s\", opt.key, opt.type, parser:jsontype(data))\n"
   "      local ret, err\n"
   "      for k,v in pairs(data) do\n"
   "        parser:assert_type(k, \"string\", \"wrong key type for %s, expected string, got %s %s\", opt.thing, parser:jsontype(k), tostring(k))\n"
   "        ret, err = opt.parser_method(parser, v, k)\n"
   "        parser:assert(ret, err)\n"
   "        parser:assert(ruleset[opt.key][ret.name] == nil, \"%s %s already exists\", opt.thing, ret.name)\n"
   "        ruleset[opt.key][ret.name]=ret\n"
   "      end\n"
   "    end\n"
   "    parser:popContext()\n"
   "    return true\n"
   "  end\n"
   "  \n"
   "  local function inheritmetatable(dst, src)\n"
   "    if type(dst) == type(src) then\n"
   "      setmetatable(dst, getmetatable(src))\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local getloc; do --location caching\n"
   "    local lc = setmetatable({}, {__mode=\"k\"}) -- weak keys\n"
   "    getloc = function(str, where)\n"
   "      local line, pos, linepos = 1, 1, 0\n"
   "      local prev = lc[str]\n"
   "      if prev and prev.pos < where then\n"
   "        line = prev.line\n"
   "        pos = prev.pos\n"
   "      end\n"
   "      while true do\n"
   "        pos = str:find(\"\\n\", pos, true)\n"
   "        if pos and pos < where then\n"
   "          line = line + 1\n"
   "          linepos = pos\n"
   "          pos = pos + 1\n"
   "        else\n"
   "          break\n"
   "        end\n"
   "      end\n"
   "      return line, (where - linepos) -- line, column\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function jsonmeta(what)\n"
   "    return function(str, where)\n"
   "      local line, column = getloc(str, where)\n"
   "      return {__pos=where,__line=line, __column=column,  __jsontype = what, __jsonmeta = true}\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local Parser = {}\n"
   "  \n"
   "  function Parser:jsontype(var)\n"
   "    if type(var) == \"table\" then\n"
   "      local m = getmetatable(var)\n"
   "      return m and m.__jsontype or nil\n"
   "    else\n"
   "      return type(var)\n"
   "    end\n"
   "  end\n"
   "  function Parser:assert(cond, err, ...)\n"
   "    if not cond then self:error(err, ...) end\n"
   "    return cond\n"
   "  end\n"
   "  function Parser:assert_type(var, expected_type, err, ...)\n"
   "    if err then\n"
   "      return self:assert(type(var) == expected_type, err, ...)\n"
   "    else\n"
   "      return self:assert(type(var) == expected_type, \"expected type '%s', got '%s'\", expected_type, type(var))\n"
   "    end\n"
   "  end\n"
   "  function Parser:assert_jsontype(var, expected_type, err, ...)\n"
   "    if err then\n"
   "      return self:assert(self:jsontype(var) == expected_type, err, ...)\n"
   "    else\n"
   "      return self:assert(self:jsontype(var) == expected_type,\"expected JSON type '%s', got '%s'\", expected_type, self:jsontype(var))\n"
   "    end\n"
   "  end\n"
   "  function Parser:assert_table_size(var, expected_size, err, ...)\n"
   "    self:assert_type(var, \"table\")\n"
   "    local n = 0\n"
   "    for _, _ in pairs(var) do\n"
   "      n = n + 1\n"
   "    end\n"
   "    if n ~= expected_size then\n"
   "      if err then\n"
   "        self:error(err, ...)\n"
   "      else\n"
   "        self:error(\"wrong table size, expected %i, got %i\", expected_size, n)\n"
   "      end\n"
   "    end\n"
   "    return var\n"
   "  end\n"
   "  \n"
   "  local function getlc(tbl)\n"
   "    local mt = getmetatable(tbl)\n"
   "    if mt.__line and mt.__column then\n"
   "      return mt.__line, mt.__column\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local function getlc_str(tbl)\n"
   "    local line, col = getlc(tbl)\n"
   "    if line and col then\n"
   "      return (\"line %s column %i\"):format(line, col)\n"
   "    else\n"
   "      return nil\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Parser:error(err, ...)\n"
   "    \n"
   "    if not err then err = \"unknown error\" end\n"
   "    if select(\"#\", ...) > 0 then\n"
   "      err = err:format(...)\n"
   "    end\n"
   "    \n"
   "    local nested_names = {}\n"
   "    \n"
   "    for i=#self.ctx_stack,1,-1 do\n"
   "      local cur = self.ctx_stack[i]\n"
   "      if cur.name then table.insert(nested_names, cur.name) end\n"
   "      local lc_str = getlc_str(cur.ctx)\n"
   "      if lc_str then\n"
   "        if self.name then table.insert(nested_names, self.name) end\n"
   "        error((\"%s at %s: %s\"):format(table.concat(nested_names, \" in \"), lc_str, err))\n"
   "      end\n"
   "    end\n"
   "    if self.name then table.insert(nested_names, self.name) end\n"
   "    if #nested_names > 0 then\n"
   "      error((\"%s: %s\"):format(table.concat(nested_names, \" in \"), err))\n"
   "    else\n"
   "      error(err)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Parser:setInterpolationChecker(func)\n"
   "    self.interpolation_checker = func\n"
   "  end\n"
   "  function Parser:checkInterpolatedString(str)\n"
   "    if self.interpolation_checker then\n"
   "      self.interpolation_checker(str, self)\n"
   "    end\n"
   "    return true\n"
   "  end\n"
   "  \n"
   "  function Parser:pushContext(ctx, name)\n"
   "    table.insert(self.ctx_stack, {ctx=ctx, name=name})\n"
   "    self.context = self.ctx_stack[#self.ctx_stack]\n"
   "    return self\n"
   "  end\n"
   "  function Parser:popContext()\n"
   "    table.remove(self.ctx_stack, #self.ctx_stack)\n"
   "    self.context = self.ctx_stack[#self.ctx_stack]\n"
   "  end\n"
   "  function Parser:getContext(name)\n"
   "    if not name then return self.context and self.context.ctx end\n"
   "    for i=#self.ctx_stack, 1, -1 do\n"
   "      local cur = self.ctx_stack[i]\n"
   "      if cur.name==name then\n"
   "        return cur.ctx\n"
   "      end\n"
   "    end\n"
   "    return nil\n"
   "  end\n"
   "  function Parser:printContext()\n"
   "    for i=#self.ctx_stack, 1, -1 do\n"
   "      local cur = self.ctx_stack[i]\n"
   "      print(cur.name or \"<?>\", self:jsontype(cur.ctx) or \"<?>\", getlc_str(cur.ctx) or \"\")\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Parser:parseFile(path)\n"
   "    local file = assert(io.open(path, \"rb\")) -- r read mode and b binary mode\n"
   "    local content = file:read(\"*a\") -- *a or *all reads the whole file\n"
   "    file:close()\n"
   "    self.name = path\n"
   "    return self:parseJSON(content, \"file \" .. path)\n"
   "  end\n"
   "  \n"
   "  function Parser:parseJSON(json_str, json_name)\n"
   "    self:assert_type(json_str, \"string\", \"expected a JSON string\")\n"
   "    local data, _, err = json.decode(json_str, 1, json.null, jsonmeta(\"object\"), jsonmeta(\"array\"))\n"
   "    self.name = json_name or self.context_name\n"
   "    self.source = json_str\n"
   "    if not data then\n"
   "      self:error(err)\n"
   "    end\n"
   "    return self:parseRuleSet(data)\n"
   "  end\n"
   "  \n"
   "  function Parser:parseInterpolatedString(str)\n"
   "    --validate the string\n"
   "    for sub in str:gmatch(\"%$%b{}\") do\n"
   "      if not sub:match(\"^%${[%w_]+}\") then\n"
   "        self:error(\"invalid variable \\\"%s\\\" in interpolated string\", sub)\n"
   "      end\n"
   "    end\n"
   "    for sub in str:gmatch(\"%${?[%w_]*}?\") do\n"
   "      if sub:sub(2,2) == \"{\" then\n"
   "        if sub:sub(-1) ~=\"}\" then --unterminated bracket\n"
   "          self:error(\"missing '}' in interpolated string\")\n"
   "        end\n"
   "        sub=sub:sub(3, -2)\n"
   "        if sub == \"\" then\n"
   "          self:error(\"invalid variable ${} in interpolated string\")\n"
   "        elseif sub:match(\"^%d%d+\") then\n"
   "          self:error(\"invalid regex capture \\\"%s\\\" in interpolated string. 1-9 only (nginx quirk)\", sub)\n"
   "        elseif sub:match(\"^%d.+\") then\n"
   "          self:error(\"invalid variable \\\"%s\\\" in interpolated string. can't sart with a number (nginx quirk)\", sub)\n"
   "        end\n"
   "      else\n"
   "        sub=sub:sub(2, -1)\n"
   "      end\n"
   "      if sub == \"\" then\n"
   "        self:error(\"invalid empty variable in interpolated string\")\n"
   "      end\n"
   "      \n"
   "    end\n"
   "    \n"
   "    return {string = str}\n"
   "  end\n"
   "  \n"
   "  function Parser:parseRuleSet(data, name)\n"
   "    self.ruleset = {\n"
   "      limiters= {},\n"
   "      rules= {},\n"
   "      lists= {},\n"
   "      phases={},\n"
   "      name = name\n"
   "    }\n"
   "    self:pushContext(data, \"ruleset\")\n"
   "    \n"
   "    self:assert_type(data, \"table\", \"wrong type for ruleset\")\n"
   "    parseRulesetThing(self, data, {\n"
   "      thing=\"limiter\", key=\"limiters\", type=\"table\",\n"
   "      parser_method= self.parseLimiter\n"
   "    })\n"
   "    self:checkLimiters(data.limiters)\n"
   "    \n"
   "    --luacheck: push ignore 432 --don't mind the shadowing\n"
   "    parseRulesetThing(self, data, {\n"
   "      thing=\"rule\", key=\"rules\",  type=\"table\",\n"
   "      parser_method=function(self, data, name)\n"
   "        self:pushContext(data, \"rule\")\n"
   "        self:assert(type(data) ~= \"string\", (\"named rule \\\"%s\\\" cannot be a string referring to another named rule \\\"%s\\\"\"):format(name, tostring(data)))\n"
   "        self:popContext()\n"
   "        return self:parseRule(data, name)\n"
   "      end\n"
   "    })\n"
   "    --luacheck: pop\n"
   "    \n"
   "    parseRulesetThing(self, data, {\n"
   "      thing=\"list\", key=\"lists\",  type=\"table\",\n"
   "      parser_method= self.parseRuleList\n"
   "    })\n"
   "    \n"
   "    self.ruleset.phases = self:parsePhaseTable(data.phases)\n"
   "    --convert debug metatable data to __dbg table whenever possible\n"
   "    local function move_dbg_data(tbl)\n"
   "      local meta = getmetatable(tbl)\n"
   "      if meta and meta.__jsonmeta then\n"
   "        setmetatable(tbl, {line=meta.__line, col=meta.__column})\n"
   "      end\n"
   "      for _, v in pairs(tbl) do\n"
   "        if type(v) == \"table\" then\n"
   "          move_dbg_data(v)\n"
   "        end\n"
   "      end\n"
   "    end\n"
   "    move_dbg_data(self.ruleset)\n"
   "    \n"
   "    return self.ruleset\n"
   "  end\n"
   "  \n"
   "  function Parser:parsePhaseTable(data)\n"
   "    self:assert(data ~= nil, \"missing phase table (\\\"phases\\\" attribute)\")\n"
   "    self:assert_jsontype(data, \"object\", \"phase table must be an object\")\n"
   "    self:pushContext(data, \"phase table\")\n"
   "    \n"
   "    for phase_name, phase_data in pairs(data) do\n"
   "      self:assert_type(phase_name, \"string\", \"phase table entries must be strings\")\n"
   "      if self:jsontype(phase_data) == \"array\" then\n"
   "        for i, list in ipairs(phase_data) do\n"
   "          if type(list)==\"string\" or self:jsontype(list) == \"array\" or self:jsontype(list) == \"object\" then\n"
   "            phase_data[i]=self:parseRuleList(list)\n"
   "          else\n"
   "            self:error(\"invalid rule list type: %s\", self:jsontype(list))\n"
   "          end\n"
   "        end\n"
   "      elseif type(phase_data) == \"string\" then\n"
   "        --singe named list\n"
   "        data[phase_name]={ self:parseRuleList(phase_data) }\n"
   "      elseif self:jsontype(phase_data)==\"object\" then\n"
   "        --single long-form list\n"
   "        data[phase_name]=self:parseRuleList(phase_data)\n"
   "      end\n"
   "    end\n"
   "    \n"
   "    self:popContext()\n"
   "    \n"
   "    return data\n"
   "  end\n"
   "  \n"
   "  function Parser:parseRuleList(data, name)\n"
   "    if type(data)==\"string\" then\n"
   "      self:assert(self.ruleset.lists[data], ([[named list \"%s\" not found]]):format(data))\n"
   "      return self.ruleset.lists[data]\n"
   "    end\n"
   "    self:pushContext(data, \"list\")\n"
   "    local list\n"
   "    if self:jsontype(data) == \"object\" then\n"
   "      if name then\n"
   "        self:assert(name == data.name, \"rule list 'name' attribute must match outside list name\")\n"
   "      else\n"
   "        name = tostring(data.name)\n"
   "      end\n"
   "      data = data.rules\n"
   "    end\n"
   "    self:assert_jsontype(data, \"array\", \"rule list must be an array\")\n"
   "    local rules = {}\n"
   "    for _,v in ipairs(data) do\n"
   "      table.insert(rules, self:parseRule(v))\n"
   "    end\n"
   "    self:popContext()\n"
   "    list = {name=name, rules=rules}\n"
   "    inheritmetatable(list, data)\n"
   "    return list\n"
   "  end\n"
   "  \n"
   "  function Parser:parseRule(data, name)\n"
   "    self:pushContext(data, \"rule\")\n"
   "    local rule\n"
   "    if type(data) == \"string\" then\n"
   "      rule = self.ruleset.rules[data]\n"
   "      self:assert(rule, ([[named rule \"%s\" not found]]):format(data))\n"
   "      self:popContext()\n"
   "      return rule\n"
   "    end\n"
   "    self:assert_type(data, \"table\", \"invalid rule data type: \" .. type(data))\n"
   "    self:assert_jsontype(data, \"object\", (\"invalid rule data type: %s\"):format(self:jsontype(data)))\n"
   "    \n"
   "    if ((data[\"if\"] or data[\"if-any\"] or data[\"if-all\"]) or data[\"then\"]) then\n"
   "      self:assert(not data[\"always\"], [[\"always\" clause can't be present in if/then rule]])\n"
   "      self:assert(not data[\"switch\"], [[\"switch\" clause can't be present in if/then rule]])\n"
   "    end\n"
   "    \n"
   "    if data[\"then\"] then\n"
   "      if (data[\"if\"] and (data[\"if-any\"] or data[\"if-all\"])) or (data[\"if-any\"] and data[\"if-all\"]) then\n"
   "        self:error(\"only one of \\\"if\\\", \\\"if-any\\\" or \\\"if-all\\\" allowed in if/then rule\")\n"
   "      end\n"
   "      \n"
   "      local condition\n"
   "      if data[\"if\"] then\n"
   "        condition = self:parseCondition(data[\"if\"])\n"
   "      elseif data[\"if-any\"] or data[\"if-all\"] then\n"
   "        local conditions = {}\n"
   "        for _, v in ipairs(data[\"if-any\"] or data[\"if-all\"]) do\n"
   "          condition = self:assert(self:parseCondition(v))\n"
   "          table.insert(conditions, condition)\n"
   "        end\n"
   "        condition = {[(data[\"if-any\"] and \"any\" or \"all\")]=conditions}\n"
   "        inheritmetatable(condition, data[\"if\"] or data[\"if-any\"] or data[\"if-all\"])\n"
   "      end\n"
   "      rule = {[\"if\"]=condition, [\"then\"]=data[\"then\"], [\"else\"]=data[\"else\"], name=data[\"name\"] or name, info=data[\"info\"], key=data[\"key\"]}\n"
   "    elseif data[\"always\"] then\n"
   "      rule = {[\"if\"]={[\"true\"]={}}, [\"then\"]=data[\"always\"], name=data[\"name\"] or name, info=data[\"info\"], key=data[\"key\"]}\n"
   "    elseif next(data) == nil then\n"
   "      self:error(\"empty rule not allowed\")\n"
   "    else\n"
   "      self:error(\"rule must have at least an \\\"if\\\", \\\"then\\\", or \\\"always\\\" attribute\")\n"
   "    end\n"
   "    if rule[\"if\"] then\n"
   "      rule[\"then\"] = self:parseActions(rule[\"then\"], \"then\")\n"
   "      rule[\"else\"] = self:parseActions(rule[\"else\"], \"else\")\n"
   "    end\n"
   "    if rule.key then\n"
   "      rule.key = self:parseInterpolatedString(rule.key)\n"
   "    end\n"
   "    \n"
   "    self:popContext()\n"
   "    --reuse metatable for debugging purposes\n"
   "    inheritmetatable(rule, data)\n"
   "    return rule\n"
   "  end\n"
   "  \n"
   "  function Parser:parseCondition(data)\n"
   "    self:pushContext(data, \"condition\")\n"
   "    local condition\n"
   "    if type(data) == \"string\" then\n"
   "      condition = {[data]={}}\n"
   "    elseif type(data) == \"table\" then\n"
   "      self:assert_jsontype(data, \"object\", \"condition cannot be an array, must be an object\")\n"
   "      self:assert_table_size(data, 1, \"condition object must have exactly one attribute (the condition name)\")\n"
   "      condition = data\n"
   "    else\n"
   "      self:error(\"wrong type (%s) for condition\", type(data))\n"
   "    end\n"
   "    self:popContext()\n"
   "    -- be more specific with condition name\n"
   "    self:pushContext(data, \"condition \" .. (next(condition)))\n"
   "    condition = Rule.condition.parse(condition, self)\n"
   "    self:popContext()\n"
   "    inheritmetatable(condition, data)\n"
   "    return condition\n"
   "  end\n"
   "    \n"
   "  function Parser:parseAction(data)\n"
   "    self:pushContext(data, \"action\")\n"
   "    local action\n"
   "    if type(data) == \"string\" then\n"
   "      action = {[data]={}}\n"
   "    elseif self:jsontype(data) == \"object\" then\n"
   "      self:assert(next(data, next(data)) == nil, \"action object must have only 1 attribute -- the action name\")\n"
   "      action = data\n"
   "    else\n"
   "      self:error(\"action must be string on 1-attribute object, but instead was a %s\", self:jsontype(data))\n"
   "    end\n"
   "    self:popContext()\n"
   "    --we can be more specific about the action name now\n"
   "    self:pushContext(data, (\"\\\"%s\\\" action\"):format(next(action)))\n"
   "    inheritmetatable(action, data)\n"
   "    action = Rule.action.parse(action, self)\n"
   "    self:popContext()\n"
   "    return action\n"
   "  end\n"
   "  \n"
   "  function Parser:parseActions(data, name)\n"
   "    if data == nil then\n"
   "      return {}\n"
   "    end\n"
   "    self:pushContext(data, name and (\"\\\"%s\\\" actions\"):format(name) or nil)\n"
   "    local actions = {}\n"
   "    inheritmetatable(actions, data)\n"
   "    if self:jsontype(data) == \"object\" or type(data)==\"string\" or (#data == 0 and next(data) ~= nil) then\n"
   "      table.insert(actions, self:parseAction(data))\n"
   "    elseif type(data) == \"table\" then\n"
   "      for _, v in ipairs(data) do\n"
   "        table.insert(actions, self:parseAction(v))\n"
   "      end\n"
   "    end\n"
   "    self:popContext()\n"
   "    return actions\n"
   "  end\n"
   "  \n"
   "  function Parser:parseTimeInterval(data, err)\n"
   "    if err then err = \" for \" .. err end\n"
   "    local typ = self:jsontype(data)\n"
   "    if typ == \"number\" then\n"
   "      return data\n"
   "    elseif typ == \"string\" then\n"
   "      local num, unit = data:match(\"^([%d.]+)([%w_]*)\")\n"
   "      local scale\n"
   "      num = tonumber(num)\n"
   "      self:assert(num and unit, (\"invalid time string \\\"%s\\\"%s\"):format(data, err))\n"
   "      if unit == \"ms\" or unit:match(\"^millisec(ond(s?))?\") then\n"
   "        scale = .01\n"
   "      elseif unit == \"\" or unit == \"s\" or unit:match(\"^sec(ond(s?))?\") then\n"
   "        scale = 1\n"
   "      elseif unit == \"m\" or unit:match(\"^min(ute(s)?)?\") then\n"
   "        scale = 60\n"
   "      elseif unit == \"h\" or unit:match(\"^hour(s?)\") then\n"
   "        scale = 3600\n"
   "      elseif unit == \"d\" or unit:match(\"^day(s)?\") then\n"
   "        scale = 86400\n"
   "      elseif unit == \"w\" or unit == \"wk\" or unit:match(\"^week(s)?\") then\n"
   "        scale = 604800\n"
   "      elseif unit == \"M\" or unit:match(\"^month(s)?\") then\n"
   "        scale = 2628001\n"
   "      else\n"
   "        self:error(\"unknown time unit \\\"%s\\\"%s\", unit, err)\n"
   "      end\n"
   "      return num * scale\n"
   "    else\n"
   "      self:error(\"invalid time inteval type \\\"%s\\\"%s\", self:jsontype(data), err)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Parser:parseLimiter(data, name)\n"
   "    self:pushContext(data, \"limiter\")\n"
   "    \n"
   "    if not data.name then data.name = name end\n"
   "    data.interval = self:parseTimeInterval(data.interval, \"interval value\")\n"
   "    self:assert(data.interval >= 60, \"\\\"interval\\\" value must be >= 60 seconds\")\n"
   "    self:assert(data.limit, \"missing \\\"limit\\\" value\")\n"
   "    data.limit = self:assert(tonumber(data.limit), \"invalid \\\"limit\\\" value, must be a number\")\n"
   "    self:assert(data.limit >= 0, \"\\\"limit\\\" value must be >= 0\")\n"
   "    \n"
   "    if data.sync_steps then\n"
   "      data.sync_steps = self:assert(tonumber(data.sync_steps), \"invalid \\\"sync-steps\\\" value\")\n"
   "    end\n"
   "    if data.burst then\n"
   "      self:assert_type(data.burst, \"string\", \"invalid \\\"burst\\\" value type\")\n"
   "    end\n"
   "    if data[\"burst-expire\"] then\n"
   "      data.burst_expire = self:parseTimeInterval(data[\"burst-expire\"], \"burst_expire value\")\n"
   "      data[\"burst-expire\"] = nil\n"
   "    end\n"
   "    \n"
   "    self:assert_type(data.name, \"string\", \"invalid limiter name\")\n"
   "    self:popContext()\n"
   "    return data\n"
   "  end\n"
   "  function Parser:checkLimiters(data)\n"
   "    if not data then return true end\n"
   "    self:pushContext(data, \"limiters\")\n"
   "    for _, v in pairs(data) do\n"
   "      self:pushContext(v, (\"limiter \\\"%s\\\"\"):format(v.name))\n"
   "      if v.burst then\n"
   "        --make sure the burst value refers to a known limiter\n"
   "        self:assert(data[v.burst], (\"limiter references unknown burst limiter \\\"%s\\\"\"):format(v.burst))\n"
   "      end\n"
   "      self:popContext()\n"
   "    end\n"
   "    self:popContext()\n"
   "  end\n"
   "  \n"
   "  local Parser_meta = {__index = Parser}\n"
   "  \n"
   "  local function newparser()\n"
   "    local parser = {\n"
   "      name = \"<?>\",\n"
   "      ctx_stack = {}\n"
   "    }\n"
   "    \n"
   "    setmetatable(parser, Parser_meta)\n"
   "    return parser\n"
   "  end\n"
   "  \n"
   "  return {new = newparser}\n"
   "\n"
   "end)\n"
   "\n"
   "\n"
   "return main()\n"}
};
const int wfx_redis_lua_scripts_count=3;
