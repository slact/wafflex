#include <ngx_wafflex_redis_lua_scripts.h>

wfx_redis_lua_scripts_t wfx_redis_lua_scripts = {
  {"init", "4f7d624f703483b37d89af715d7230c2ea24a95c",
   "\n"
   "--luacheck: globals redis\n"
   "\n"
   "redis.echo(\"hi there\")\n"
   "return \"hello\"\n"},

  {"ruleset_read", "152e908b3419eabece475671fa73939d650eae8f",
   "\n"
   "--luacheck: globals redis cjson ARGV\n"
   "local prefix =        ARGV[1]\n"
   "local item =          ARGV[2]\n"
   "local ruleset_name =  ARGV[3]\n"
   "local item_name =     ARGV[4]\n"
   "\n"
   "local encode = cjson.encode\n"
   "local tinsert = table.insert\n"
   "\n"
   "--[[local dbg= function(...)\n"
   "  local out = {...}\n"
   "  for i,v in pairs(out) do\n"
   "    out[i]=tostring(v)\n"
   "  end\n"
   "  redis.call(\"ECHO\", table.concat(out, \"    \"))\n"
   "end\n"
   "]]\n"
   "local Jsonobj; do\n"
   "  local Jmeta = {__index = {\n"
   "    use = function(self, ...)\n"
   "      for _, k in ipairs {...} do\n"
   "        self:add(k, self.data[k])\n"
   "      end\n"
   "    end,\n"
   "    useRaw = function(self, ...)\n"
   "      for _, k in ipairs {...} do\n"
   "        self:addRaw(k, self.data[k])\n"
   "      end\n"
   "    end,\n"
   "    add = function(self, key, data, raw)\n"
   "      if data == nil then return end\n"
   "      if not raw then data = encode(data) end\n"
   "      tinsert(self.buf, (\"%s: %s\"):format(encode(key), data))\n"
   "    end,\n"
   "    addRaw = function(self, key, data)\n"
   "      return self:add(key, data, true)\n"
   "    end,\n"
   "    json = function(self)\n"
   "      return (\"{ %s }\"):format(table.concat(self.buf, \", \\n\"))\n"
   "    end\n"
   "  }}\n"
   "  Jsonobj = function(data)\n"
   "    return setmetatable({buf={}, data=data or {}}, Jmeta)\n"
   "  end\n"
   "end\n"
   "\n"
   "local kbase, key, keyf;\n"
   "local function genkeys(new_ruleset_name)\n"
   "  kbase = (\"%sruleset:%s\"):format(prefix, new_ruleset_name)\n"
   "  key = {\n"
   "    rulesets = prefix..\"rulesets\",\n"
   "    ruleset =  kbase,\n"
   "    phases =   kbase..\":phases\",\n"
   "    lists =    kbase..\":lists\",\n"
   "    rules =    kbase..\":rules\",\n"
   "    limiters = kbase..\":limiters\"\n"
   "  }\n"
   "  keyf = {\n"
   "    list =         key.ruleset..\":list:%s\",\n"
   "    list_rules =   key.ruleset..\":list:%s:rules\",\n"
   "    list_refs =    key.ruleset..\":list:%s:refs\",\n"
   "    \n"
   "    rule =         key.ruleset..\":rule:%s\",\n"
   "    rule_refs =    key.ruleset..\":rule:%s:refs\",\n"
   "    \n"
   "    limiter =      key.ruleset..\":limiter:%s\",\n"
   "    limiter_refs = key.ruleset..\":limiter:%s:refs\",\n"
   "    \n"
   "    phase =        key.ruleset..\":phase:%s\",\n"
   "    phase_lists =  key.ruleset..\":phase:%s:lists\"\n"
   "  }\n"
   "end\n"
   "genkeys(ruleset_name)\n"
   "\n"
   "local function redis_gethash(redis_key)\n"
   "  local res = redis.call(\"HGETALL\", redis_key)\n"
   "  if type(res)~=\"table\" then return nil end\n"
   "  local h, k = {}, nil\n"
   "  for _, v in ipairs(res) do\n"
   "    if k == nil then k=v\n"
   "    else h[k]=v; k=nil end\n"
   "  end\n"
   "  return h\n"
   "end\n"
   "\n"
   "local function as_json(what, name)\n"
   "  local j, ll\n"
   "  if what == \"rule\" then\n"
   "    j = Jsonobj(redis_gethash(keyf.rule:format(name)))\n"
   "    if not j then return end\n"
   "    j:use(\"name\",\"info\",\"gen\", \"key\")\n"
   "    j:useRaw(\"if\", \"then\", \"else\")\n"
   "\n"
   "  elseif what == \"limiter\" then\n"
   "    j = Jsonobj(redis_gethash(keyf.limiter:format(name)))\n"
   "    if not j then return end\n"
   "    j:use(\"name\",\"info\",\"gen\",\"interval\",\"limit\",\"sync-steps\",\"burst\",\"burst-expire\")\n"
   "    \n"
   "  elseif what == \"list\" then\n"
   "    j = Jsonobj(redis_gethash(keyf.list:format(name)))\n"
   "    if not j then return end\n"
   "    j:use(\"name\",\"info\",\"gen\")\n"
   "    ll = redis.call(\"LRANGE\", keyf.list_rules:format(name), 0, -1)\n"
   "    if ll and #ll > 0 then\n"
   "      j:add(\"rules\", ll)\n"
   "    else\n"
   "      j:addRaw(\"rules\", \"[]\")\n"
   "    end\n"
   "  \n"
   "  elseif what == \"phase\" then\n"
   "    ll = redis.call(\"LRANGE\", keyf.phase_lists:format(name), 0, -1)\n"
   "    return #ll > 0 and encode(ll) or \"[]\"\n"
   "\n"
   "  elseif what == \"ruleset\" then\n"
   "    j = Jsonobj(redis_gethash(key.ruleset))\n"
   "    if not j then return end\n"
   "    \n"
   "    local function add_ruleset_items(the_item, items_set_key, attribute)\n"
   "      local jj = Jsonobj()\n"
   "      local members = redis.call(\"SMEMBERS\", items_set_key)\n"
   "      table.sort(members)\n"
   "      for _, n in ipairs(members) do\n"
   "        jj:addRaw(n, as_json(the_item, n))\n"
   "      end\n"
   "      j:addRaw(attribute, jj:json())\n"
   "    end\n"
   "    \n"
   "    add_ruleset_items(\"limiter\", key.limiters, \"limiters\")\n"
   "    add_ruleset_items(\"phase\", key.phases, \"phases\")\n"
   "    add_ruleset_items(\"list\", key.lists, \"lists\")\n"
   "    add_ruleset_items(\"rule\", key.rules, \"rules\")\n"
   "  else\n"
   "    error((\"unknown ruleset item \\\"%s\\\"\"):format(what))\n"
   "  end\n"
   "  return j:json()\n"
   "end\n"
   "\n"
   "return as_json(item, item_name)\n"},

  {"ruleset_write", "8ee7dae260352d2538b9274e5774e5b5bf169c96",
   "--[[autogenerated script, do not edit]] local require, module; local function main()   local Parser = require \"parser\"\n"
   "  local Ruleset = require \"ruleset\"\n"
   "  local Binding = require \"binding\"\n"
   "  local inspect = require \"inspect\"\n"
   "  \n"
   "  --luacheck: globals redis cjson ARGV unpack\n"
   "  local hmm = function(thing)\n"
   "    local out = inspect(thing)\n"
   "    for line in out:gmatch('[^\\r\\n]+') do\n"
   "      redis.call(\"ECHO\", line)\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  Ruleset.RuleComponent.generate_refs = true\n"
   "  \n"
   "  local tunpack = table.unpack or unpack\n"
   "  local function redis_hmset(key, tbl, ...)\n"
   "    local flat = {}\n"
   "    for _, k in ipairs{...} do\n"
   "      if tbl[k] then\n"
   "        table.insert(flat, k)\n"
   "        table.insert(flat, tbl[k])\n"
   "      end\n"
   "    end\n"
   "    if #flat > 0 then\n"
   "      redis.call(\"HMSET\", key, tunpack(flat))\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local nextarg; do local n = 0; nextarg = function(how_many)\n"
   "    local ret = {}; how_many = how_many or 1;\n"
   "    for i=1,how_many do ret[i]=ARGV[n+i] or false end\n"
   "    n = n + how_many\n"
   "    return tunpack(ret)\n"
   "  end; end\n"
   "  \n"
   "  local prefix, action, item, ruleset_name = nextarg(4)\n"
   "  prefix = #prefix>0 and prefix .. \":\" or \"\"\n"
   "  \n"
   "  local kbase, key, keyf;\n"
   "  local function genkeys(new_ruleset_name)\n"
   "    kbase = (\"%sruleset:%s\"):format(prefix, new_ruleset_name)\n"
   "    key = {\n"
   "      rulesets = prefix..\"rulesets\",\n"
   "      ruleset =  kbase,\n"
   "      phases =   kbase..\":phases\",\n"
   "      lists =    kbase..\":lists\",\n"
   "      rules =    kbase..\":rules\",\n"
   "      limiters = kbase..\":limiters\",\n"
   "      \n"
   "      pubsub = {\n"
   "        ruleset = kbase..\":pubsub\"\n"
   "      }\n"
   "    }\n"
   "    keyf = {\n"
   "      list =         key.ruleset..\":list:%s\",\n"
   "      list_rules =   key.ruleset..\":list:%s:rules\",\n"
   "      list_refs =    key.ruleset..\":list:%s:refs\",\n"
   "      \n"
   "      rule =         key.ruleset..\":rule:%s\",\n"
   "      rule_refs =    key.ruleset..\":rule:%s:refs\",\n"
   "      \n"
   "      limiter =      key.ruleset..\":limiter:%s\",\n"
   "      limiter_refs = key.ruleset..\":limiter:%s:refs\",\n"
   "      \n"
   "      phase =        key.ruleset..\":phase:%s\",\n"
   "      phase_lists =  key.ruleset..\":phase:%s:lists\"\n"
   "    }\n"
   "  end\n"
   "  genkeys(ruleset_name)\n"
   "  \n"
   "  Ruleset.uniqueName = function(thing, thingtbl, ruleset)\n"
   "    local name, thing_key, n, set_key\n"
   "    if thing == \"ruleset\" then\n"
   "      thing_key = prefix .. \"rulesets:n\"\n"
   "      set_key = key.rulesets\n"
   "    else\n"
   "      thing_key = (prefix .. \"ruleset:\" .. ruleset.name)\n"
   "      if     thing == \"phase\" then\n"
   "        set_key = key.phases\n"
   "      elseif thing == \"list\" then\n"
   "        set_key = key.lists\n"
   "      elseif thing == \"rule\" then\n"
   "        set_key = key.rules\n"
   "      elseif thing == \"limiter\" then\n"
   "        set_key = key.limiters\n"
   "      end\n"
   "    end\n"
   "    n = redis.call(\"HINCRBY\", thing_key, thing .. \":n\", 1)\n"
   "    name = (\"%s%i\"):format(thing, n)\n"
   "    \n"
   "    if redis.call(\"SISMEMBER\", set_key, name) == 1 then --already exists\n"
   "      return Ruleset.uniqueName(thing, thingtbl, ruleset)\n"
   "    elseif thingtbl and thingtbl[name] then -- also already exists\n"
   "      return Ruleset.uniqueName(thing, thingtbl, ruleset)\n"
   "    else\n"
   "      if thing == \"ruleset\" then genkeys(name) end\n"
   "      return name\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  local limiter_created = {} --needed because limiters can reference other limiters\n"
   "  Binding.set(\"limiter\", {\n"
   "    create = function(limiter)\n"
   "      if limiter.external then return end\n"
   "      if limiter_created[limiter.name] then return end\n"
   "      local lkey = keyf.limiter:format(limiter.name)\n"
   "      if redis.call(\"EXISTS\", lkey) == 1 then error(\"limiter \\\"\" .. limiter.name .. \"\\\" already exists\") end\n"
   "      limiter.gen = 0\n"
   "      redis_hmset(lkey, limiter, \"name\", \"info\", \"gen\", \"interval\", \"limit\", \"sync-steps\", \"burst-expire\")\n"
   "      if limiter.burst then\n"
   "        redis.call(\"HSET\", lkey, \"burst\", limiter.burst.name)\n"
   "      end\n"
   "      redis.call(\"SADD\", key.limiters, limiter.name)\n"
   "      \n"
   "      if limiter.burst then\n"
   "        redis.call(\"SADD\", keyf.limiter_refs:format(limiter.burst.name), \"limiter:\"..limiter.name)\n"
   "      end\n"
   "      \n"
   "      limiter_created[limiter.name]=true\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Binding.set(\"list\", {\n"
   "    create = function(list)\n"
   "      if list.external then return end\n"
   "      local lkey = keyf.list:format(list.name)\n"
   "      if redis.call(\"EXISTS\", lkey) == 1 then error(\"list \\\"\" .. list.name .. \"\\\" already exists\") end\n"
   "      list.gen = 0\n"
   "      redis_hmset(lkey, list, \"name\", \"info\", \"gen\")\n"
   "      \n"
   "      local list_rules_key = keyf.list_rules:format(list.name)\n"
   "      local list_refs_key = keyf.list_refs:format(list.name)\n"
   "      local list_ref = \"list:\"..list.name\n"
   "      for _, rule in ipairs(list.rules) do\n"
   "        redis.call(\"RPUSH\", list_rules_key, rule.name)\n"
   "        redis.call(\"ZINCRBY\", list_refs_key, 1, rule.name)\n"
   "        redis.call(\"SADD\", keyf.rule_refs:format(rule.name), list_ref)\n"
   "      end\n"
   "      \n"
   "      redis.call(\"SADD\", key.lists, list.name)\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Binding.set(\"phase\", {\n"
   "    create = function(phase)\n"
   "      if phase.external then return end\n"
   "      local pkey = keyf.phase:format(phase.name)\n"
   "      if redis.call(\"EXISTS\", pkey) == 1 then error(\"phase \\\"\" .. phase.name .. \"\\\" already exists\") end\n"
   "      phase.gen = 0\n"
   "      redis_hmset(pkey, phase, \"name\", \"info\", \"gen\")\n"
   "      \n"
   "      local phase_lists_key = keyf.phase_lists:format(phase.name)\n"
   "      for _, list in ipairs(phase.lists) do\n"
   "        redis.call(\"RPUSH\", phase_lists_key, list.name)\n"
   "      end\n"
   "      \n"
   "      redis.call(\"SADD\", key.phases, phase.name)\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Binding.set(\"rule\", {\n"
   "    create = function(rule)\n"
   "      local rkey = keyf.rule:format(rule.name)\n"
   "      if redis.call(\"EXISTS\", rkey) == 1 then error(\"rule \\\"\" .. rule.name .. \"\\\" already exists\") end\n"
   "      rule.gen = 0\n"
   "      redis_hmset(rkey, rule, \"name\", \"info\", \"gen\", \"key\")\n"
   "      redis.call(\"HSET\", rkey, \"if\", rule[\"if\"]:toJSON())\n"
   "      if rule[\"then\"] then\n"
   "        redis.call(\"HSET\", rkey, \"then\", rule[\"then\"]:toJSON())\n"
   "      end\n"
   "      if rule[\"else\"] then\n"
   "        redis.call(\"HSET\", rkey, \"else\", rule[\"else\"]:toJSON())\n"
   "      end\n"
   "      \n"
   "      if rule.refs then\n"
   "        local rule_ref = \"rule:\"..rule.name\n"
   "        for ref_type, ref in pairs(rule.refs) do\n"
   "          local refkeyf\n"
   "          if ref_type == \"limiter\" then\n"
   "            refkeyf = keyf.limiter_refs\n"
   "          elseif ref_type == \"rule\" then\n"
   "            refkeyf = keyf.rule_refs\n"
   "          else\n"
   "            assert(\"can't handle ref tyoe \" .. ref_type)\n"
   "          end\n"
   "          for _, ref_name in ipairs(ref) do\n"
   "            redis.call(\"SADD\", refkeyf:format(ref_name), rule_ref)\n"
   "          end\n"
   "        end\n"
   "      end\n"
   "      \n"
   "      redis.call(\"SADD\", key.rules, rule.name)\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  Binding.set(\"ruleset\", {\n"
   "    create = function(ruleset)\n"
   "      if redis.call(\"SISMEMBER\", key.rulesets, ruleset.name) == 1 then error((\"ruleset \\\"%s\\\" already exists\"):format(ruleset.name)) end\n"
   "      \n"
   "      ruleset.gen = 0\n"
   "      redis_hmset(key.ruleset, ruleset, \"name\", \"info\", \"gen\")\n"
   "      redis.call(\"SADD\", key.rulesets, ruleset.name)\n"
   "    end\n"
   "  })\n"
   "  \n"
   "  local actions\n"
   "  actions = {\n"
   "    ruleset = {\n"
   "      create = function()\n"
   "        if #ruleset_name > 0 and redis.call(\"EXISTS\", key.ruleset) == 1 then\n"
   "          return {0, (\"ruleset \\\"%s\\\" already exists\"):format(ruleset_name)}\n"
   "        end\n"
   "        \n"
   "        local json_in = nextarg(1)\n"
   "        \n"
   "        local p = Parser.new()\n"
   "        local parsed, err = p:parseJSON(\"ruleset\", json_in, ruleset_name or \"anonymous ruleset\", true)\n"
   "        if not parsed then\n"
   "          return {0, err}\n"
   "        end\n"
   "        if #ruleset_name > 0 then\n"
   "          parsed.name = ruleset_name\n"
   "        end\n"
   "        \n"
   "        local rs = Ruleset.new(parsed)\n"
   "        hmm(rs)\n"
   "        \n"
   "        return {1}\n"
   "      end,\n"
   "      delete = function()\n"
   "        local name = nextarg(1)\n"
   "        error(\"can'd do this yet\" .. name, ruleset_name)\n"
   "      end\n"
   "    },\n"
   "    list = {\n"
   "      create = function()\n"
   "      \n"
   "      end,\n"
   "      delete = function()\n"
   "      \n"
   "      end\n"
   "    },\n"
   "    rule = {\n"
   "      create = function()\n"
   "      \n"
   "      end,\n"
   "      delete = function()\n"
   "      \n"
   "      end\n"
   "    },\n"
   "    limiter = {\n"
   "      create = function()\n"
   "      \n"
   "      end,\n"
   "      delete = function()\n"
   "      \n"
   "      end\n"
   "    }\n"
   "  }\n"
   "  \n"
   "  if type(actions[item]) == \"function\" then\n"
   "    actions[item](action)\n"
   "  elseif actions[item][action] then\n"
   "    return actions[item][action]()\n"
   "  else\n"
   "    error((\"unknown action %s for item %s\"):format(action, item))\n"
   "  end\n"
   "\n"
   "end\n"
   "do\n"
   "  local modules = {}\n"
   "  module = function(name, fn) modules[name]=fn() end\n"
   "  require = function(name) return modules[name] end\n"
   "end\n"
   "--luacheck: ignore\n"
   "\n"
   "module(\"inspect\", function()\n"
   "local a={_VERSION='inspect.lua 3.1.0',_URL='http://github.com/kikito/inspect.lua',_DESCRIPTION='human-readable representations of tables',_LICENSE=\"MIT LICENSE; Copyright (c) 2013 Enrique Garc√≠a Cota\"}local tostring=tostring;a.KEY=setmetatable({},{__tostring=function()return'inspect.KEY'end})a.METATABLE=setmetatable({},{__tostring=function()return'inspect.METATABLE'end})local function b(c)if c:match('\"')and not c:match(\"'\")then return\"'\"..c..\"'\"end;return'\"'..c:gsub('\"','\\\\\"')..'\"'end;local d={[\"\\a\"]=\"\\\\a\",[\"\\b\"]=\"\\\\b\",[\"\\f\"]=\"\\\\f\",[\"\\n\"]=\"\\\\n\",[\"\\r\"]=\"\\\\r\",[\"\\t\"]=\"\\\\t\",[\"\\v\"]=\"\\\\v\"}local e={}for f=0,31 do local g=string.char(f)if not d[g]then d[g]=\"\\\\\"..f;e[g]=string.format(\"\\\\%03d\",f)end end;local function h(c)return c:gsub(\"\\\\\",\"\\\\\\\\\"):gsub(\"(%c)%f[0-9]\",e):gsub(\"%c\",d)end;local function i(c)return type(c)=='string'and c:match(\"^[_%a][_%a%d]*$\")end;local function j(k,l)return type(k)=='number'and 1<=k and k<=l and math.floor(k)==k end;local m={['number']=1,['boolean']=2,['string']=3,['table']=4,['function']=5,['userdata']=6,['thread']=7}local function n(o,p)local q,r=type(o),type(p)if q==r and(q=='string'or q=='number')then return o<p end;local s,t=m[q],m[r]if s and t then return m[q]<m[r]elseif s then return true elseif t then return false end;return q<r end;local function u(v)local w=1;local x=rawget(v,w)while x~=nil do w=w+1;x=rawget(v,w)end;return w-1 end;local function y(v)local z={}local l=u(v)for k,A in pairs(v)do if not j(k,l)then table.insert(z,k)end end;table.sort(z,n)return z,l end;local function B(v,C)local D=type(C)=='table'and rawget(C,'__tostring')local c,E;if type(D)=='function'then E,c=pcall(D,v)c=E and c or'error: '..tostring(c)end;if type(c)=='string'and#c>0 then return c end end;local function F(v,G)G=G or{}if type(v)=='table'then if not G[v]then G[v]=1;for k,x in pairs(v)do F(k,G)F(x,G)end;F(getmetatable(v),G)else G[v]=G[v]+1 end end;return G end;local H=function(I)local J,w={},#I;for f=1,w do J[f]=I[f]end;return J,w end;local function K(L,...)local z={...}local M,w=H(L)for f=1,#z do M[w+f]=z[f]end;return M end;local function N(O,P,L,Q)if P==nil then return nil end;if Q[P]then return Q[P]end;local R=O(P,L)if type(R)=='table'then local S={}Q[P]=S;local T;for k,x in pairs(R)do T=N(O,k,K(L,k,a.KEY),Q)if T~=nil then S[T]=N(O,x,K(L,T),Q)end end;local C=N(O,getmetatable(R),K(L,a.METATABLE),Q)setmetatable(S,C)R=S end;return R end;local U={}local V={__index=U}function U:puts(...)local W={...}local X=self.buffer;local w=#X;for f=1,#W do w=w+1;X[w]=W[f]end end;function U:down(Y)self.level=self.level+1;Y()self.level=self.level-1 end;function U:tabify()self:puts(self.newline,string.rep(self.indent,self.level))end;function U:alreadyVisited(x)return self.ids[x]~=nil end;function U:getId(x)local Z=self.ids[x]if not Z then local _=type(x)Z=(self.maxIds[_]or 0)+1;self.maxIds[_]=Z;self.ids[x]=Z end;return tostring(Z)end;function U:putKey(k)if i(k)then return self:puts(k)end;self:puts(\"[\")self:putValue(k)self:puts(\"]\")end;function U:putTable(v)if v==a.KEY or v==a.METATABLE then self:puts(tostring(v))elseif self:alreadyVisited(v)then self:puts('<table ',self:getId(v),'>')elseif self.level>=self.depth then self:puts('{...}')else if self.tableAppearances[v]>1 then self:puts('<',self:getId(v),'>')end;local a0,l=y(v)local C=getmetatable(v)local a1=B(v,C)self:puts('{')self:down(function()if a1 then self:puts(' -- ',h(a1))if l>=1 then self:tabify()end end;local a2=0;for f=1,l do if a2>0 then self:puts(',')end;self:puts(' ')self:putValue(v[f])a2=a2+1 end;for A,k in ipairs(a0)do if a2>0 then self:puts(',')end;self:tabify()self:putKey(k)self:puts(' = ')self:putValue(v[k])a2=a2+1 end;if C then if a2>0 then self:puts(',')end;self:tabify()self:puts('<metatable> = ')self:putValue(C)end end)if#a0>0 or C then self:tabify()elseif l>0 then self:puts(' ')end;self:puts('}')end end;function U:putValue(x)local _=type(x)if _=='string'then self:puts(b(h(x)))elseif _=='number'or _=='boolean'or _=='nil'then self:puts(tostring(x))elseif _=='table'then self:putTable(x)else self:puts('<',_,' ',self:getId(x),'>')end end;function a.inspect(a3,a4)a4=a4 or{}local a5=a4.depth or math.huge;local a6=a4.newline or'\\n'local a7=a4.indent or'  'local O=a4.process;if O then a3=N(O,a3,{},{})end;local a8=setmetatable({depth=a5,level=0,buffer={},ids={},maxIds={},newline=a6,indent=a7,tableAppearances=F(a3)},V)a8:putValue(a3)return table.concat(a8.buffer)end;setmetatable(a,{__call=function(A,...)return a.inspect(...)end})return a\n"
   "\n"
   "end)\n"
   "\n"
   "module(\"dkjson\", function()\n"
   "local a=false;local b=false;local c='json'local pairs,type,tostring,tonumber,getmetatable,setmetatable,rawset=pairs,type,tostring,tonumber,getmetatable,setmetatable,rawset;local error,require,pcall,select=error,require,pcall,select;local d,e=math.floor,math.huge;local f,g,h,i,j,k,l,m=string.rep,string.gsub,string.sub,string.byte,string.char,string.find,string.len,string.format;local n=string.match;local o=table.concat;local p={version=\"dkjson 2.5\"}if b then _G[c]=p end;local q=nil;pcall(function()local r=require\"debug\".getmetatable;if r then getmetatable=r end end)p.null=setmetatable({},{__tojson=function()return\"null\"end})local function s(t)local u,v,w=0,0,0;for x,y in pairs(t)do if x=='n'and type(y)=='number'then w=y;if y>u then u=y end else if type(x)~='number'or x<1 or d(x)~=x then return false end;if x>u then u=x end;v=v+1 end end;if u>10 and u>w and u>v*2 then return false end;return true,u end;local z={[\"\\\"\"]=\"\\\\\\\"\",[\"\\\\\"]=\"\\\\\\\\\",[\"\\b\"]=\"\\\\b\",[\"\\f\"]=\"\\\\f\",[\"\\n\"]=\"\\\\n\",[\"\\r\"]=\"\\\\r\",[\"\\t\"]=\"\\\\t\"}local function A(B)local C=z[B]if C then return C end;local D,E,F,G=i(B,1,4)D,E,F,G=D or 0,E or 0,F or 0,G or 0;if D<=0x7f then C=D elseif 0xc0<=D and D<=0xdf and E>=0x80 then C=(D-0xc0)*0x40+E-0x80 elseif 0xe0<=D and D<=0xef and E>=0x80 and F>=0x80 then C=((D-0xe0)*0x40+E-0x80)*0x40+F-0x80 elseif 0xf0<=D and D<=0xf7 and E>=0x80 and F>=0x80 and G>=0x80 then C=(((D-0xf0)*0x40+E-0x80)*0x40+F-0x80)*0x40+G-0x80 else return\"\"end;if C<=0xffff then return m(\"\\\\u%.4x\",C)elseif C<=0x10ffff then C=C-0x10000;local H,I=0xD800+d(C/0x400),0xDC00+C%0x400;return m(\"\\\\u%.4x\\\\u%.4x\",H,I)else return\"\"end end;local function J(K,L,M)if k(K,L)then return g(K,L,M)else return K end end;local function N(C)C=J(C,\"[%z\\1-\\31\\\"\\\\\\127]\",A)if k(C,\"[\\194\\216\\220\\225\\226\\239]\")then C=J(C,\"\\194[\\128-\\159\\173]\",A)C=J(C,\"\\216[\\128-\\132]\",A)C=J(C,\"\\220\\143\",A)C=J(C,\"\\225\\158[\\180\\181]\",A)C=J(C,\"\\226\\128[\\140-\\143\\168-\\175]\",A)C=J(C,\"\\226\\129[\\160-\\175]\",A)C=J(C,\"\\239\\187\\191\",A)C=J(C,\"\\239\\191[\\176-\\191]\",A)end;return\"\\\"\"..C..\"\\\"\"end;p.quotestring=N;local function O(K,P,v)local Q,R=k(K,P,1,true)if Q then return h(K,1,Q-1)..v..h(K,R+1,-1)else return K end end;local S,T;local function U()S=n(tostring(0.5),\"([^05+])\")T=\"[^0-9%-%+eE\"..g(S,\"[%^%$%(%)%%%.%[%]%*%+%-%?]\",\"%%%0\")..\"]+\"end;U()local function V(W)return O(J(tostring(W),T,\"\"),S,\".\")end;local function X(K)local W=tonumber(O(K,\".\",S))if not W then U()W=tonumber(O(K,\".\",S))end;return W end;local function Y(Z,_,a0)_[a0+1]=\"\\n\"_[a0+2]=f(\"  \",Z)a0=a0+2;return a0 end;function p.addnewline(a1)if a1.indent then a1.bufferlen=Y(a1.level or 0,a1.buffer,a1.bufferlen or#a1.buffer)end end;local a2;local function a3(a4,C,a5,a6,Z,_,a0,a7,a8,a1)local a9=type(a4)if a9~='string'and a9~='number'then return nil,\"type '\"..a9 ..\"' is not supported as a key by JSON.\"end;if a5 then a0=a0+1;_[a0]=\",\"end;if a6 then a0=Y(Z,_,a0)end;_[a0+1]=N(a4)_[a0+2]=\":\"return a2(C,a6,Z,_,a0+2,a7,a8,a1)end;local function aa(ab,_,a1)local a0=a1.bufferlen;if type(ab)=='string'then a0=a0+1;_[a0]=ab end;return a0 end;local function ac(ad,C,a1,_,a0,ae)ae=ae or ad;local af=a1.exception;if not af then return nil,ae else a1.bufferlen=a0;local ag,ah=af(ad,C,a1,ae)if not ag then return nil,ah or ae end;return aa(ag,_,a1)end end;function p.encodeexception(ad,C,a1,ae)return N(\"<\"..ae..\">\")end;a2=function(C,a6,Z,_,a0,a7,a8,a1)local ai=type(C)local aj=getmetatable(C)aj=type(aj)=='table'and aj;local ak=aj and aj.__jsonval;if ak then if type(ak)==\"function\"then C=ak(C)else C=ak end;ai=type(C)end;local al=aj and aj.__tojson;if al then if a7[C]then return ac('reference cycle',C,a1,_,a0)end;a7[C]=true;a1.bufferlen=a0;local ag,ah=al(C,a1)if not ag then return ac('custom encoder failed',C,a1,_,a0,ah)end;a7[C]=nil;a0=aa(ag,_,a1)elseif C==nil then a0=a0+1;_[a0]=\"null\"elseif ai=='number'then local am;if C~=C or C>=e or-C>=e then am=\"null\"else am=V(C)end;a0=a0+1;_[a0]=am elseif ai=='boolean'then a0=a0+1;_[a0]=C and\"true\"or\"false\"elseif ai=='string'then a0=a0+1;_[a0]=N(C)elseif ai=='table'then if a7[C]then return ac('reference cycle',C,a1,_,a0)end;a7[C]=true;Z=Z+1;local an,v=s(C)if v==0 and aj and aj.__jsontype=='object'then an=false end;local ah;if an then a0=a0+1;_[a0]=\"[\"for Q=1,v do a0,ah=a2(C[Q],a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;if Q<v then a0=a0+1;_[a0]=\",\"end end;a0=a0+1;_[a0]=\"]\"else local a5=false;a0=a0+1;_[a0]=\"{\"local ao=aj and aj.__jsonorder or a8;if ao then if type(ao)==\"function\"then ao=ao(C)end;local ap={}v=#ao;for Q=1,v do local x=ao[Q]local y=C[x]if y then ap[x]=true;a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)a5=true end end;for x,y in pairs(C)do if not ap[x]then a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;a5=true end end else for x,y in pairs(C)do a0,ah=a3(x,y,a5,a6,Z,_,a0,a7,a8,a1)if not a0 then return nil,ah end;a5=true end end;if a6 then a0=Y(Z-1,_,a0)end;a0=a0+1;_[a0]=\"}\"end;a7[C]=nil else return ac('unsupported type',C,a1,_,a0,\"type '\"..ai..\"' is not supported by JSON.\")end;return a0 end;function p.encode(C,a1)a1=a1 or{}local aq=a1.buffer;local _=aq or{}a1.buffer=_;U()local ag,ah=a2(C,a1.indent,a1.level or 0,_,a1.bufferlen or 0,a1.tables or{},a1.keyorder,a1)if not ag then error(ah,2)elseif aq==_ then a1.bufferlen=ag;return true else a1.bufferlen=nil;a1.buffer=nil;return o(_)end end;local function ar(K,as)local at,au,av=1,1,0;while true do au=k(K,\"\\n\",au,true)if au and au<as then at=at+1;av=au;au=au+1 else break end end;return\"line \"..at..\", column \"..as-av end;local function aw(K,ax,as)return nil,l(K)+1,\"unterminated \"..ax..\" at \"..ar(K,as)end;local function ay(K,au)while true do au=k(K,\"%S\",au)if not au then return nil end;local az=h(K,au,au+1)if az==\"\\239\\187\"and h(K,au+2,au+2)==\"\\191\"then au=au+3 elseif az==\"//\"then au=k(K,\"[\\n\\r]\",au+2)if not au then return nil end elseif az==\"/*\"then au=k(K,\"*/\",au+2)if not au then return nil end;au=au+2 else return au end end end;local aA={[\"\\\"\"]=\"\\\"\",[\"\\\\\"]=\"\\\\\",[\"/\"]=\"/\",[\"b\"]=\"\\b\",[\"f\"]=\"\\f\",[\"n\"]=\"\\n\",[\"r\"]=\"\\r\",[\"t\"]=\"\\t\"}local function aB(C)if C<0 then return nil elseif C<=0x007f then return j(C)elseif C<=0x07ff then return j(0xc0+d(C/0x40),0x80+d(C)%0x40)elseif C<=0xffff then return j(0xe0+d(C/0x1000),0x80+d(C/0x40)%0x40,0x80+d(C)%0x40)elseif C<=0x10ffff then return j(0xf0+d(C/0x40000),0x80+d(C/0x1000)%0x40,0x80+d(C/0x40)%0x40,0x80+d(C)%0x40)else return nil end end;local function aC(K,au)local aD=au+1;local _,v={},0;while true do local aE=k(K,\"[\\\"\\\\]\",aD)if not aE then return aw(K,\"string\",au)end;if aE>aD then v=v+1;_[v]=h(K,aD,aE-1)end;if h(K,aE,aE)==\"\\\"\"then aD=aE+1;break else local aF=h(K,aE+1,aE+1)local C;if aF==\"u\"then C=tonumber(h(K,aE+2,aE+5),16)if C then local aG;if 0xD800<=C and C<=0xDBff then if h(K,aE+6,aE+7)==\"\\\\u\"then aG=tonumber(h(K,aE+8,aE+11),16)if aG and 0xDC00<=aG and aG<=0xDFFF then C=(C-0xD800)*0x400+aG-0xDC00+0x10000 else aG=nil end end end;C=C and aB(C)if C then if aG then aD=aE+12 else aD=aE+6 end end end end;if not C then C=aA[aF]or aF;aD=aE+2 end;v=v+1;_[v]=C end end;if v==1 then return _[1],aD elseif v>1 then return o(_),aD else return\"\",aD end end;local aH;local function aI(t,aJ,K,au)if type(aJ)==\"function\"then aJ=aJ(K,au)if type(aJ)~=\"table\"then return t end end;return setmetatable(t,aJ)end;local function aK(ax,aL,K,aM,aN,aO,aP)local aQ=l(K)local t,v={},0;local au=aM+1;if ax=='object'then aI(t,aO,K,aM)else aI(t,aP,K,aM)end;while true do au=ay(K,au)if not au then return aw(K,ax,aM)end;local aR=h(K,au,au)if aR==aL then return t,au+1 end;local aS,aT;aS,au,aT=aH(K,au,aN,aO,aP)if aT then return nil,au,aT end;au=ay(K,au)if not au then return aw(K,ax,aM)end;aR=h(K,au,au)if aR==\":\"then if aS==nil then return nil,au,\"cannot use nil as table index (at \"..ar(K,au)..\")\"end;au=ay(K,au+1)if not au then return aw(K,ax,aM)end;local aU;aU,au,aT=aH(K,au,aN,aO,aP)if aT then return nil,au,aT end;t[aS]=aU;au=ay(K,au)if not au then return aw(K,ax,aM)end;aR=h(K,au,au)else v=v+1;t[v]=aS end;if aR==\",\"then au=au+1 end end end;aH=function(K,au,aN,aO,aP)au=au or 1;au=ay(K,au)if not au then return nil,l(K)+1,\"no valid JSON value (reached the end)\"end;local aR=h(K,au,au)if aR==\"{\"then return aK('object',\"}\",K,au,aN,aO,aP)elseif aR==\"[\"then return aK('array',\"]\",K,au,aN,aO,aP)elseif aR==\"\\\"\"then return aC(K,au)else local aV,aW=k(K,\"^%-?[%d%.]+[eE]?[%+%-]?%d*\",au)if aV then local aX=X(h(K,aV,aW))if aX then return aX,aW+1 end end;aV,aW=k(K,\"^%a%w*\",au)if aV then local aY=h(K,aV,aW)if aY==\"true\"then return true,aW+1 elseif aY==\"false\"then return false,aW+1 elseif aY==\"null\"then return aN,aW+1 end end;return nil,au,\"no valid JSON value at \"..ar(K,au)end end;local function aZ(...)if select(\"#\",...)>0 then return...else return{__jsontype='object'},{__jsontype='array'}end end;function p.decode(K,au,aN,...)local aO,aP=aZ(...)return aH(K,au,aN,aO,aP)end;function p.use_lpeg()local a_=require(\"lpeg\")if a_.version()==\"0.11\"then error\"due to a bug in LPeg 0.11, it cannot be used for JSON matching\"end;local b0=a_.match;local b1,b2,b3=a_.P,a_.S,a_.R;local function b4(K,au,ah,a1)if not a1.msg then a1.msg=ah..\" at \"..ar(K,au)a1.pos=au end;return false end;local function b5(ah)return a_.Cmt(a_.Cc(ah)*a_.Carg(2),b4)end;local b6=b1\"//\"*(1-b2\"\\n\\r\")^0;local b7=b1\"/*\"*(1-b1\"*/\")^0*b1\"*/\"local b8=(b2\" \\n\\r\\t\"+b1\"\\239\\187\\191\"+b6+b7)^0;local b9=1-b2\"\\\"\\\\\\n\\r\"local ba=b1\"\\\\\"*a_.C(b2\"\\\"\\\\/bfnrt\"+b5\"unsupported escape sequence\")/aA;local bb=b3(\"09\",\"af\",\"AF\")local function bc(bd,au,be,bf)be,bf=tonumber(be,16),tonumber(bf,16)if 0xD800<=be and be<=0xDBff and 0xDC00<=bf and bf<=0xDFFF then return true,aB((be-0xD800)*0x400+bf-0xDC00+0x10000)else return false end end;local function bg(bh)return aB(tonumber(bh,16))end;local bi=b1\"\\\\u\"*a_.C(bb*bb*bb*bb)local bj=a_.Cmt(bi*bi,bc)+bi/bg;local bk=bj+ba+b9;local bl=b1\"\\\"\"*a_.Cs(bk^0)*(b1\"\\\"\"+b5\"unterminated string\")local bm=b1\"-\"^-1*(b1\"0\"+b3\"19\"*b3\"09\"^0)local bn=b1\".\"*b3\"09\"^0;local bo=b2\"eE\"*b2\"+-\"^-1*b3\"09\"^1;local bp=bm*bn^-1*bo^-1/X;local bq=b1\"true\"*a_.Cc(true)+b1\"false\"*a_.Cc(false)+b1\"null\"*a_.Carg(1)local br=bp+bl+bq;local bs,bt;local function bu(K,au,aN,a1)local bv,bw;local bx;local by,bz={},0;repeat bv,bw,bx=b0(bs,K,au,aN,a1)if not bx then break end;au=bx;bz=bz+1;by[bz]=bv until bw=='last'return au,setmetatable(by,a1.arraymeta)end;local function bA(K,au,aN,a1)local bv,a4,bw;local bx;local by={}repeat a4,bv,bw,bx=b0(bt,K,au,aN,a1)if not bx then break end;au=bx;by[a4]=bv until bw=='last'return au,setmetatable(by,a1.objectmeta)end;local bB=b1\"[\"*a_.Cmt(a_.Carg(1)*a_.Carg(2),bu)*b8*(b1\"]\"+b5\"']' expected\")local bC=b1\"{\"*a_.Cmt(a_.Carg(1)*a_.Carg(2),bA)*b8*(b1\"}\"+b5\"'}' expected\")local bD=b8*(bB+bC+br)local bE=bD+b8*b5\"value expected\"bs=bD*b8*(b1\",\"*a_.Cc'cont'+a_.Cc'last')*a_.Cp()local bF=a_.Cg(b8*bl*b8*(b1\":\"+b5\"colon expected\")*bE)bt=bF*b8*(b1\",\"*a_.Cc'cont'+a_.Cc'last')*a_.Cp()local bG=bE*a_.Cp()function p.decode(K,au,aN,...)local a1={}a1.objectmeta,a1.arraymeta=aZ(...)local bv,bH=b0(bG,K,au,aN,a1)if a1.msg then return nil,a1.pos,a1.msg else return bv,bH end end;p.use_lpeg=function()return p end;p.using_lpeg=true;return p end;if a then pcall(p.use_lpeg)end;return p\n"
   "\n"
   "end)\n"
   "\n"
   "module(\"binding\", function()\n"
   "local a={}local b={bindings=a,require_create_userdata=false,require_binding=false}setmetatable(a,{__index=function(c,d)if b.require_binding then error(\"missing binding for \"..tostring(d))end end})local e={create=function(f,self,...)if type(self)~=\"table\"then return nil,(\"expected 'self' to be table, got %s)\"):format(type(self))end;local g=f(self,...)if(b.require_create_userdata or g)and type(g)~=\"userdata\"then return nil,(\"expected userdata, got %s\"):format(type(g))elseif type(g)==\"userdata\"then self.__binding=g end;return true end,update=function(h,self,i,j,...)if type(self)~=\"table\"then return nil,(\"expected 'self' to be table, got %s)\"):format(type(self))end;if type(i)~=\"string\"then return nil,(\"expected 'update_name' to be string, got %s)\"):format(type(self))end;local g=h(self,i,j,...)if type(g)==\"userdata\"then self.__binding=g end;return true end,replace=function(k,self,l,...)if type(self)~=\"table\"then return nil,(\"expected 'self'(replacement) to be table, got %s)\"):format(type(self))end;if type(self)~=\"table\"then return nil,(\"expected 'replacee' to be table, got %s)\"):format(type(l))end;if self.ruleset~=l.ruleset then return nil,\"replacement ruleset differs from replacee ruleset\"end;local g=k(self,l,...)if type(g)==\"userdata\"then self.__binding=g end;return true end,delete=function(m,self,...)if type(self)~=\"table\"then return nil,(\"expected 'self' to be table, got %s)\"):format(type(self))end;assert(type(self.__binding)==\"userdata\",(\"expected seld.__binding userdata, got %s\"):format(type(self.__binding)))m(self.__binding,self,...)return true end}function b.set(n,o,p,q,r)assert(not rawget(a,n),(\"binding %s already set\"):format(n))assert(type(n)==\"string\",\"binding name must be a string, got \"..type(n))if type(o)==\"table\"and p==nil and q==nil and r==nil then local s=o;o=s.create;p=s.replace;q=s.update;r=s.delete end;local t={create=o,replace=p,update=q,delete=r}for u,v in pairs(t)do assert(type(v)==\"function\"or type(v)==nil,(\"\\\"%s\\\" binding \\\"%s\\\" callback must be function or nil, was %s\"):format(n,u,type(v)))end;a[n]=t end;function b.call(w,x,...)local t=a[w]if not t then return end;local y=e[x]if not y then error((\"unknown binding call \\\"%s\\\" for \\\"%s\\\"\"):format(x,w))end;if not t[x]then error((\"no callback for binding call \\\"%s\\\" for \\\"%s\\\"\"):format(x,w))end;local z,A=y(t[x],...)if not z then error((\"Binding \\\"%s\\\" call \\\"%s\\\" error: %s\"):format(w,x,A))end;return z end;return b\n"
   "\n"
   "end)\n"
   "\n"
   "module(\"rulecomponent\", function()\n"
   "local a=require\"binding\"local b=require\"dkjson\"local c;local function d(e)return e:sub(1,1)==\"#\"and e:sub(2)or e end;local f={__index=function(self,g)local h=d(g)if h~=g then return self[d(g)]end end}local function i(j)local self={table=setmetatable({},f)}local function k(l,m)local n,o=next(l)if type(n)==\"number\"then m:error(\"invalid data value, expected {\\\"key\\\":value}, got {\\\"key\\\"}\")elseif type(n)~=\"string\"then m:error(\"unexpected data type %s\",type(n))end;local p=self.table[n]if m then m:assert(p,(\"Unknown %s \\\"%s\\\"\"):format(j,n))else assert(p,(\"Unknown %s \\\"%s\\\"\"):format(j,n))end;return n,o end;function self.add(n,q)if type(n)==\"table\"then for r,s in pairs(n)do self.add(s,q)end;return true end;assert(q.parse,(\"%s missing parse callback\"):format(j))assert(self.table[n]==nil,(\"%s %s already exists\"):format(j,n))local t={parse=q.parse,init=q.init,delete=q.delete,meta={__jsonval=q.jsonval,__jsonorder=q.jsonorder or{\"action\",\"condition\"},__index={toJSON=function(u)return b.encode(u,{indent=true})end}}}self.table[n]=t;return true end;function self.parse(l,m)local n,o=k(l,m)o=self.table[n].parse(o,m)or o;return{[n]=o}end;function self.new(l,v)local n,o=k(l)n=d(n)local w=self.table[n]local p=setmetatable({[j]=n,data=o},w.meta)if w.init then local x=w.init(o,p,v)if x then p.data=x end end;a.call((\"%s:%s\"):format(j,n),\"create\",p)return p end;function self.delete(p,v)local n=p[j]or p.name;local w=self.table[n]print(j..\" DELETE THING \"..n..\" \"..tostring(w.delete))if w.delete then w.delete(p.data,v)end;a.call((\"%s:%s\"):format(j,n),\"delete\",p)end;return self end;c={condition=i(\"condition\"),action=i(\"action\")}c.condition.add(\"any\",{parse=function(l,m)m:assert_jsontype(l,\"array\",\"\\\"any\\\" condition value must be an array of conditions\")for y,s in ipairs(l)do local z=m:parseCondition(s)l[y]=z end end,init=function(l,p,v)for y,s in ipairs(l)do l[y]=c.condition.new(s,v)end end,delete=function(l,v)for r,A in ipairs(l)do c.condition.delete(A,v)end end,jsonval=function(self)return{any=self.data}end})c.condition.add(\"all\",{parse=function(l,m)m:assert_jsontype(l,\"array\",\"\\\"all\\\" condition value must be an array of conditions\")for y,s in ipairs(l)do local z=m:parseCondition(s)l[y]=z end end,init=function(l,v)for y,s in ipairs(l)do l[y]=c.condition.new(s,v)end end,delete=function(l,v)for r,A in ipairs(l)do c.condition.delete(A,v)end end,jsonval=function(self)return{all=self.data}end})c.condition.add({\"true\",\"false\"},{parse=function(l,m)end,jsonval=function(self)return self.condition end})c.condition.add(\"tag-check\",{parse=function(l,m)m:assert_type(l,\"string\",\"\\\"tag-check\\\" value must be a string\")return m:parseInterpolatedString(l)end,init=function(l)a.call(\"string\",\"create\",l)end,delete=function(l)a.call(\"string\",\"delete\",l)end,jsonval=function(self)return{[\"tag-check\"]=self.data.string}end})c.condition.add(\"match\",{parse=function(l,m)m:assert_jsontype(l,\"array\",\"\\\"match\\\" value must be an array of strings\")for y,s in ipairs(l)do m:assert_jsontype(s,\"string\",\"\\\"match\\\" value must be an array of strings\")l[y]=m:parseInterpolatedString(s)end end,init=function(l)local B=function(e)local C=0;for r in e.string:gmatch(\"%$\")do C=C+1 end;return C end;local D=function(E,F)return B(E)<B(F)end;table.sort(l,D)for r,e in ipairs(l)do a.call(\"string\",\"create\",e)end end,delete=function(l)for r,e in ipairs(l)do a.call(\"string\",\"delete\",e)end end,jsonval=function(self)local G={}for r,e in ipairs(self.data)do table.insert(G,e.string)end;return{match=G}end})local H={__jsonorder={\"name\",\"key\",\"increment\"}}c.condition.add({\"limit-break\",\"limit-check\"},{parse=function(l,m)if type(l)==\"string\"then l={name=l}elseif type(l)~=\"table\"then m:error(\"invalid value type %s\",type(l))end;local I=next(m:getContext())local J=m:getContext(\"rule\")if not l.key then l.key=J.key end;m:assert(l.key,\"limiter \\\"key\\\" missing, and no default \\\"key\\\" in rule\")m:assert_type(l.key,\"string\",\"invalid limiter \\\"key\\\" type\")l.key=m:parseInterpolatedString(l.key)if not l.increment then if I==\"limit-break\"then l.increment=1 elseif I==\"limit-check\"then l.increment=0 end end;l.increment=m:assert(tonumber(l.increment),\"invalid or empty \\\"increment\\\" value\")m:assert(l.increment>=0,\"\\\"increment\\\" must be >= 0\")m:assert(l.name,\"name missing\")m:assert_type(l.name,\"string\",\"invalid \\\"name\\\" type\")if c.generate_refs then if not J.refs then J.refs={}end;if not J.refs.limiter then J.refs.limiter={}end;table.insert(J.refs.limiter,l.name)end;return l end,init=function(l,p,v)local K=v:findLimiter(l.name)if not K then error(\"unknown limiter \"..l.name)end;l.name=nil;l.limiter=K;if l.key then a.call(\"string\",\"create\",l.key)end end,delete=function(l)if l.key then a.call(\"string\",\"delete\",l.key)end end,jsonval=function(self)local L={}for M,s in pairs(self.data)do L[M]=s end;if L.derived_key then L.derived_key=nil;L.key=nil elseif L.key then L.key=L.key.string end;L.name=L.limiter.name;L.limiter=nil;setmetatable(L,H)local N={[self.condition]=L}return N end})c.condition.add(\".delay\",{parse=function(l,m)m:assert_jsontype(l,\"number\",\"delay by <number> please\")end})c.action.add(\"tag\",{parse=function(l,m)m:assert_jsontype(l,\"string\",\"\\\"tag\\\" value must be a string\")return m:parseInterpolatedString(l)end,init=function(l)a.call(\"string\",\"create\",l)end,delete=function(l)a.call(\"string\",\"delete\",l)end,jsonval=function(self)return{tag=self.data.string}end})c.action.add(\"accept\",{parse=function(l,m)m:assert_type(l,\"table\",\"\\\"accept\\\" value must be an object\")m:assert_table_size(l,0,\"\\\"accept\\\" value must be empty\")end})c.action.add(\"reject\",{parse=function(l,m)m:assert_type(l,\"table\",\"\\\"reject\\\" value must be an object\")end})c.action.add(\"wait\",{parse=function(l,m)m:assert_jsontype(l,\"number\",\"\\\"wait\\\" value must be a number\")end})return c\n"
   "\n"
   "end)\n"
   "\n"
   "module(\"parser\", function()\n"
   "local a=require\"rulecomponent\"local b=require\"dkjson\"local function c(d,e,f)local g=e[f.key]d:pushContext(g,f.key)local h=d.ruleset;if g then d:assert_type(g,f.type,\"wrong type for ruleset %s, expected %s, got %s\",f.key,f.type,d:jsontype(g))local i,j;for k,l in pairs(g)do d:assert_type(k,\"string\",\"wrong key type for %s, expected string, got %s %s\",f.thing,d:jsontype(k),tostring(k))i,j=f.parser_method(d,l,k)d:assert(i,j)d:assert(h[f.key][i.name]==nil,\"%s %s already exists\",f.thing,i.name)h[f.key][i.name]=i end end;d:popContext()return true end;local function m(n,o)if type(n)==type(o)then setmetatable(n,getmetatable(o))end end;local p;do local q=setmetatable({},{__mode=\"k\"})p=function(r,s)local t,u,v=1,1,0;local w=q[r]if w and w.pos<s then t=w.line;u=w.pos end;while true do u=r:find(\"\\n\",u,true)if u and u<s then t=t+1;v=u;u=u+1 else break end end;return t,s-v end end;local function x(y)return function(r,s)local t,z=p(r,s)return{__pos=s,__line=t,__column=z,__jsontype=y,__jsonmeta=true}end end;local A={}function A:jsontype(B)if type(B)==\"table\"then local C=getmetatable(B)return C and C.__jsontype or nil else return type(B)end end;function A:assert(D,j,...)if not D then self:error(j,...)end;return D end;function A:assert_type(B,E,j,...)if j then return self:assert(type(B)==E,j,...)else return self:assert(type(B)==E,\"expected type '%s', got '%s'\",E,type(B))end end;function A:assert_jsontype(B,E,j,...)if j then return self:assert(self:jsontype(B)==E,j,...)else return self:assert(self:jsontype(B)==E,\"expected JSON type '%s', got '%s'\",E,self:jsontype(B))end end;function A:assert_table_size(B,F,j,...)self:assert_type(B,\"table\")local G=0;for H,H in pairs(B)do G=G+1 end;if G~=F then if j then self:error(j,...)else self:error(\"wrong table size, expected %i, got %i\",F,G)end end;return B end;local function I(J)local K=getmetatable(J)if K.__line and K.__column then return K.__line,K.__column end end;local function L(J)local t,M=I(J)if t and M then return(\"line %s column %i\"):format(t,M)else return nil end end;function A:error(j,...)if not j then j=\"unknown error\"end;if select(\"#\",...)>0 then j=j:format(...)end;local N={}for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]if P.name then table.insert(N,P.name)end;local Q=L(P.ctx)if Q then if self.name then table.insert(N,self.name)end;error((\"%s at %s: %s\"):format(table.concat(N,\" in \"),Q,j))end end;if self.name then table.insert(N,self.name)end;if#N>0 then error((\"%s: %s\"):format(table.concat(N,\" in \"),j))else error(j)end end;function A:setInterpolationChecker(R)self.interpolation_checker=R end;function A:checkInterpolatedString(r)if self.interpolation_checker then self.interpolation_checker(r,self)end;return true end;function A:pushContext(S,T)table.insert(self.ctx_stack,{ctx=S,name=T})self.context=self.ctx_stack[#self.ctx_stack]return self end;function A:popContext()table.remove(self.ctx_stack,#self.ctx_stack)self.context=self.ctx_stack[#self.ctx_stack]end;function A:getContext(T)if not T then return self.context and self.context.ctx end;for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]if P.name==T then return P.ctx end end;return nil end;function A:printContext()for O=#self.ctx_stack,1,-1 do local P=self.ctx_stack[O]print(P.name or\"<?>\",self:jsontype(P.ctx)or\"<?>\",L(P.ctx)or\"\")end end;function A:parseFile(U,V)local W,j=io.open(U,\"rb\")if not W then return nil,j end;local X=W:read(\"*a\")W:close()self.name=U;return self:parseJSON(\"ruleset\",X,\"file \"..U,V)end;function A:parseJSON(Y,Z,_,V)self:assert_type(Z,\"string\",\"expected a JSON string\")local g,H,j=b.decode(Z,1,b.null,x(\"object\"),x(\"array\"))self.name=_;local function a0()if not g then self:error(\"Error parsing JSON: \"..j)end;if Y==\"ruleset\"then return self:parseRuleSet(g)elseif Y==\"phase\"then return self:parsePhase(g)elseif Y==\"limiter\"then return self:parseLimiter(g)elseif Y==\"list\"then return self:parseList(g)elseif Y==\"rule\"then return self:parseRule(g)end end;if V then return a0()else local a1,a2=pcall(a0)if not a1 then return nil,a2:match(\"[^:]*:%d+: (.*)\")or a2 else return a2 end end end;function A:parseInterpolatedString(r)for a3 in r:gmatch(\"%$%b{}\")do if not a3:match(\"^%${[%w_]+}\")then self:error(\"invalid variable \\\"%s\\\" in interpolated string\",a3)end end;for a3 in r:gmatch(\"%${?[%w_]*}?\")do if a3:sub(2,2)==\"{\"then if a3:sub(-1)~=\"}\"then self:error(\"missing '}' in interpolated string\")end;a3=a3:sub(3,-2)if a3==\"\"then self:error(\"invalid variable ${} in interpolated string\")elseif a3:match(\"^%d%d+\")then self:error(\"invalid regex capture \\\"%s\\\" in interpolated string. 1-9 only (nginx quirk)\",a3)elseif a3:match(\"^%d.+\")then self:error(\"invalid variable \\\"%s\\\" in interpolated string. can't sart with a number (nginx quirk)\",a3)end else a3=a3:sub(2,-1)end;if a3==\"\"then self:error(\"invalid empty variable in interpolated string\")end end;return{string=r}end;function A:parseRuleSet(g,T)self:pushContext(g,\"ruleset\")self:assert_type(g,\"table\",\"wrong type for ruleset\")c(self,g,{thing=\"limiter\",key=\"limiters\",type=\"table\",parser_method=self.parseLimiter})self:checkLimiters(g.limiters)self.ruleset.name=T or g.name;c(self,g,{thing=\"rule\",key=\"rules\",type=\"table\",parser_method=function(self,g,T)self:pushContext(g,\"rule\")self:assert(type(g)~=\"string\",(\"named rule \\\"%s\\\" cannot be a string referring to another named rule \\\"%s\\\"\"):format(T,tostring(g)))self:popContext()return self:parseRule(g,T)end})c(self,g,{thing=\"list\",key=\"lists\",type=\"table\",parser_method=self.parseList})self.ruleset.phases=self:parsePhaseTable(g.phases)local function a4(J)local a5=getmetatable(J)if a5 and a5.__jsonmeta then setmetatable(J,{line=a5.__line,col=a5.__column})end;for H,l in pairs(J)do if type(l)==\"table\"then a4(l)end end end;a4(self.ruleset)return self.ruleset end;function A:parsePhaseTable(g)self:assert(g~=nil,\"missing phase table (\\\"phases\\\" attribute)\")self:assert_jsontype(g,\"object\",\"phase table must be an object\")self:pushContext(g,\"phase table\")for a6,a7 in pairs(g)do self:assert_type(a6,\"string\",\"phase table entries must be strings\")if self:jsontype(a7)==\"array\"then for O,a8 in ipairs(a7)do if type(a8)==\"string\"or self:jsontype(a8)==\"array\"or self:jsontype(a8)==\"object\"then a7[O]=self:parseList(a8)else self:error(\"invalid rule list type: %s\",self:jsontype(a8))end end elseif type(a7)==\"string\"then g[a6]={self:parseList(a7)}elseif self:jsontype(a7)==\"object\"then g[a6]=self:parseList(a7)end end;self:popContext()return g end;function A:getList(T)local a8=self.ruleset.lists[T]if not a8 and self.external then a8=self.external.lists[T]end;return a8 end;function A:parseList(g,T)if type(g)==\"string\"then return self:assert(self:getList(g),([[named list \"%s\" not found]]):format(g))end;self:pushContext(g,\"list\")local a8;if self:jsontype(g)==\"object\"then if T then self:assert(T==g.name,\"rule list 'name' attribute must match outside list name\")else T=tostring(g.name)end;g=g.rules end;self:assert_jsontype(g,\"array\",\"rule list must be an array\")local a9={}for H,l in ipairs(g)do table.insert(a9,self:parseRule(l))end;self:popContext()a8={name=T,rules=a9}m(a8,g)return a8 end;function A:getRule(T)local aa=self.ruleset.rules[T]if not aa and self.external then aa=self.external.rules[T]end;return aa end;function A:parseRule(g,T)self:pushContext(g,\"rule\")local ab;if type(g)==\"string\"then ab=self:getRule(g)self:assert(ab,([[named rule \"%s\" not found]]):format(g))self:popContext()return ab end;self:assert_type(g,\"table\",\"invalid rule data type: \"..type(g))self:assert_jsontype(g,\"object\",(\"invalid rule data type: %s\"):format(self:jsontype(g)))if g[\"if\"]or g[\"if-any\"]or g[\"if-all\"]or g[\"then\"]then self:assert(not g[\"always\"],[[\"always\" clause can't be present in if/then rule]])self:assert(not g[\"switch\"],[[\"switch\" clause can't be present in if/then rule]])end;if g[\"then\"]then if g[\"if\"]and(g[\"if-any\"]or g[\"if-all\"])or g[\"if-any\"]and g[\"if-all\"]then self:error(\"only one of \\\"if\\\", \\\"if-any\\\" or \\\"if-all\\\" allowed in if/then rule\")end;local ac;if g[\"if\"]then ac=self:parseCondition(g[\"if\"])elseif g[\"if-any\"]or g[\"if-all\"]then local ad={}for H,l in ipairs(g[\"if-any\"]or g[\"if-all\"])do ac=self:assert(self:parseCondition(l))table.insert(ad,ac)end;ac={[g[\"if-any\"]and\"any\"or\"all\"]=ad}m(ac,g[\"if\"]or g[\"if-any\"]or g[\"if-all\"])g[\"if-any\"]=nil;g[\"if-all\"]=nil end;g[\"if\"]=ac elseif g[\"always\"]then g[\"if\"]={[\"true\"]={}}g[\"then\"]=g[\"always\"]g[\"always\"]=nil elseif next(g)==nil then self:error(\"empty rule not allowed\")else self:error(\"rule must have at least an \\\"if\\\", \\\"then\\\", or \\\"always\\\" attribute\")end;if not g.name then g.name=T end;if g[\"if\"]then g[\"then\"]=self:parseActions(g[\"then\"],\"then\")g[\"else\"]=self:parseActions(g[\"else\"],\"else\")end;if g.key then g.key=self:parseInterpolatedString(g.key)end;self:popContext()return g end;function A:parseCondition(g)self:pushContext(g,\"condition\")local ac;if type(g)==\"string\"then ac={[g]={}}elseif type(g)==\"table\"then self:assert_jsontype(g,\"object\",\"condition cannot be an array, must be an object\")self:assert_table_size(g,1,\"condition object must have exactly one attribute (the condition name)\")ac=g else self:error(\"wrong type (%s) for condition\",type(g))end;self:popContext()self:pushContext(g,\"condition \"..next(ac))ac=a.condition.parse(ac,self)self:popContext()m(ac,g)return ac end;function A:parseAction(g)self:pushContext(g,\"action\")local ae;if type(g)==\"string\"then ae={[g]={}}elseif self:jsontype(g)==\"object\"then self:assert(next(g,next(g))==nil,\"action object must have only 1 attribute -- the action name\")ae=g else self:error(\"action must be string on 1-attribute object, but instead was a %s\",self:jsontype(g))end;self:popContext()self:pushContext(g,(\"\\\"%s\\\" action\"):format(next(ae)))m(ae,g)ae=a.action.parse(ae,self)self:popContext()return ae end;function A:parseActions(g,T)if g==nil then return{}end;self:pushContext(g,T and(\"\\\"%s\\\" actions\"):format(T)or nil)local af={}m(af,g)if self:jsontype(g)==\"object\"or type(g)==\"string\"or#g==0 and next(g)~=nil then table.insert(af,self:parseAction(g))elseif type(g)==\"table\"then for H,l in ipairs(g)do table.insert(af,self:parseAction(l))end end;self:popContext()return af end;function A:parseTimeInterval(g,j)if j then j=\" for \"..j end;local ag=self:jsontype(g)if ag==\"number\"then return g elseif ag==\"string\"then local ah,ai=g:match(\"^([%d.]+)([%w_]*)\")local aj;ah=tonumber(ah)self:assert(ah and ai,(\"invalid time string \\\"%s\\\"%s\"):format(g,j))if ai==\"ms\"or ai:match(\"^millisec(ond(s?))?\")then aj=.01 elseif ai==\"\"or ai==\"s\"or ai:match(\"^sec(ond(s?))?\")then aj=1 elseif ai==\"m\"or ai:match(\"^min(ute(s)?)?\")then aj=60 elseif ai==\"h\"or ai:match(\"^hour(s?)\")then aj=3600 elseif ai==\"d\"or ai:match(\"^day(s)?\")then aj=86400 elseif ai==\"w\"or ai==\"wk\"or ai:match(\"^week(s)?\")then aj=604800 elseif ai==\"M\"or ai:match(\"^month(s)?\")then aj=2628001 else self:error(\"unknown time unit \\\"%s\\\"%s\",ai,j)end;return ah*aj else self:error(\"invalid time inteval type \\\"%s\\\"%s\",self:jsontype(g),j)end end;function A:getLimiter(T)local ak=self.ruleset.limiters[T]if not ak and self.external then ak=self.external.limiters[T]end;return ak end;function A:parseLimiter(g,T)self:pushContext(g,\"limiter\")if not g.name then g.name=T end;g.interval=self:parseTimeInterval(g.interval,\"interval value\")self:assert(g.interval>=60,\"\\\"interval\\\" value must be >= 60 seconds\")self:assert(g.limit,\"missing \\\"limit\\\" value\")g.limit=self:assert(tonumber(g.limit),\"invalid \\\"limit\\\" value, must be a number\")self:assert(g.limit>=0,\"\\\"limit\\\" value must be >= 0\")if g.sync_steps then g.sync_steps=self:assert(tonumber(g.sync_steps),\"invalid \\\"sync-steps\\\" value\")end;if g.burst then self:assert_type(g.burst,\"string\",\"invalid \\\"burst\\\" value type\")end;if g[\"burst-expire\"]then g.burst_expire=self:parseTimeInterval(g[\"burst-expire\"],\"burst_expire value\")g[\"burst-expire\"]=nil end;self:assert_type(g.name,\"string\",\"invalid limiter name\")self:popContext()return g end;function A:checkLimiters(g)if not g then return true end;self:pushContext(g,\"limiters\")for H,l in pairs(g)do self:pushContext(l,(\"limiter \\\"%s\\\"\"):format(l.name))if l.burst then self:assert(g[l.burst],(\"limiter references unknown burst limiter \\\"%s\\\"\"):format(l.burst))end;self:popContext()end;self:popContext()end;local al={__index=A}local function am(f)local d={name=\"<?>\",ctx_stack={},ruleset={limiters={},rules={},lists={},phases={}}}f=f or{}if f.external then d.external={}for k,G in pairs{lists=\"list\",rules=\"rule\",limiters=\"limiter\"}do local an=f.external[G]d.external[k]=setmetatable({},{__index=function(J,ao)local i=an(ao)if i then if type(i)~=\"table\"then i={name=ao,external=true}else error(\"how do?...\")end end;J[ao]=i;return i end})end end;setmetatable(d,al)return d end;return{new=am,RuleComponent=a}\n"
   "\n"
   "end)\n"
   "\n"
   "module(\"ruleset\", function()\n"
   "local a=require\"rulecomponent\"local b=require\"binding\"local c=require\"dkjson\"local d;local e=function(f,g)local h={}for i,j in pairs(f)do h[i]=j end;if g then return h else return setmetatable(h,getmetatable(f))end end;local function k(l,f,m)assert(m.name,(\"a %s must have a name\"):format(l))assert(not f[m.name],(\"%s \\\"%s\\\" already exists\"):format(l,m.name))end;local function n(o)if type(o)==\"string\"then return o elseif type(o)==\"table\"then return o.name else return o end end;local function p(f,q)local h={}setmetatable(h,getmetatable(f))for i,j in pairs(f)do if not q[i]then h[i]=j end end;return h end;local function r(f)local s={}for i in pairs(f)do table.insert(s,i)end;table.sort(s)return s end;local t={}local u={}u.ruleset={__index=t,__jsonorder={\"name\",\"info\",\"phases\",\"limiters\",\"lists\",\"rules\"}}u.phase={new=function(v,m)return setmetatable({name=v,lists=m},u.phase)end,__index={toJSON=function(self)return c.encode(self,{indent=true})end},__jsonval=function(self)local w={}for x,y in pairs(self.lists)do table.insert(w,y.name)end;return w end}u.rules={__jsonorder=r}u.lists={__jsonorder=r}u.limiters={__jsonorder=r}u.list={new=function(m)return setmetatable(m,u.list)end,__index={toJSON=function(self)return c.encode(self,{indent=true})end},__jsonorder={\"name\",\"info\",\"rules\"},__jsonval=function(self)local z={}for x,A in pairs(self.rules)do table.insert(z,A.name)end;if self.info then return setmetatable({info=self.info,rules=z},getmetatable(self))else return setmetatable(z,getmetatable(self))end end}local B={__index={toJSON=function(self)return c.encode(self,{indent=true})end}}u.rule={new=function(m,C)local A=setmetatable(m,u.rule)if m[\"if\"]then m[\"if\"]=a.condition.new(A[\"if\"],C)end;for x,D in pairs{\"then\",\"else\"}do if m[D]then local E=setmetatable({},B)for x,j in pairs(m[D])do table.insert(E,a.action.new(j,C))end;m[D]=E end end;return m end,__index={toJSON=function(self)return c.encode(self,{indent=true})end},__jsonorder={\"name\",\"info\",\"key\",\"if\",\"if-any\",\"if-all\",\"then\",\"else\"},__jsonval=function(self)if#self[\"else\"]<=1 or#self[\"then\"]<=1 or self.key or self[\"if\"].condition==\"any\"or self[\"if\"].condition==\"all\"or self[\"refs\"]then local F=e(self)if self[\"if\"].condition==\"any\"then F[\"if-any\"]=F[\"if\"].data;F[\"if\"]=nil end;if self[\"if\"].condition==\"all\"then F[\"if-all\"]=F[\"if\"].data;F[\"if\"]=nil end;if#self[\"then\"]==0 then F[\"then\"]=nil end;if#self[\"then\"]==1 then F[\"then\"]=self[\"then\"][1]end;if#self[\"else\"]==0 then F[\"else\"]=nil end;if#self[\"else\"]==1 then F[\"else\"]=self[\"else\"][1]end;if self.key then self.key=self.key.string end;if F.refs then F.refs=nil end;return F end;return self end}u.limiter={new=function(m)return setmetatable(m,u.limiter)end,__index={toJSON=function(self)return c.encode(self,{indent=true})end},__jsonorder={\"name\",\"info\",\"limit\",\"interval\",\"burst\",\"burst-expire\"},__jsonval=function(self)if self.burst then local h=e(self)h.burst=h.burst[\"name\"]return h end;return self end}function t:findLimiter(v)return self.limiters[n(v)]end;function t:addLimiter(m,G)if m.__already_loaded_as_burst_limiter then m.__already_loaded_as_burst_limiter=nil;return nil end;k(\"limiter\",self.limiters,m)local H=u.limiter.new(m)self.limiters[m.name]=H;if H.burst then local I=self:findLimiter(H.burst)if not I then I=self:addLimiter(G[H.burst],G)G[H.burst].__already_loaded_as_burst_limiter=true;H.burst=I end end;b.call(\"limiter\",\"create\",H)return H end;function t:deleteLimiter(H)assert(self.limiters[H.name]==H,\"tried deleting unexpected limiter of the same name\")self.limiters[H.name]=nil;b.call(\"limiter\",\"delete\",H)end;function t:findRule(v)return self.rules[n(v)]end;function t:addRule(m)if not m.name then m.name=self:uniqueName(\"rule\")else k(\"rule\",self.rules,m)end;local A=u.rule.new(m,self)self.rules[m.name]=A;b.call(\"rule\",\"create\",A)return A end;function t:deleteRule(A)assert(self.rules[A.name]==A,\"tried deleting unexpected rule of the same name\")for J,y in pairs(self.lists)do for x,K in ipairs(y)do assert(K~=A,(\"can't delete rule \\\"%s\\\", it's used in list \\\"%s\\\"\"):format(A.name,J))end end;self.rules[A.name]=nil;if A[\"if\"]then a.condition.delete(A[\"if\"],self)end;for x,D in pairs{\"then\",\"else\"}do if A[D]then local E=A[D]for x,L in pairs(E)do a.action.delete(L,self)end;A[D]={}end end;b.call(\"rule\",\"delete\",A)end;function t:findList(v)return self.lists[n(v)]end;function t:addList(m)if not m.name then m.name=self:uniqueName(\"list\")else k(\"list\",self.lists,m)end;for M,N in ipairs(m.rules)do m.rules[M]=self:findRule(N.name)or self:addRule(N)end;local y=u.list.new(m)self.lists[m.name]=y;b.call(\"list\",\"create\",y)return y end;function t:deleteList(y)assert(self.lists[y.name]==y,\"tried deleting unexpected list of the same name\")for O,P in pairs(self.phases)do for x,Q in ipairs(P)do assert(Q~=y,(\"can't delete list \\\"%s\\\", it's used in phase \\\"%s\\\"\"):format(y.name,O))end end;self.lists[y.name]=nil;b.call(\"list\",\"delete\",y)end;function t:setPhaseTable(m)if self.phases then for x,P in pairs(self.phases)do b.call(\"phase\",\"delete\",P)end end;self.phases={}for i,j in pairs(m)do local P=u.phase.new(i,m)for M,y in pairs(j)do P.lists[M]=self:findList(y)or self:addList(y)end;self.phases[i]=P;b.call(\"phase\",\"create\",P)end;return self.phases end;function t:uniqueName(o)local R={ruleset={},rule=self.rules,list=self.lists,limiter=self.limiters}local S=R[o]if S==nil then error(\"don't knoq how to generate unique name for \"..tostring(o))end;return assert(d.uniqueName(o,S,self),\"unique name can't be nil\")end;function t:toJSON()local T={name=self.name,info=self.info,rules=e(self.rules),lists=e(self.lists),limiters=e(self.limiters),phases=self.phases}setmetatable(T,u.ruleset)local U={name=true}for x,V in ipairs({\"rules\",\"lists\",\"limiters\",\"phases\"})do local W=T[V]or{}for i,o in pairs(W)do W[i]=p(o,U)end end;return c.encode(T,{indent=true})end;function t:destroy()self:setPhaseTable({})for x,y in pairs(self.lists)do self:deleteList(y)end;for x,A in pairs(self.rules)do self:deleteRule(A)end;for x,H in pairs(self.limiters)do self:deleteLimiter(H)end;b.call(\"ruleset\",\"delete\",self)end;d={new=function(m)local C=setmetatable({rules=setmetatable({},u.rules),lists=setmetatable({},u.lists),limiters=setmetatable({},u.limiters),phases={},name=m and m.name or nil},u.ruleset)if not C.name then C.name=C:uniqueName(\"ruleset\")end;if m then for x,j in pairs(m.limiters)do C:addLimiter(j,m.limiters)end;for x,j in pairs(m.rules)do C:addRule(j)end;for x,j in pairs(m.lists)do C:addList(j)end;C:setPhaseTable(m.phases)end;b.call(\"ruleset\",\"create\",C)return C end,newLimiter=u.limiter.new,newPhase=u.phase.new,newList=u.list.new,newRule=u.rule.new,uniqueName=function(X,S,C)error(\"uniqueName must be configured outside the Ruleset module\")end,RuleComponent=a}return d\n"
   "\n"
   "end)\n"
   "\n"
   "\n"
   "return main()\n"}
};
const int wfx_redis_lua_scripts_count=3;
