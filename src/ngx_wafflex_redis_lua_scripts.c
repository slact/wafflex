#include <ngx_wafflex_redis_lua_scripts.h>

wfx_redis_lua_scripts_t wfx_redis_lua_scripts = {
  {"init", 
   "--lua environs initializer\n"
   "return function(package_loader, manager, init_bind_cfunc, ruleset_confset_cfunc)\n"
   "  package.path = \"\"\n"
   "  package.cpath= \"\"\n"
   "  setmetatable(package.preload, {__index = function(self, name)\n"
   "    local pkg = package_loader(name)\n"
   "    local loader\n"
   "    if pkg then\n"
   "      loader = function()\n"
   "        return pkg\n"
   "      end\n"
   "      self[name]=loader\n"
   "    end\n"
   "    return loader\n"
   "  end})\n"
   "  \n"
   "  _G.Parser = require \"parser\"\n"
   "  _G.Ruleset = require \"ruleset\"\n"
   "  _G.Binding = require \"binding\"\n"
   "  Binding.require_create_userdata = true\n"
   "  Binding.require_binding = true\n"
   "  \n"
   "  _G.mm = require \"mm\"\n"
   "  \n"
   "  if init_bind_cfunc then\n"
   "    init_bind_cfunc(Binding.set)\n"
   "  end\n"
   "  \n"
   "  local parsed_ruleset_data = {}\n"
   "  \n"
   "  _G.parseRulesetFile = function(prefix, path, ruleset_name)\n"
   "    local p = Parser.new()\n"
   "    \n"
   "    local fullpath\n"
   "    if path:match(\"^/\") then\n"
   "      fullpath = path\n"
   "    elseif prefix then\n"
   "      fullpath = (prefix:match(\"/$\") and \"%s%s\" or \"%s/%s\"):format(prefix, path)\n"
   "    end\n"
   "    \n"
   "    local ok, res = pcall(p.parseFile, p, fullpath)\n"
   "    if not ok then\n"
   "      return nil, (res:match(\"[^:]*:%d+: (.*)\") or res)\n"
   "    end\n"
   "    \n"
   "    if ruleset_name then\n"
   "      res.name = ruleset_name\n"
   "    end\n"
   "    if not res.name then\n"
   "      local filename = path:match(\"[^/]+$\")\n"
   "      local sansext = filename:match(\"(.*)%.[^.]+$\")\n"
   "      filename = sansext or filename\n"
   "      res.name = filename\n"
   "    end\n"
   "    \n"
   "    if res.name and parsed_ruleset_data[res.name] then\n"
   "      return nil, (\"ruleset \\\"%s\\\" already exists\"):format(res.name)\n"
   "    end\n"
   "    parsed_ruleset_data[res.name] = res\n"
   "    \n"
   "    return res\n"
   "  end\n"
   "  \n"
   "  local deferred = setmetatable({}, {__index = function(t,k)\n"
   "    t[k]={}\n"
   "    return t[k]\n"
   "  end})\n"
   "  \n"
   "  _G.deferRulesetCreation = function(name, conf_ref)\n"
   "    if not parsed_ruleset_data[name] then\n"
   "      return nil, (\"unknown ruleset \\\"%s\\\"\"):format(name)\n"
   "    end\n"
   "    table.insert(deferred[name], conf_ref)\n"
   "    return true\n"
   "  end\n"
   "  \n"
   "  _G.createDeferredRulesets = function()\n"
   "    for name, def in pairs(deferred) do\n"
   "      for _, ref in pairs(def) do\n"
   "        local rsdata = parsed_ruleset_data[name]\n"
   "        local rs = Ruleset.new(rsdata)\n"
   "        ruleset_confset_cfunc(rs, ref)\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function printFunctions(pattern)\n"
   "    for k,v in pairs(_G) do\n"
   "      if type(v) == \"function\" then\n"
   "        if not pattern or k:match(pattern) then\n"
   "          local info = debug.getinfo(v)\n"
   "          print((\"%s: function %s (%s %s %s:%i-%i)\"):format(tostring(k), tostring(v), info.what, info.namewhat, info.short_src, info.linedefined, info.lastlinedefined))\n"
   "        end\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "end\n"},

  {"ipc", 
   "local handlers = {}\n"
   "local rawget = rawget\n"
   "function setAlertHandler(name, callback)\n"
   "  rawset(handlers, name, callback)\n"
   "end\n"
   "function getAlertHandler(name, data_ptr)\n"
   "  return rawget(handlers, name)\n"
   "end\n"},

  {"limiter", 
   "local mm = require \"mm\"\n"
   "local setmetatable, rawset, rawget, tinsert = setmetatable, rawset, rawget, table.insert\n"
   "  local function tabling_meta(depth, ephemeron)\n"
   "    return {__index = function(t,k)\n"
   "      local v = {}\n"
   "      if depth > 0 then\n"
   "        setmetatable(v, tabling_meta(depth-1, type(ephemeron) == number and ephemeron-1 or ephemeron))\n"
   "      end\n"
   "      t[k]=v\n"
   "      return v\n"
   "    end, __mode = (ephemeron == true or (ephemeron and ephemeron > 0)) and \"k\" or nil }\n"
   "  end\n"
   "\n"
   "local limiters = setmetatable({}, tabling_meta(2))\n"
   "\n"
   "return function(manager)\n"
   "  function findLimiterValue(limiter_ptr, key)\n"
   "    local limit = rawget(limiters, limiter_ptr)\n"
   "    if not limit then \n"
   "      return nil\n"
   "    end\n"
   "    local data = rawget(limit, key)\n"
   "    if not data then\n"
   "      return nil\n"
   "    end\n"
   "    return data\n"
   "  end\n"
   "\n"
   "  function setLimiterValue(limiter_ptr, key, limit_data_ptr)\n"
   "    limiters[limiter_ptr][key]=limit_data_ptr\n"
   "    \n"
   "    --check uniqueness\n"
   "    --[[\n"
   "    local uniq = {}\n"
   "    mm(limiters[limiter_ptr])\n"
   "    for k, v in pairs(limiters[limiter_ptr]) do\n"
   "      assert(not uniq[v], \"found two different keys mapping to same limiter value\")\n"
   "      uniq[v] = true\n"
   "    end\n"
   "    ]]\n"
   "    \n"
   "    return limit_data_ptr\n"
   "  end\n"
   "    \n"
   "  function unsetLimiterValue(limiter_ptr, key, limit_data_ptr)\n"
   "    --mm(limiters)\n"
   "    local limit = rawget(limiters, limiter_ptr)\n"
   "    local data = rawget(limit, key)\n"
   "    if data then\n"
   "      assert(type(data) == \"userdata\")\n"
   "      if limit_data_ptr then\n"
   "        assert(data == limit_data_ptr)\n"
   "      end\n"
   "      rawset(limit, key, nil)\n"
   "      if next(limit) == nil then\n"
   "        rawset(limiters, limiter_ptr, nil)\n"
   "      end\n"
   "      return true\n"
   "    else\n"
   "      return nil\n"
   "    end\n"
   "  end\n"
   "\n"
   "  if not manager then\n"
   "    local reqs = {}\n"
   "    function addLimiterValueRequest(request_ptr)\n"
   "      local first_time = reqs[request_ptr] == nil\n"
   "      reqs[request_ptr] = request_ptr\n"
   "      return first_time\n"
   "    end\n"
   "    function completeLimiterValueRequest(request_ptr)\n"
   "      if reqs[request_ptr] ~= nil then\n"
   "        assert(reqs[request_ptr] == request_ptr)\n"
   "        reqs[request_ptr] = true\n"
   "        return true\n"
   "      else\n"
   "        return nil\n"
   "      end\n"
   "    end\n"
   "    function cleanupLimiterValueRequest(request_ptr)\n"
   "      reqs[request_ptr]=nil\n"
   "    end\n"
   "  end\n"
   "end\n"},

  {"redis", 
   "local mm = require \"mm\"\n"
   "local Redis = require \"redis\"\n"
   "\n"
   "local function parseRedisUrl(url)\n"
   "  local host, port, pass, db\n"
   "  local cur, rest\n"
   "  \n"
   "  mm(url)\n"
   "  \n"
   "  url = url:match(\"^redis://(.*)\") or url\n"
   "  pass, rest = url:match(\"^:([^@]+)@(.*)\")\n"
   "  if pass then url = rest end\n"
   "  host, rest = url:match(\"^([^:/]+)(.*)\")\n"
   "  if host then url = rest end\n"
   "  port, rest = url:match(\"^:(%d+)(.*)\")\n"
   "  if port then port=tonumber(port); url = rest end\n"
   "  db = url:match(\"^/(%d+)\")\n"
   "  if db then db = tonumber(db) end\n"
   "  \n"
   "  local ret = {\n"
   "    url=(\"redis://%s%s:%i%s\"):format(pass and \":\"..pass..\"@\" or \"\", host, port, db and \"/\"..db or \"\"),\n"
   "    host = host,\n"
   "    port = port,\n"
   "    pass = pass,\n"
   "    db = db\n"
   "  }\n"
   "  mm(ret)\n"
   "  \n"
   "  return ret\n"
   "  \n"
   "end\n"
   "\n"
   "return function(redis_connect, redis_close, redis_command, loadscripts, timeout)\n"
   "  assert(type(redis_connect) == \"function\")\n"
   "  assert(type(redis_command) == \"function\")\n"
   "  assert(type(loadscripts) == \"function\")\n"
   "  assert(type(timeout) == \"function\")\n"
   "  Redis.c.redis_connect = redis_connect\n"
   "  Redis.c.redis_close = redis_close\n"
   "  Redis.c.redis_command = redis_command\n"
   "  Redis.c.loadscripts = loadscripts\n"
   "  Redis.c.timeout = timeout\n"
   "\n"
   "  local redises = {}\n"
   "  \n"
   "  function registerRedis(url)\n"
   "    local exists = redises[url]\n"
   "    if exists then return exists end\n"
   "    \n"
   "    local parsedUrl = parseRedisUrl(url)\n"
   "    \n"
   "    local r = Redis.new(parsedUrl.host, parsedUrl.port, parsedUrl.pass, parsedUrl.db)\n"
   "    redises[parsedUrl.url]=r\n"
   "    mm(redises)\n"
   "    return parsedUrl.url\n"
   "  end\n"
   "  \n"
   "  function connectRedises()\n"
   "    for url, r in pairs(redises) do\n"
   "      r:connect()\n"
   "    end\n"
   "  end\n"
   "  \n"
   "end\n"},

  {"tag", 
   "local tags = {}\n"
   "local tconcat = table.concat\n"
   "local rawset, rawget = rawset, rawget\n"
   "\n"
   "function findTag(ref, key)\n"
   "  local mytags = rawget(tags, ref)\n"
   "  return mytags and rawget(mytags, key) or nil\n"
   "end\n"
   "\n"
   "function setTag(ref, key)\n"
   "  local mytags = rawget(tags, ref)\n"
   "  if not mytags then\n"
   "    rawset(tags, ref, {[key]=true})\n"
   "    return true\n"
   "  else\n"
   "    rawset(mytags, key, true)\n"
   "    return nil\n"
   "  end\n"
   "end\n"
   "function clearTags(ref)\n"
   "  rawset(tags, ref, nil)\n"
   "end\n"},

  {"tracer", 
   "local mm = require \"mm\"\n"
   "return function(ngx_cached_msec_time, ngx_cached_time, ngx_add_request_cleanup_handler, ngx_error_log)\n"
   "  local ngx = {\n"
   "    time_msec = function()\n"
   "      local sec, msec = ngx_cached_msec_time()\n"
   "      return sec + msec/1000\n"
   "    end,\n"
   "    time_cached = ngx_cached_time,\n"
   "    error_log = ngx_error_log,\n"
   "    add_request_cleanup_handler = ngx_add_request_cleanup_handler\n"
   "  }\n"
   "\n"
   "  local tracers = {}\n"
   "  \n"
   "  local Tracer = {}\n"
   "  local tracer_mt = {__index = Tracer}\n"
   "\n"
   "  local function tracerCleaner(ref)\n"
   "    print(\"CLEANED UP AFTER TRACER\")\n"
   "    tracers[ref] = nil\n"
   "  end\n"
   "  \n"
   "  function newTracer(ref_type, req_ref)\n"
   "    local tracer = {\n"
   "      stack = {},\n"
   "      complete = {},\n"
   "      defer = 0,\n"
   "      cur = 0,\n"
   "      \n"
   "      profile = true\n"
   "    }\n"
   "    setmetatable(tracer, tracer_mt)\n"
   "    tracers[req_ref] = tracer\n"
   "    if ref_type == \"request\" then\n"
   "      ngx.add_request_cleanup_handler(req_ref, tracerCleaner)\n"
   "    else\n"
   "      error(\"don't know how to do this\")\n"
   "    end\n"
   "    \n"
   "    return tracer\n"
   "  end\n"
   "  \n"
   "  function getTracer(ref_type, req_ref)\n"
   "    local tracer =  tracers[req_ref] or newTracer(ref_type, req_ref)\n"
   "    --mm(tracer)\n"
   "    return tracer\n"
   "  end\n"
   "\n"
   "  function Tracer:push(element, el_name, el_gen, el_ref)\n"
   "    print(\"pushing\", element, el_name, \"defer:\", self.defer)\n"
   "    self.cur = self.cur + 1\n"
   "    local el\n"
   "    if self.defer == 0 then\n"
   "      el = {\n"
   "        type = element,\n"
   "        name = el_name,\n"
   "        --gen = el_gen,\n"
   "        --ref = el_ref,\n"
   "        \n"
   "        time = { }\n"
   "      }\n"
   "      if self.profile then\n"
   "        el.time.start = ngx.time_msec()\n"
   "      end\n"
   "      table.insert(self.stack, self.cur, el)\n"
   "    else\n"
   "      el = self.stack[self.cur]\n"
   "      self.defer = self.defer - 1\n"
   "      assert(el.deferred)\n"
   "      --assert(el.ref == el_ref)\n"
   "      el.deferred = nil\n"
   "      if el.time.defer_start then\n"
   "        el.time.defer = (el.time.defer or 0) + (ngx.time_msec() - el.time.defer_start)\n"
   "        el.time.defer_start = nil\n"
   "      end\n"
   "    end\n"
   "  end\n"
   "  \n"
   "  function Tracer:pop(element, rc, ...)\n"
   "    local el\n"
   "    print(\"popping\", element, rc)\n"
   "    if rc == \"defer\" then\n"
   "      self.defer = self.defer + 1\n"
   "      el = self.stack[self.cur]\n"
   "      assert(el.type == element)\n"
   "      el.deferred = true\n"
   "      if self.profile then\n"
   "        el.time.defer_start = ngx.time_msec()\n"
   "      end\n"
   "      if el.time.start then\n"
   "        el.time.run = el.time.run or 0 + (ngx.time_msec() - el.time.start)\n"
   "        el.time.start = nil\n"
   "      end\n"
   "    else\n"
   "      el = self.stack[self.cur]\n"
   "      assert(el.type == element)\n"
   "      el.result = rc\n"
   "      if rc == \"error\" then\n"
   "        el.error = ({...})[1]\n"
   "      end\n"
   "      if el.time.start then\n"
   "        el.time.run = el.time.run or 0 + (ngx.time_msec() - el.time.start)\n"
   "        el.time.total = el.time.run + (el.time.defer or 0)\n"
   "        el.time.start = nil\n"
   "      end\n"
   "      table.remove(self.stack, self.cur)\n"
   "      self:completeElement(el);\n"
   "    end\n"
   "    self.cur = self.cur - 1\n"
   "  end\n"
   "  \n"
   "  function Tracer:log(data_name, data)\n"
   "    local el = self.stack[self.cur]\n"
   "    if not el.data then el.data = {} end\n"
   "    el.data[data_name]=data\n"
   "  end\n"
   "  \n"
   "  function Tracer:log_array(data_name, data)\n"
   "    local el = self.stack[self.cur]\n"
   "    if not el.data then el.data = {} end\n"
   "    if not el.data[data_name] then\n"
   "      el.data[data_name] = {}\n"
   "    end\n"
   "    table.insert(el.data[data_name], data)\n"
   "  end\n"
   "  \n"
   "  local parent_type = {\n"
   "    condition=  \"rule\",\n"
   "    action=     \"rule\",\n"
   "    rule=       \"list\",\n"
   "    list=       \"phase\",\n"
   "    phase=      \"ruleset\",\n"
   "    ruleset=    \"root\"\n"
   "  }\n"
   "  \n"
   "  function Tracer:getTop(element)\n"
   "    mm(self.stack)\n"
   "    if element == \"root\" then\n"
   "      return self.complete\n"
   "    end\n"
   "    local cur\n"
   "    for i = #self.stack, 1, -1 do\n"
   "      cur = self.stack[i]\n"
   "      if cur.type == element then\n"
   "        return cur\n"
   "      end\n"
   "    end\n"
   "    error(\"element type \" .. element .. \" not found in stack\")\n"
   "  end\n"
   "  \n"
   "  function Tracer:completeElement(el)\n"
   "    local parent = self:getTop(parent_type[el.type])\n"
   "    if not parent[el.type] then parent[el.type]={} end\n"
   "    table.insert(parent[el.type], el)\n"
   "  end\n"
   "  \n"
   "  function Tracer:finish()\n"
   "    if self.defer >  0 then\n"
   "      return\n"
   "    end\n"
   "    mm(self)\n"
   "  end\n"
   "end\n"}
};
